(function () {
  'use strict';

  /**
   * returns a list of all elements under the cursor
   * from https://gist.github.com/iddan/54d5d9e58311b0495a91bf06de661380
   *
   * It appears Safari and maybe Opera browsers are missing this;
   * https://developer.mozilla.org/en-US/docs/Web/API/Document/elementsFromPoint
   */

  if (!document.elementsFromPoint) {
    document.elementsFromPoint = elementsFromPoint;
  }
  /* istanbul ignore next: depends on browser native elementFromPoint(x,y) */


  function elementsFromPoint(x, y) {
    var parents = [];
    var parent = void 0;

    do {
      if (parent !== document.elementFromPoint(x, y)) {
        parent = document.elementFromPoint(x, y);
        parents.push(parent);
        parent.style.pointerEvents = 'none';
      } else {
        parent = false;
      }
    } while (parent);

    parents.forEach(function (parent) {
      return parent.style.pointerEvents = 'all';
    });
    return parents;
  }

  var global$1 = (typeof global !== "undefined" ? global :
              typeof self !== "undefined" ? self :
              typeof window !== "undefined" ? window : {});

  /**
   * @this {Promise}
   */
  function finallyConstructor(callback) {
    var constructor = this.constructor;
    return this.then(
      function(value) {
        return constructor.resolve(callback()).then(function() {
          return value;
        });
      },
      function(reason) {
        return constructor.resolve(callback()).then(function() {
          return constructor.reject(reason);
        });
      }
    );
  }

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}

  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function() {
      fn.apply(thisArg, arguments);
    };
  }

  /**
   * @constructor
   * @param {Function} fn
   */
  function Promise$1(fn) {
    if (!(this instanceof Promise$1))
      throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    /** @type {!number} */
    this._state = 0;
    /** @type {!boolean} */
    this._handled = false;
    /** @type {Promise|undefined} */
    this._value = undefined;
    /** @type {!Array<!Function>} */
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise$1._immediateFn(function() {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self)
        throw new TypeError('A promise cannot be resolved with itself.');
      if (
        newValue &&
        (typeof newValue === 'object' || typeof newValue === 'function')
      ) {
        var then = newValue.then;
        if (newValue instanceof Promise$1) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise$1._immediateFn(function() {
        if (!self._handled) {
          Promise$1._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  /**
   * @constructor
   */
  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(
        function(value) {
          if (done) return;
          done = true;
          resolve(self, value);
        },
        function(reason) {
          if (done) return;
          done = true;
          reject(self, reason);
        }
      );
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise$1.prototype['catch'] = function(onRejected) {
    return this.then(null, onRejected);
  };

  Promise$1.prototype.then = function(onFulfilled, onRejected) {
    // @ts-ignore
    var prom = new this.constructor(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise$1.prototype['finally'] = finallyConstructor;

  Promise$1.all = function(arr) {
    return new Promise$1(function(resolve, reject) {
      if (!arr || typeof arr.length === 'undefined')
        throw new TypeError('Promise.all accepts an array');
      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(
                val,
                function(val) {
                  res(i, val);
                },
                reject
              );
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise$1.resolve = function(value) {
    if (value && typeof value === 'object' && value.constructor === Promise$1) {
      return value;
    }

    return new Promise$1(function(resolve) {
      resolve(value);
    });
  };

  Promise$1.reject = function(value) {
    return new Promise$1(function(resolve, reject) {
      reject(value);
    });
  };

  Promise$1.race = function(values) {
    return new Promise$1(function(resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise$1._immediateFn =
    (typeof setImmediate === 'function' &&
      function(fn) {
        setImmediate(fn);
      }) ||
    function(fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /** @suppress {undefinedVars} */
  var globalNS = (function() {
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== 'undefined') {
      return self;
    }
    if (typeof window !== 'undefined') {
      return window;
    }
    if (typeof global$1 !== 'undefined') {
      return global$1;
    }
    throw new Error('unable to locate global object');
  })();

  if (!('Promise' in globalNS)) {
    globalNS['Promise'] = Promise$1;
  } else if (!globalNS.Promise.prototype['finally']) {
    globalNS.Promise.prototype['finally'] = finallyConstructor;
  }

  "function"!=typeof Object.values&&(Object.values=function(e){for(var t=Object.keys(e),n=t.length,r=new Array(n);n--;)r[n]=e[t[n]];return r});

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var _global = createCommonjsModule(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self
    // eslint-disable-next-line no-new-func
    : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
  });

  var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.6.3' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
  });
  var _core_1 = _core.version;

  var _isObject = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var _anObject = function (it) {
    if (!_isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };

  var _fails = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };

  // Thank's IE8 for his funny defineProperty
  var _descriptors = !_fails(function () {
    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  });

  var document$1 = _global.document;
  // typeof document.createElement is 'object' in old IE
  var is = _isObject(document$1) && _isObject(document$1.createElement);
  var _domCreate = function (it) {
    return is ? document$1.createElement(it) : {};
  };

  var _ie8DomDefine = !_descriptors && !_fails(function () {
    return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
  });

  // 7.1.1 ToPrimitive(input [, PreferredType])

  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  var _toPrimitive = function (it, S) {
    if (!_isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var dP = Object.defineProperty;

  var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject(O);
    P = _toPrimitive(P, true);
    _anObject(Attributes);
    if (_ie8DomDefine) try {
      return dP(O, P, Attributes);
    } catch (e) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var _objectDp = {
  	f: f
  };

  var _propertyDesc = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _hide = _descriptors ? function (object, key, value) {
    return _objectDp.f(object, key, _propertyDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var hasOwnProperty = {}.hasOwnProperty;
  var _has = function (it, key) {
    return hasOwnProperty.call(it, key);
  };

  var id = 0;
  var px = Math.random();
  var _uid = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };

  var _redefine = createCommonjsModule(function (module) {
  var SRC = _uid('src');
  var TO_STRING = 'toString';
  var $toString = Function[TO_STRING];
  var TPL = ('' + $toString).split(TO_STRING);

  _core.inspectSource = function (it) {
    return $toString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if (O === _global) {
      O[key] = val;
    } else if (!safe) {
      delete O[key];
      _hide(O, key, val);
    } else if (O[key]) {
      O[key] = val;
    } else {
      _hide(O, key, val);
    }
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
  });

  var _aFunction = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };

  // optional / simple context binding

  var _ctx = function (fn, that, length) {
    _aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };

  var PROTOTYPE = 'prototype';

  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
    var key, own, out, exp;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      // export native or passed
      out = (own ? target : source)[key];
      // bind timers to global for call from export context
      exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
      // extend global
      if (target) _redefine(target, key, out, type & $export.U);
      // export
      if (exports[key] != out) _hide(exports, key, exp);
      if (IS_PROTO && expProto[key] != out) expProto[key] = out;
    }
  };
  _global.core = _core;
  // type bitmap
  $export.F = 1;   // forced
  $export.G = 2;   // global
  $export.S = 4;   // static
  $export.P = 8;   // proto
  $export.B = 16;  // bind
  $export.W = 32;  // wrap
  $export.U = 64;  // safe
  $export.R = 128; // real proto method for `library`
  var _export = $export;

  var toString = {}.toString;

  var _cof = function (it) {
    return toString.call(it).slice(8, -1);
  };

  // fallback for non-array-like ES3 and non-enumerable old V8 strings

  // eslint-disable-next-line no-prototype-builtins
  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return _cof(it) == 'String' ? it.split('') : Object(it);
  };

  // 7.2.1 RequireObjectCoercible(argument)
  var _defined = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };

  // 7.1.13 ToObject(argument)

  var _toObject = function (it) {
    return Object(_defined(it));
  };

  // 7.1.4 ToInteger
  var ceil = Math.ceil;
  var floor = Math.floor;
  var _toInteger = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };

  // 7.1.15 ToLength

  var min = Math.min;
  var _toLength = function (it) {
    return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };

  // 7.2.2 IsArray(argument)

  var _isArray = Array.isArray || function isArray(arg) {
    return _cof(arg) == 'Array';
  };

  var _library = false;

  var _shared = createCommonjsModule(function (module) {
  var SHARED = '__core-js_shared__';
  var store = _global[SHARED] || (_global[SHARED] = {});

  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: _core.version,
    mode: 'global',
    copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
  });
  });

  var _wks = createCommonjsModule(function (module) {
  var store = _shared('wks');

  var Symbol = _global.Symbol;
  var USE_SYMBOL = typeof Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] =
      USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
  };

  $exports.store = store;
  });

  var SPECIES = _wks('species');

  var _arraySpeciesConstructor = function (original) {
    var C;
    if (_isArray(original)) {
      C = original.constructor;
      // cross-realm fallback
      if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
      if (_isObject(C)) {
        C = C[SPECIES];
        if (C === null) C = undefined;
      }
    } return C === undefined ? Array : C;
  };

  // 9.4.2.3 ArraySpeciesCreate(originalArray, length)


  var _arraySpeciesCreate = function (original, length) {
    return new (_arraySpeciesConstructor(original))(length);
  };

  // 0 -> Array#forEach
  // 1 -> Array#map
  // 2 -> Array#filter
  // 3 -> Array#some
  // 4 -> Array#every
  // 5 -> Array#find
  // 6 -> Array#findIndex





  var _arrayMethods = function (TYPE, $create) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    var create = $create || _arraySpeciesCreate;
    return function ($this, callbackfn, that) {
      var O = _toObject($this);
      var self = _iobject(O);
      var f = _ctx(callbackfn, that, 3);
      var length = _toLength(self.length);
      var index = 0;
      var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
      var val, res;
      for (;length > index; index++) if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res;   // map
          else if (res) switch (TYPE) {
            case 3: return true;             // some
            case 5: return val;              // find
            case 6: return index;            // findIndex
            case 2: result.push(val);        // filter
          } else if (IS_EVERY) return false; // every
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };

  var _strictMethod = function (method, arg) {
    return !!method && _fails(function () {
      // eslint-disable-next-line no-useless-call
      arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
    });
  };

  var $forEach = _arrayMethods(0);
  var STRICT = _strictMethod([].forEach, true);

  _export(_export.P + _export.F * !STRICT, 'Array', {
    // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
    forEach: function forEach(callbackfn /* , thisArg */) {
      return $forEach(this, callbackfn, arguments[1]);
    }
  });

  var forEach = _core.Array.forEach;

  var $filter = _arrayMethods(2);

  _export(_export.P + _export.F * !_strictMethod([].filter, true), 'Array', {
    // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
    filter: function filter(callbackfn /* , thisArg */) {
      return $filter(this, callbackfn, arguments[1]);
    }
  });

  var filter = _core.Array.filter;

  var $map = _arrayMethods(1);

  _export(_export.P + _export.F * !_strictMethod([].map, true), 'Array', {
    // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
    map: function map(callbackfn /* , thisArg */) {
      return $map(this, callbackfn, arguments[1]);
    }
  });

  var map = _core.Array.map;

  var TYPED = _uid('typed_array');
  var VIEW = _uid('view');
  var ABV = !!(_global.ArrayBuffer && _global.DataView);
  var CONSTR = ABV;
  var i = 0;
  var l = 9;
  var Typed;

  var TypedArrayConstructors = (
    'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
  ).split(',');

  while (i < l) {
    if (Typed = _global[TypedArrayConstructors[i++]]) {
      _hide(Typed.prototype, TYPED, true);
      _hide(Typed.prototype, VIEW, true);
    } else CONSTR = false;
  }

  var _typed = {
    ABV: ABV,
    CONSTR: CONSTR,
    TYPED: TYPED,
    VIEW: VIEW
  };

  var _redefineAll = function (target, src, safe) {
    for (var key in src) _redefine(target, key, src[key], safe);
    return target;
  };

  var _anInstance = function (it, Constructor, name, forbiddenField) {
    if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
      throw TypeError(name + ': incorrect invocation!');
    } return it;
  };

  // https://tc39.github.io/ecma262/#sec-toindex


  var _toIndex = function (it) {
    if (it === undefined) return 0;
    var number = _toInteger(it);
    var length = _toLength(number);
    if (number !== length) throw RangeError('Wrong length!');
    return length;
  };

  // to indexed object, toObject with fallback for non-array-like ES3 strings


  var _toIobject = function (it) {
    return _iobject(_defined(it));
  };

  var max = Math.max;
  var min$1 = Math.min;
  var _toAbsoluteIndex = function (index, length) {
    index = _toInteger(index);
    return index < 0 ? max(index + length, 0) : min$1(index, length);
  };

  // false -> Array#indexOf
  // true  -> Array#includes



  var _arrayIncludes = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = _toIobject($this);
      var length = _toLength(O.length);
      var index = _toAbsoluteIndex(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var shared = _shared('keys');

  var _sharedKey = function (key) {
    return shared[key] || (shared[key] = _uid(key));
  };

  var arrayIndexOf = _arrayIncludes(false);
  var IE_PROTO = _sharedKey('IE_PROTO');

  var _objectKeysInternal = function (object, names) {
    var O = _toIobject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };

  // IE 8- don't enum bug keys
  var _enumBugKeys = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');

  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

  var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

  var f$1 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return _objectKeysInternal(O, hiddenKeys);
  };

  var _objectGopn = {
  	f: f$1
  };

  var _arrayFill = function fill(value /* , start = 0, end = @length */) {
    var O = _toObject(this);
    var length = _toLength(O.length);
    var aLen = arguments.length;
    var index = _toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
    var end = aLen > 2 ? arguments[2] : undefined;
    var endPos = end === undefined ? length : _toAbsoluteIndex(end, length);
    while (endPos > index) O[index++] = value;
    return O;
  };

  var def = _objectDp.f;

  var TAG = _wks('toStringTag');

  var _setToStringTag = function (it, tag, stat) {
    if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
  };

  var _typedBuffer = createCommonjsModule(function (module, exports) {











  var gOPN = _objectGopn.f;
  var dP = _objectDp.f;


  var ARRAY_BUFFER = 'ArrayBuffer';
  var DATA_VIEW = 'DataView';
  var PROTOTYPE = 'prototype';
  var WRONG_LENGTH = 'Wrong length!';
  var WRONG_INDEX = 'Wrong index!';
  var $ArrayBuffer = _global[ARRAY_BUFFER];
  var $DataView = _global[DATA_VIEW];
  var Math = _global.Math;
  var RangeError = _global.RangeError;
  // eslint-disable-next-line no-shadow-restricted-names
  var Infinity = _global.Infinity;
  var BaseBuffer = $ArrayBuffer;
  var abs = Math.abs;
  var pow = Math.pow;
  var floor = Math.floor;
  var log = Math.log;
  var LN2 = Math.LN2;
  var BUFFER = 'buffer';
  var BYTE_LENGTH = 'byteLength';
  var BYTE_OFFSET = 'byteOffset';
  var $BUFFER = _descriptors ? '_b' : BUFFER;
  var $LENGTH = _descriptors ? '_l' : BYTE_LENGTH;
  var $OFFSET = _descriptors ? '_o' : BYTE_OFFSET;

  // IEEE754 conversions based on https://github.com/feross/ieee754
  function packIEEE754(value, mLen, nBytes) {
    var buffer = new Array(nBytes);
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
    var i = 0;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    var e, m, c;
    value = abs(value);
    // eslint-disable-next-line no-self-compare
    if (value != value || value === Infinity) {
      // eslint-disable-next-line no-self-compare
      m = value != value ? 1 : 0;
      e = eMax;
    } else {
      e = floor(log(value) / LN2);
      if (value * (c = pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * pow(2, eBias - 1) * pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
    buffer[--i] |= s * 128;
    return buffer;
  }
  function unpackIEEE754(buffer, mLen, nBytes) {
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = eLen - 7;
    var i = nBytes - 1;
    var s = buffer[i--];
    var e = s & 127;
    var m;
    s >>= 7;
    for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : s ? -Infinity : Infinity;
    } else {
      m = m + pow(2, mLen);
      e = e - eBias;
    } return (s ? -1 : 1) * m * pow(2, e - mLen);
  }

  function unpackI32(bytes) {
    return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
  }
  function packI8(it) {
    return [it & 0xff];
  }
  function packI16(it) {
    return [it & 0xff, it >> 8 & 0xff];
  }
  function packI32(it) {
    return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
  }
  function packF64(it) {
    return packIEEE754(it, 52, 8);
  }
  function packF32(it) {
    return packIEEE754(it, 23, 4);
  }

  function addGetter(C, key, internal) {
    dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
  }

  function get(view, bytes, index, isLittleEndian) {
    var numIndex = +index;
    var intIndex = _toIndex(numIndex);
    if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
    var store = view[$BUFFER]._b;
    var start = intIndex + view[$OFFSET];
    var pack = store.slice(start, start + bytes);
    return isLittleEndian ? pack : pack.reverse();
  }
  function set(view, bytes, index, conversion, value, isLittleEndian) {
    var numIndex = +index;
    var intIndex = _toIndex(numIndex);
    if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
    var store = view[$BUFFER]._b;
    var start = intIndex + view[$OFFSET];
    var pack = conversion(+value);
    for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
  }

  if (!_typed.ABV) {
    $ArrayBuffer = function ArrayBuffer(length) {
      _anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
      var byteLength = _toIndex(length);
      this._b = _arrayFill.call(new Array(byteLength), 0);
      this[$LENGTH] = byteLength;
    };

    $DataView = function DataView(buffer, byteOffset, byteLength) {
      _anInstance(this, $DataView, DATA_VIEW);
      _anInstance(buffer, $ArrayBuffer, DATA_VIEW);
      var bufferLength = buffer[$LENGTH];
      var offset = _toInteger(byteOffset);
      if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
      byteLength = byteLength === undefined ? bufferLength - offset : _toLength(byteLength);
      if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
      this[$BUFFER] = buffer;
      this[$OFFSET] = offset;
      this[$LENGTH] = byteLength;
    };

    if (_descriptors) {
      addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
      addGetter($DataView, BUFFER, '_b');
      addGetter($DataView, BYTE_LENGTH, '_l');
      addGetter($DataView, BYTE_OFFSET, '_o');
    }

    _redefineAll($DataView[PROTOTYPE], {
      getInt8: function getInt8(byteOffset) {
        return get(this, 1, byteOffset)[0] << 24 >> 24;
      },
      getUint8: function getUint8(byteOffset) {
        return get(this, 1, byteOffset)[0];
      },
      getInt16: function getInt16(byteOffset /* , littleEndian */) {
        var bytes = get(this, 2, byteOffset, arguments[1]);
        return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
      },
      getUint16: function getUint16(byteOffset /* , littleEndian */) {
        var bytes = get(this, 2, byteOffset, arguments[1]);
        return bytes[1] << 8 | bytes[0];
      },
      getInt32: function getInt32(byteOffset /* , littleEndian */) {
        return unpackI32(get(this, 4, byteOffset, arguments[1]));
      },
      getUint32: function getUint32(byteOffset /* , littleEndian */) {
        return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
      },
      getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
        return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
      },
      getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
        return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
      },
      setInt8: function setInt8(byteOffset, value) {
        set(this, 1, byteOffset, packI8, value);
      },
      setUint8: function setUint8(byteOffset, value) {
        set(this, 1, byteOffset, packI8, value);
      },
      setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
        set(this, 2, byteOffset, packI16, value, arguments[2]);
      },
      setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
        set(this, 2, byteOffset, packI16, value, arguments[2]);
      },
      setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
        set(this, 4, byteOffset, packI32, value, arguments[2]);
      },
      setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
        set(this, 4, byteOffset, packI32, value, arguments[2]);
      },
      setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
        set(this, 4, byteOffset, packF32, value, arguments[2]);
      },
      setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
        set(this, 8, byteOffset, packF64, value, arguments[2]);
      }
    });
  } else {
    if (!_fails(function () {
      $ArrayBuffer(1);
    }) || !_fails(function () {
      new $ArrayBuffer(-1); // eslint-disable-line no-new
    }) || _fails(function () {
      new $ArrayBuffer(); // eslint-disable-line no-new
      new $ArrayBuffer(1.5); // eslint-disable-line no-new
      new $ArrayBuffer(NaN); // eslint-disable-line no-new
      return $ArrayBuffer.name != ARRAY_BUFFER;
    })) {
      $ArrayBuffer = function ArrayBuffer(length) {
        _anInstance(this, $ArrayBuffer);
        return new BaseBuffer(_toIndex(length));
      };
      var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
      for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
        if (!((key = keys[j++]) in $ArrayBuffer)) _hide($ArrayBuffer, key, BaseBuffer[key]);
      }
      if (!_library) ArrayBufferProto.constructor = $ArrayBuffer;
    }
    // iOS Safari 7.x bug
    var view = new $DataView(new $ArrayBuffer(2));
    var $setInt8 = $DataView[PROTOTYPE].setInt8;
    view.setInt8(0, 2147483648);
    view.setInt8(1, 2147483649);
    if (view.getInt8(0) || !view.getInt8(1)) _redefineAll($DataView[PROTOTYPE], {
      setInt8: function setInt8(byteOffset, value) {
        $setInt8.call(this, byteOffset, value << 24 >> 24);
      },
      setUint8: function setUint8(byteOffset, value) {
        $setInt8.call(this, byteOffset, value << 24 >> 24);
      }
    }, true);
  }
  _setToStringTag($ArrayBuffer, ARRAY_BUFFER);
  _setToStringTag($DataView, DATA_VIEW);
  _hide($DataView[PROTOTYPE], _typed.VIEW, true);
  exports[ARRAY_BUFFER] = $ArrayBuffer;
  exports[DATA_VIEW] = $DataView;
  });

  // 7.3.20 SpeciesConstructor(O, defaultConstructor)


  var SPECIES$1 = _wks('species');
  var _speciesConstructor = function (O, D) {
    var C = _anObject(O).constructor;
    var S;
    return C === undefined || (S = _anObject(C)[SPECIES$1]) == undefined ? D : _aFunction(S);
  };

  var SPECIES$2 = _wks('species');

  var _setSpecies = function (KEY) {
    var C = _global[KEY];
    if (_descriptors && C && !C[SPECIES$2]) _objectDp.f(C, SPECIES$2, {
      configurable: true,
      get: function () { return this; }
    });
  };

  var ArrayBuffer = _global.ArrayBuffer;

  var $ArrayBuffer = _typedBuffer.ArrayBuffer;
  var $DataView = _typedBuffer.DataView;
  var $isView = _typed.ABV && ArrayBuffer.isView;
  var $slice = $ArrayBuffer.prototype.slice;
  var VIEW$1 = _typed.VIEW;
  var ARRAY_BUFFER = 'ArrayBuffer';

  _export(_export.G + _export.W + _export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

  _export(_export.S + _export.F * !_typed.CONSTR, ARRAY_BUFFER, {
    // 24.1.3.1 ArrayBuffer.isView(arg)
    isView: function isView(it) {
      return $isView && $isView(it) || _isObject(it) && VIEW$1 in it;
    }
  });

  _export(_export.P + _export.U + _export.F * _fails(function () {
    return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
  }), ARRAY_BUFFER, {
    // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
    slice: function slice(start, end) {
      if ($slice !== undefined && end === undefined) return $slice.call(_anObject(this), start); // FF fix
      var len = _anObject(this).byteLength;
      var first = _toAbsoluteIndex(start, len);
      var fin = _toAbsoluteIndex(end === undefined ? len : end, len);
      var result = new (_speciesConstructor(this, $ArrayBuffer))(_toLength(fin - first));
      var viewS = new $DataView(this);
      var viewT = new $DataView(result);
      var index = 0;
      while (first < fin) {
        viewT.setUint8(index++, viewS.getUint8(first++));
      } return result;
    }
  });

  _setSpecies(ARRAY_BUFFER);

  _export(_export.G + _export.W + _export.F * !_typed.ABV, {
    DataView: _typedBuffer.DataView
  });

  // getting tag from 19.1.3.6 Object.prototype.toString()

  var TAG$1 = _wks('toStringTag');
  // ES3 wrong here
  var ARG = _cof(function () { return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) { /* empty */ }
  };

  var _classof = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
      // builtinTag case
      : ARG ? _cof(O)
      // ES3 arguments fallback
      : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };

  var _iterators = {};

  // check on default Array iterator

  var ITERATOR = _wks('iterator');
  var ArrayProto = Array.prototype;

  var _isArrayIter = function (it) {
    return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR] === it);
  };

  // 19.1.2.14 / 15.2.3.14 Object.keys(O)



  var _objectKeys = Object.keys || function keys(O) {
    return _objectKeysInternal(O, _enumBugKeys);
  };

  var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    _anObject(O);
    var keys = _objectKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;
    while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
    return O;
  };

  var document$2 = _global.document;
  var _html = document$2 && document$2.documentElement;

  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



  var IE_PROTO$1 = _sharedKey('IE_PROTO');
  var Empty = function () { /* empty */ };
  var PROTOTYPE$1 = 'prototype';

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var createDict = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = _domCreate('iframe');
    var i = _enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    _html.appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
    return createDict();
  };

  var _objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE$1] = _anObject(O);
      result = new Empty();
      Empty[PROTOTYPE$1] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO$1] = O;
    } else result = createDict();
    return Properties === undefined ? result : _objectDps(result, Properties);
  };

  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


  var IE_PROTO$2 = _sharedKey('IE_PROTO');
  var ObjectProto = Object.prototype;

  var _objectGpo = Object.getPrototypeOf || function (O) {
    O = _toObject(O);
    if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  };

  var ITERATOR$1 = _wks('iterator');

  var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR$1]
      || it['@@iterator']
      || _iterators[_classof(it)];
  };

  // 22.1.3.31 Array.prototype[@@unscopables]
  var UNSCOPABLES = _wks('unscopables');
  var ArrayProto$1 = Array.prototype;
  if (ArrayProto$1[UNSCOPABLES] == undefined) _hide(ArrayProto$1, UNSCOPABLES, {});
  var _addToUnscopables = function (key) {
    ArrayProto$1[UNSCOPABLES][key] = true;
  };

  var _iterStep = function (done, value) {
    return { value: value, done: !!done };
  };

  var IteratorPrototype = {};

  // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
  _hide(IteratorPrototype, _wks('iterator'), function () { return this; });

  var _iterCreate = function (Constructor, NAME, next) {
    Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
    _setToStringTag(Constructor, NAME + ' Iterator');
  };

  var ITERATOR$2 = _wks('iterator');
  var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
  var FF_ITERATOR = '@@iterator';
  var KEYS = 'keys';
  var VALUES = 'values';

  var returnThis = function () { return this; };

  var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    _iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS: return function keys() { return new Constructor(this, kind); };
        case VALUES: return function values() { return new Constructor(this, kind); };
      } return function entries() { return new Constructor(this, kind); };
    };
    var TAG = NAME + ' Iterator';
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR$2] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype;
    // Fix native
    if ($anyNative) {
      IteratorPrototype = _objectGpo($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        // Set @@toStringTag to native iterators
        _setToStringTag(IteratorPrototype, TAG, true);
        // fix for some old engines
        if (typeof IteratorPrototype[ITERATOR$2] != 'function') _hide(IteratorPrototype, ITERATOR$2, returnThis);
      }
    }
    // fix Array#{values, @@iterator}.name in V8 / FF
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() { return $native.call(this); };
    }
    // Define iterator
    if (BUGGY || VALUES_BUG || !proto[ITERATOR$2]) {
      _hide(proto, ITERATOR$2, $default);
    }
    // Plug for library
    _iterators[NAME] = $default;
    _iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) _redefine(proto, key, methods[key]);
      } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };

  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
    this._t = _toIobject(iterated); // target
    this._i = 0;                   // next index
    this._k = kind;                // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var kind = this._k;
    var index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return _iterStep(1);
    }
    if (kind == 'keys') return _iterStep(0, index);
    if (kind == 'values') return _iterStep(0, O[index]);
    return _iterStep(0, [index, O[index]]);
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  _iterators.Arguments = _iterators.Array;

  _addToUnscopables('keys');
  _addToUnscopables('values');
  _addToUnscopables('entries');

  var ITERATOR$3 = _wks('iterator');
  var SAFE_CLOSING = false;

  try {
    var riter = [7][ITERATOR$3]();
    riter['return'] = function () { SAFE_CLOSING = true; };
  } catch (e) { /* empty */ }

  var _iterDetect = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7];
      var iter = arr[ITERATOR$3]();
      iter.next = function () { return { done: safe = true }; };
      arr[ITERATOR$3] = function () { return iter; };
      exec(arr);
    } catch (e) { /* empty */ }
    return safe;
  };

  var _arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
    var O = _toObject(this);
    var len = _toLength(O.length);
    var to = _toAbsoluteIndex(target, len);
    var from = _toAbsoluteIndex(start, len);
    var end = arguments.length > 2 ? arguments[2] : undefined;
    var count = Math.min((end === undefined ? len : _toAbsoluteIndex(end, len)) - from, len - to);
    var inc = 1;
    if (from < to && to < from + count) {
      inc = -1;
      from += count - 1;
      to += count - 1;
    }
    while (count-- > 0) {
      if (from in O) O[to] = O[from];
      else delete O[to];
      to += inc;
      from += inc;
    } return O;
  };

  var f$2 = {}.propertyIsEnumerable;

  var _objectPie = {
  	f: f$2
  };

  var gOPD = Object.getOwnPropertyDescriptor;

  var f$3 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
    O = _toIobject(O);
    P = _toPrimitive(P, true);
    if (_ie8DomDefine) try {
      return gOPD(O, P);
    } catch (e) { /* empty */ }
    if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
  };

  var _objectGopd = {
  	f: f$3
  };

  var _typedArray = createCommonjsModule(function (module) {
  if (_descriptors) {
    var LIBRARY = _library;
    var global = _global;
    var fails = _fails;
    var $export = _export;
    var $typed = _typed;
    var $buffer = _typedBuffer;
    var ctx = _ctx;
    var anInstance = _anInstance;
    var propertyDesc = _propertyDesc;
    var hide = _hide;
    var redefineAll = _redefineAll;
    var toInteger = _toInteger;
    var toLength = _toLength;
    var toIndex = _toIndex;
    var toAbsoluteIndex = _toAbsoluteIndex;
    var toPrimitive = _toPrimitive;
    var has = _has;
    var classof = _classof;
    var isObject = _isObject;
    var toObject = _toObject;
    var isArrayIter = _isArrayIter;
    var create = _objectCreate;
    var getPrototypeOf = _objectGpo;
    var gOPN = _objectGopn.f;
    var getIterFn = core_getIteratorMethod;
    var uid = _uid;
    var wks = _wks;
    var createArrayMethod = _arrayMethods;
    var createArrayIncludes = _arrayIncludes;
    var speciesConstructor = _speciesConstructor;
    var ArrayIterators = es6_array_iterator;
    var Iterators = _iterators;
    var $iterDetect = _iterDetect;
    var setSpecies = _setSpecies;
    var arrayFill = _arrayFill;
    var arrayCopyWithin = _arrayCopyWithin;
    var $DP = _objectDp;
    var $GOPD = _objectGopd;
    var dP = $DP.f;
    var gOPD = $GOPD.f;
    var RangeError = global.RangeError;
    var TypeError = global.TypeError;
    var Uint8Array = global.Uint8Array;
    var ARRAY_BUFFER = 'ArrayBuffer';
    var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
    var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
    var PROTOTYPE = 'prototype';
    var ArrayProto = Array[PROTOTYPE];
    var $ArrayBuffer = $buffer.ArrayBuffer;
    var $DataView = $buffer.DataView;
    var arrayForEach = createArrayMethod(0);
    var arrayFilter = createArrayMethod(2);
    var arraySome = createArrayMethod(3);
    var arrayEvery = createArrayMethod(4);
    var arrayFind = createArrayMethod(5);
    var arrayFindIndex = createArrayMethod(6);
    var arrayIncludes = createArrayIncludes(true);
    var arrayIndexOf = createArrayIncludes(false);
    var arrayValues = ArrayIterators.values;
    var arrayKeys = ArrayIterators.keys;
    var arrayEntries = ArrayIterators.entries;
    var arrayLastIndexOf = ArrayProto.lastIndexOf;
    var arrayReduce = ArrayProto.reduce;
    var arrayReduceRight = ArrayProto.reduceRight;
    var arrayJoin = ArrayProto.join;
    var arraySort = ArrayProto.sort;
    var arraySlice = ArrayProto.slice;
    var arrayToString = ArrayProto.toString;
    var arrayToLocaleString = ArrayProto.toLocaleString;
    var ITERATOR = wks('iterator');
    var TAG = wks('toStringTag');
    var TYPED_CONSTRUCTOR = uid('typed_constructor');
    var DEF_CONSTRUCTOR = uid('def_constructor');
    var ALL_CONSTRUCTORS = $typed.CONSTR;
    var TYPED_ARRAY = $typed.TYPED;
    var VIEW = $typed.VIEW;
    var WRONG_LENGTH = 'Wrong length!';

    var $map = createArrayMethod(1, function (O, length) {
      return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
    });

    var LITTLE_ENDIAN = fails(function () {
      // eslint-disable-next-line no-undef
      return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
    });

    var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
      new Uint8Array(1).set({});
    });

    var toOffset = function (it, BYTES) {
      var offset = toInteger(it);
      if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
      return offset;
    };

    var validate = function (it) {
      if (isObject(it) && TYPED_ARRAY in it) return it;
      throw TypeError(it + ' is not a typed array!');
    };

    var allocate = function (C, length) {
      if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
        throw TypeError('It is not a typed array constructor!');
      } return new C(length);
    };

    var speciesFromList = function (O, list) {
      return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
    };

    var fromList = function (C, list) {
      var index = 0;
      var length = list.length;
      var result = allocate(C, length);
      while (length > index) result[index] = list[index++];
      return result;
    };

    var addGetter = function (it, key, internal) {
      dP(it, key, { get: function () { return this._d[internal]; } });
    };

    var $from = function from(source /* , mapfn, thisArg */) {
      var O = toObject(source);
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var iterFn = getIterFn(O);
      var i, length, values, result, step, iterator;
      if (iterFn != undefined && !isArrayIter(iterFn)) {
        for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
          values.push(step.value);
        } O = values;
      }
      if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
      for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
        result[i] = mapping ? mapfn(O[i], i) : O[i];
      }
      return result;
    };

    var $of = function of(/* ...items */) {
      var index = 0;
      var length = arguments.length;
      var result = allocate(this, length);
      while (length > index) result[index] = arguments[index++];
      return result;
    };

    // iOS Safari 6.x fails here
    var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

    var $toLocaleString = function toLocaleString() {
      return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
    };

    var proto = {
      copyWithin: function copyWithin(target, start /* , end */) {
        return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
      },
      every: function every(callbackfn /* , thisArg */) {
        return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      },
      fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
        return arrayFill.apply(validate(this), arguments);
      },
      filter: function filter(callbackfn /* , thisArg */) {
        return speciesFromList(this, arrayFilter(validate(this), callbackfn,
          arguments.length > 1 ? arguments[1] : undefined));
      },
      find: function find(predicate /* , thisArg */) {
        return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
      },
      findIndex: function findIndex(predicate /* , thisArg */) {
        return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
      },
      forEach: function forEach(callbackfn /* , thisArg */) {
        arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      },
      indexOf: function indexOf(searchElement /* , fromIndex */) {
        return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
      },
      includes: function includes(searchElement /* , fromIndex */) {
        return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
      },
      join: function join(separator) { // eslint-disable-line no-unused-vars
        return arrayJoin.apply(validate(this), arguments);
      },
      lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
        return arrayLastIndexOf.apply(validate(this), arguments);
      },
      map: function map(mapfn /* , thisArg */) {
        return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
      },
      reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
        return arrayReduce.apply(validate(this), arguments);
      },
      reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
        return arrayReduceRight.apply(validate(this), arguments);
      },
      reverse: function reverse() {
        var that = this;
        var length = validate(that).length;
        var middle = Math.floor(length / 2);
        var index = 0;
        var value;
        while (index < middle) {
          value = that[index];
          that[index++] = that[--length];
          that[length] = value;
        } return that;
      },
      some: function some(callbackfn /* , thisArg */) {
        return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      },
      sort: function sort(comparefn) {
        return arraySort.call(validate(this), comparefn);
      },
      subarray: function subarray(begin, end) {
        var O = validate(this);
        var length = O.length;
        var $begin = toAbsoluteIndex(begin, length);
        return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
          O.buffer,
          O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
          toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
        );
      }
    };

    var $slice = function slice(start, end) {
      return speciesFromList(this, arraySlice.call(validate(this), start, end));
    };

    var $set = function set(arrayLike /* , offset */) {
      validate(this);
      var offset = toOffset(arguments[1], 1);
      var length = this.length;
      var src = toObject(arrayLike);
      var len = toLength(src.length);
      var index = 0;
      if (len + offset > length) throw RangeError(WRONG_LENGTH);
      while (index < len) this[offset + index] = src[index++];
    };

    var $iterators = {
      entries: function entries() {
        return arrayEntries.call(validate(this));
      },
      keys: function keys() {
        return arrayKeys.call(validate(this));
      },
      values: function values() {
        return arrayValues.call(validate(this));
      }
    };

    var isTAIndex = function (target, key) {
      return isObject(target)
        && target[TYPED_ARRAY]
        && typeof key != 'symbol'
        && key in target
        && String(+key) == String(key);
    };
    var $getDesc = function getOwnPropertyDescriptor(target, key) {
      return isTAIndex(target, key = toPrimitive(key, true))
        ? propertyDesc(2, target[key])
        : gOPD(target, key);
    };
    var $setDesc = function defineProperty(target, key, desc) {
      if (isTAIndex(target, key = toPrimitive(key, true))
        && isObject(desc)
        && has(desc, 'value')
        && !has(desc, 'get')
        && !has(desc, 'set')
        // TODO: add validation descriptor w/o calling accessors
        && !desc.configurable
        && (!has(desc, 'writable') || desc.writable)
        && (!has(desc, 'enumerable') || desc.enumerable)
      ) {
        target[key] = desc.value;
        return target;
      } return dP(target, key, desc);
    };

    if (!ALL_CONSTRUCTORS) {
      $GOPD.f = $getDesc;
      $DP.f = $setDesc;
    }

    $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
      getOwnPropertyDescriptor: $getDesc,
      defineProperty: $setDesc
    });

    if (fails(function () { arrayToString.call({}); })) {
      arrayToString = arrayToLocaleString = function toString() {
        return arrayJoin.call(this);
      };
    }

    var $TypedArrayPrototype$ = redefineAll({}, proto);
    redefineAll($TypedArrayPrototype$, $iterators);
    hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
    redefineAll($TypedArrayPrototype$, {
      slice: $slice,
      set: $set,
      constructor: function () { /* noop */ },
      toString: arrayToString,
      toLocaleString: $toLocaleString
    });
    addGetter($TypedArrayPrototype$, 'buffer', 'b');
    addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
    addGetter($TypedArrayPrototype$, 'byteLength', 'l');
    addGetter($TypedArrayPrototype$, 'length', 'e');
    dP($TypedArrayPrototype$, TAG, {
      get: function () { return this[TYPED_ARRAY]; }
    });

    // eslint-disable-next-line max-statements
    module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
      CLAMPED = !!CLAMPED;
      var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
      var GETTER = 'get' + KEY;
      var SETTER = 'set' + KEY;
      var TypedArray = global[NAME];
      var Base = TypedArray || {};
      var TAC = TypedArray && getPrototypeOf(TypedArray);
      var FORCED = !TypedArray || !$typed.ABV;
      var O = {};
      var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
      var getter = function (that, index) {
        var data = that._d;
        return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
      };
      var setter = function (that, index, value) {
        var data = that._d;
        if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
        data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
      };
      var addElement = function (that, index) {
        dP(that, index, {
          get: function () {
            return getter(this, index);
          },
          set: function (value) {
            return setter(this, index, value);
          },
          enumerable: true
        });
      };
      if (FORCED) {
        TypedArray = wrapper(function (that, data, $offset, $length) {
          anInstance(that, TypedArray, NAME, '_d');
          var index = 0;
          var offset = 0;
          var buffer, byteLength, length, klass;
          if (!isObject(data)) {
            length = toIndex(data);
            byteLength = length * BYTES;
            buffer = new $ArrayBuffer(byteLength);
          } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
            buffer = data;
            offset = toOffset($offset, BYTES);
            var $len = data.byteLength;
            if ($length === undefined) {
              if ($len % BYTES) throw RangeError(WRONG_LENGTH);
              byteLength = $len - offset;
              if (byteLength < 0) throw RangeError(WRONG_LENGTH);
            } else {
              byteLength = toLength($length) * BYTES;
              if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
            }
            length = byteLength / BYTES;
          } else if (TYPED_ARRAY in data) {
            return fromList(TypedArray, data);
          } else {
            return $from.call(TypedArray, data);
          }
          hide(that, '_d', {
            b: buffer,
            o: offset,
            l: byteLength,
            e: length,
            v: new $DataView(buffer)
          });
          while (index < length) addElement(that, index++);
        });
        TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
        hide(TypedArrayPrototype, 'constructor', TypedArray);
      } else if (!fails(function () {
        TypedArray(1);
      }) || !fails(function () {
        new TypedArray(-1); // eslint-disable-line no-new
      }) || !$iterDetect(function (iter) {
        new TypedArray(); // eslint-disable-line no-new
        new TypedArray(null); // eslint-disable-line no-new
        new TypedArray(1.5); // eslint-disable-line no-new
        new TypedArray(iter); // eslint-disable-line no-new
      }, true)) {
        TypedArray = wrapper(function (that, data, $offset, $length) {
          anInstance(that, TypedArray, NAME);
          var klass;
          // `ws` module bug, temporarily remove validation length for Uint8Array
          // https://github.com/websockets/ws/pull/645
          if (!isObject(data)) return new Base(toIndex(data));
          if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
            return $length !== undefined
              ? new Base(data, toOffset($offset, BYTES), $length)
              : $offset !== undefined
                ? new Base(data, toOffset($offset, BYTES))
                : new Base(data);
          }
          if (TYPED_ARRAY in data) return fromList(TypedArray, data);
          return $from.call(TypedArray, data);
        });
        arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
          if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
        });
        TypedArray[PROTOTYPE] = TypedArrayPrototype;
        if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
      }
      var $nativeIterator = TypedArrayPrototype[ITERATOR];
      var CORRECT_ITER_NAME = !!$nativeIterator
        && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
      var $iterator = $iterators.values;
      hide(TypedArray, TYPED_CONSTRUCTOR, true);
      hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
      hide(TypedArrayPrototype, VIEW, true);
      hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

      if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
        dP(TypedArrayPrototype, TAG, {
          get: function () { return NAME; }
        });
      }

      O[NAME] = TypedArray;

      $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

      $export($export.S, NAME, {
        BYTES_PER_ELEMENT: BYTES
      });

      $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
        from: $from,
        of: $of
      });

      if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

      $export($export.P, NAME, proto);

      setSpecies(NAME);

      $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

      $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

      if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

      $export($export.P + $export.F * fails(function () {
        new TypedArray(1).slice();
      }), NAME, { slice: $slice });

      $export($export.P + $export.F * (fails(function () {
        return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
      }) || !fails(function () {
        TypedArrayPrototype.toLocaleString.call([1, 2]);
      })), NAME, { toLocaleString: $toLocaleString });

      Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
      if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
    };
  } else module.exports = function () { /* empty */ };
  });

  _typedArray('Int8', 1, function (init) {
    return function Int8Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Uint8', 1, function (init) {
    return function Uint8Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Uint8', 1, function (init) {
    return function Uint8ClampedArray(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  }, true);

  _typedArray('Int16', 2, function (init) {
    return function Int16Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Uint16', 2, function (init) {
    return function Uint16Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Int32', 4, function (init) {
    return function Int32Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Uint32', 4, function (init) {
    return function Uint32Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Float32', 4, function (init) {
    return function Float32Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  _typedArray('Float64', 8, function (init) {
    return function Float64Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  // 19.1.3.6 Object.prototype.toString()

  var test = {};
  test[_wks('toStringTag')] = 'z';
  if (test + '' != '[object z]') {
    _redefine(Object.prototype, 'toString', function toString() {
      return '[object ' + _classof(this) + ']';
    }, true);
  }

  /**
   * A polyfill is a type of shim that retrofits legacy browsers with modern
   * Javascript, HTML5, or CSS3 features.
   */

  /**
   * @description concatAll() aka flattenDeep(), based on http://reactivex.io/learnrx/
   * @return {array} concatenated array.
   */
  Array.prototype.concatAll = function () {
    var results = [];
    this.forEach(function (subArray) {
      results.push.apply(results, subArray);
    });
    return results;
  };

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css = "/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}[hidden],template{display:none}";
  styleInject(css);

  var css$1 = ".container{position:relative;max-width:960px;margin:0 auto;padding:0 20px}.column,.columns,.container{width:100%;box-sizing:border-box}.column,.columns{float:left}@media (min-width:400px){.container{width:85%;padding:0}}@media (min-width:550px){.container{width:80%}.column,.columns{margin-left:4%}.column:first-child,.columns:first-child{margin-left:0}.one.column,.one.columns{width:4.66666666667%}.two.columns{width:13.3333333333%}.three.columns{width:22%}.four.columns{width:30.6666666667%}.five.columns{width:39.3333333333%}.six.columns{width:48%}.seven.columns{width:56.6666666667%}.eight.columns{width:65.3333333333%}.nine.columns{width:74%}.ten.columns{width:82.6666666667%}.eleven.columns{width:91.3333333333%}.twelve.columns{width:100%;margin-left:0}.one-third.column{width:30.6666666667%}.two-thirds.column{width:65.3333333333%}.one-half.column{width:48%}.offset-by-one.column,.offset-by-one.columns{margin-left:8.66666666667%}.offset-by-two.column,.offset-by-two.columns{margin-left:17.3333333333%}.offset-by-three.column,.offset-by-three.columns{margin-left:26%}.offset-by-four.column,.offset-by-four.columns{margin-left:34.6666666667%}.offset-by-five.column,.offset-by-five.columns{margin-left:43.3333333333%}.offset-by-six.column,.offset-by-six.columns{margin-left:52%}.offset-by-seven.column,.offset-by-seven.columns{margin-left:60.6666666667%}.offset-by-eight.column,.offset-by-eight.columns{margin-left:69.3333333333%}.offset-by-nine.column,.offset-by-nine.columns{margin-left:78%}.offset-by-ten.column,.offset-by-ten.columns{margin-left:86.6666666667%}.offset-by-eleven.column,.offset-by-eleven.columns{margin-left:95.3333333333%}.offset-by-one-third.column,.offset-by-one-third.columns{margin-left:34.6666666667%}.offset-by-two-thirds.column,.offset-by-two-thirds.columns{margin-left:69.3333333333%}.offset-by-one-half.column,.offset-by-one-half.columns{margin-left:52%}}html{font-size:62.5%}body{font-size:1.5em;line-height:1.6;font-weight:400;font-family:Raleway,HelveticaNeue,Helvetica Neue,Helvetica,Arial,sans-serif;color:#222}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:2rem;font-weight:300}h1{font-size:40px;font-size:4rem;line-height:1.2}h1,h2{letter-spacing:-1px;letter-spacing:-.1rem}h2{font-size:36px;font-size:3.6rem;line-height:1.25}h3{font-size:30px;font-size:3rem;line-height:1.3;letter-spacing:-1px;letter-spacing:-.1rem}h4{font-size:24px;font-size:2.4rem;line-height:1.35;letter-spacing:-.8px;letter-spacing:-.08rem}h5{font-size:18px;font-size:1.8rem;line-height:1.5;letter-spacing:-.5px;letter-spacing:-.05rem}h6{font-size:15px;font-size:1.5rem;line-height:1.6;letter-spacing:0}@media (min-width:550px){h1{font-size:5rem}h2{font-size:4.2rem}h3{font-size:3.6rem}h4{font-size:3rem}h5{font-size:2.4rem}h6{font-size:1.5rem}}p{margin-top:0}a{color:#1eaedb}a:hover{color:#0fa0ce}.button,button,input[type=button],input[type=reset],input[type=submit]{display:inline-block;height:38px;padding:0 30px;color:#555;text-align:center;font-size:11px;font-weight:600;line-height:38px;letter-spacing:1px;letter-spacing:.1rem;text-transform:uppercase;text-decoration:none;white-space:nowrap;background-color:transparent;border-radius:4px;border:1px solid #bbb;cursor:pointer;box-sizing:border-box}.button:focus,.button:hover,button:focus,button:hover,input[type=button]:focus,input[type=button]:hover,input[type=reset]:focus,input[type=reset]:hover,input[type=submit]:focus,input[type=submit]:hover{color:#333;border-color:#888;outline:0}.button.button-primary,button.button-primary,input[type=button].button-primary,input[type=reset].button-primary,input[type=submit].button-primary{color:#fff;background-color:#33c3f0;border-color:#33c3f0}.button.button-primary:focus,.button.button-primary:hover,button.button-primary:focus,button.button-primary:hover,input[type=button].button-primary:focus,input[type=button].button-primary:hover,input[type=reset].button-primary:focus,input[type=reset].button-primary:hover,input[type=submit].button-primary:focus,input[type=submit].button-primary:hover{color:#fff;background-color:#1eaedb;border-color:#1eaedb}input[type=email],input[type=number],input[type=password],input[type=search],input[type=tel],input[type=text],input[type=url],select,textarea{height:38px;padding:6px 10px;background-color:#fff;border:1px solid #d1d1d1;border-radius:4px;box-shadow:none;box-sizing:border-box}input[type=email],input[type=number],input[type=password],input[type=search],input[type=tel],input[type=text],input[type=url],textarea{appearance:none}textarea{min-height:65px;padding-top:6px;padding-bottom:6px}input[type=email]:focus,input[type=number]:focus,input[type=password]:focus,input[type=search]:focus,input[type=tel]:focus,input[type=text]:focus,input[type=url]:focus,select:focus,textarea:focus{border:1px solid #33c3f0;outline:0}label,legend{display:block;margin-bottom:.5rem;font-weight:600}fieldset{padding:0;border-width:0}input[type=checkbox],input[type=radio]{display:inline}label>.label-body{display:inline-block;margin-left:.5rem;font-weight:400}ul{list-style:circle inside}ol{list-style:decimal inside}ol,ul{padding-left:0;margin-top:0}ol ol,ol ul,ul ol,ul ul{margin:1.5rem 0 1.5rem 3rem;font-size:90%}li{margin-bottom:1rem}code{padding:.2rem .5rem;margin:0 .2rem;font-size:90%;white-space:nowrap;background:#f1f1f1;border:1px solid #e1e1e1;border-radius:4px}pre>code{display:block;padding:1rem 1.5rem;white-space:pre}td,th{padding:12px 15px;text-align:left;border-bottom:1px solid #e1e1e1}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}.button,button{margin-bottom:1rem}fieldset,input,select,textarea{margin-bottom:1.5rem}blockquote,dl,figure,form,ol,p,pre,table,ul{margin-bottom:2.5rem}.u-full-width{width:100%;box-sizing:border-box}.u-max-full-width{max-width:100%;box-sizing:border-box}.u-pull-right{float:right}.u-pull-left{float:left}hr{margin-top:3rem;margin-bottom:3.5rem;border-width:0;border-top:1px solid #e1e1e1}.container:after,.row:after,.u-cf{content:\"\";display:table;clear:both}";
  styleInject(css$1);

  var css$2 = "body,html{width:100%;height:100%;margin:0;overflow:hidden;font-family:Nunito,HelveticaNeue,Helvetica Neue,Helvetica,Arial,sans-serif}#cmap-div{width:calc(100% - 2rem);height:calc(100% - 2rem);margin:0 auto;max-width:95%}#cmap-app{height:inherit;max-height:100%}#cmap-main-app{width:calc(100% - 2rem);height:500000px;margin:0 auto;overflow:hidden}#cmap-disclaimer{font-size:28px;font-size:1.75rem;color:red;border:2px solid #000;border-radius:8px;padding:10px}#horizontal-layout-container{display:table;display:-moz-flex;display:-ms-flexbox;display:-o-flex;display:flex;-moz-flex-direction:row;-ms-flex-direction:row;-o-flex-direction:row;flex-direction:row;overflow:auto}.cmap-vbox{-ms-flex-direction:column;flex-direction:column;-ms-flex-line-pack:stretch}.cmap-hbox,.cmap-vbox{display:-ms-flexbox;display:flex;align-content:stretch}.cmap-hbox{-ms-flex-direction:row;flex-direction:row;-ms-flex-line-pack:stretch;-ms-flex-pack:start;justify-content:start}.cmap-layout{width:calc(100% - 2rem);height:calc(100% - 2rem)}.cmap-layout-viewport{overflow-y:hidden;overflow-x:hidden;-ms-flex:auto;flex:auto;position:relative}.cmap-layout-container{position:absolute;width:calc(100% - 2rem);height:calc(100% - 2.5rem)}.cmap-canvas{position:absolute}.cmap-layout-circos,.cmap-layout-horizontal{width:calc(100% - 2rem);height:calc(100% - 2rem);position:relative}.cmap-biomap{border:2px dashed grey}.cmap-biomap.selected{border:2px dashed #f0f}.cmap-tools h5,h4.cmap-header{margin-bottom:0}.control-dialog{overflow-y:hidden}.cmap-modal-control{text-align:center}div.cmap-modal-control button{margin-right:1rem;margin-left:1rem;text-align:center}#cmap-map-addition-dialog,#cmap-map-removal-dialog{padding-left:2rem;border-left:4px solid grey}#cmap-map-addition-dialog label{display:inline-block;margin:0 .5rem}#export-location-input{width:100%;margin:auto}.button i,button>i{margin-right:.5em;vertical-align:-30%}div.cmap-tools button{margin-right:.5rem;padding-left:1rem;padding-right:1rem}button[disabled]{background:#ccc;border-color:#ccc;text-shadow:none}span.cmap-map-name-chip{background:#eee;border-radius:4px;padding:.2rem 1rem;margin-right:.5rem}.biomap-info{width:15em;height:15em;position:absolute;display:inline-block}.biomap-info,.biomap-info-name{border:1px solid #bbb;border-radius:4px;background:#fff}.biomap-info-name{margin:5px;text-align:center}.biomap-info-name:hover{background:#ccc}.biomap-info-data{margin:5px 20px}.swap-div{opacity:.6;z-index:10000}.swap-div,.swap-map-order{border:1px solid #bbb;border-radius:4px;text-align:center}.swap-map-order{margin:5px 10px;padding:5px 10px;background:#fff;opacity:.5}.swap-map-order:hover{background:#ccc}.map-title{margin:5px 10px;padding:5px 10px}.feature-title,.map-title{text-align:center;background:#fff}.feature-title{z-index:1000;border:1px solid #000;border-radius:4px;padding:5px 0;margin:5px 0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:inline-block}.feature-title.add-new{width:48px;width:3rem}.feature-menu{z-index:10000;background:#fff;border:1px solid #000;border-radius:4px;padding:5px 0;margin:5px 0;text-align:center}#cmap-menu-viewport{margin:5px;padding:5px 10px;border:1px solid #bbb;border-radius:4px;background:#fff}.alert{border:1px solid #59030b;border-radius:.5rem;padding:1.5rem;background-color:#d4707a;color:#831a24}.close-button{position:absolute;top:0;float:left;border:none}.loading-row{height:inherit}.loading-col{height:50%;margin-top:25%;border:4px solid #000;border-radius:3rem}.loading-spinner{margin:25% auto}.loading-element{display:block;margin:0 auto;text-align:center}.color-select-ctrl{display:block;width:128px;width:8rem;padding-left:1rem;padding-right:1rem}";
  styleInject(css$2);

  var VNode = function VNode() {};

  var options = {};

  var stack = [];

  var EMPTY_CHILDREN = [];

  function h(nodeName, attributes) {
  	var children = EMPTY_CHILDREN,
  	    lastSimple,
  	    child,
  	    simple,
  	    i;
  	for (i = arguments.length; i-- > 2;) {
  		stack.push(arguments[i]);
  	}
  	if (attributes && attributes.children != null) {
  		if (!stack.length) stack.push(attributes.children);
  		delete attributes.children;
  	}
  	while (stack.length) {
  		if ((child = stack.pop()) && child.pop !== undefined) {
  			for (i = child.length; i--;) {
  				stack.push(child[i]);
  			}
  		} else {
  			if (typeof child === 'boolean') child = null;

  			if (simple = typeof nodeName !== 'function') {
  				if (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;
  			}

  			if (simple && lastSimple) {
  				children[children.length - 1] += child;
  			} else if (children === EMPTY_CHILDREN) {
  				children = [child];
  			} else {
  				children.push(child);
  			}

  			lastSimple = simple;
  		}
  	}

  	var p = new VNode();
  	p.nodeName = nodeName;
  	p.children = children;
  	p.attributes = attributes == null ? undefined : attributes;
  	p.key = attributes == null ? undefined : attributes.key;

  	return p;
  }

  function extend(obj, props) {
    for (var i in props) {
      obj[i] = props[i];
    }return obj;
  }

  function applyRef(ref, value) {
    if (ref != null) {
      if (typeof ref == 'function') ref(value);else ref.current = value;
    }
  }

  var defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;

  function cloneElement(vnode, props) {
    return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
  }

  var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

  var items = [];

  function enqueueRender(component) {
  	if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
  		(defer)(rerender);
  	}
  }

  function rerender() {
  	var p;
  	while (p = items.pop()) {
  		if (p._dirty) renderComponent(p);
  	}
  }

  function isSameNodeType(node, vnode, hydrating) {
  	if (typeof vnode === 'string' || typeof vnode === 'number') {
  		return node.splitText !== undefined;
  	}
  	if (typeof vnode.nodeName === 'string') {
  		return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
  	}
  	return hydrating || node._componentConstructor === vnode.nodeName;
  }

  function isNamedNode(node, nodeName) {
  	return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
  }

  function getNodeProps(vnode) {
  	var props = extend({}, vnode.attributes);
  	props.children = vnode.children;

  	var defaultProps = vnode.nodeName.defaultProps;
  	if (defaultProps !== undefined) {
  		for (var i in defaultProps) {
  			if (props[i] === undefined) {
  				props[i] = defaultProps[i];
  			}
  		}
  	}

  	return props;
  }

  function createNode(nodeName, isSvg) {
  	var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
  	node.normalizedNodeName = nodeName;
  	return node;
  }

  function removeNode(node) {
  	var parentNode = node.parentNode;
  	if (parentNode) parentNode.removeChild(node);
  }

  function setAccessor(node, name, old, value, isSvg) {
  	if (name === 'className') name = 'class';

  	if (name === 'key') ; else if (name === 'ref') {
  		applyRef(old, null);
  		applyRef(value, node);
  	} else if (name === 'class' && !isSvg) {
  		node.className = value || '';
  	} else if (name === 'style') {
  		if (!value || typeof value === 'string' || typeof old === 'string') {
  			node.style.cssText = value || '';
  		}
  		if (value && typeof value === 'object') {
  			if (typeof old !== 'string') {
  				for (var i in old) {
  					if (!(i in value)) node.style[i] = '';
  				}
  			}
  			for (var i in value) {
  				node.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];
  			}
  		}
  	} else if (name === 'dangerouslySetInnerHTML') {
  		if (value) node.innerHTML = value.__html || '';
  	} else if (name[0] == 'o' && name[1] == 'n') {
  		var useCapture = name !== (name = name.replace(/Capture$/, ''));
  		name = name.toLowerCase().substring(2);
  		if (value) {
  			if (!old) node.addEventListener(name, eventProxy, useCapture);
  		} else {
  			node.removeEventListener(name, eventProxy, useCapture);
  		}
  		(node._listeners || (node._listeners = {}))[name] = value;
  	} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {
  		try {
  			node[name] = value == null ? '' : value;
  		} catch (e) {}
  		if ((value == null || value === false) && name != 'spellcheck') node.removeAttribute(name);
  	} else {
  		var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));

  		if (value == null || value === false) {
  			if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);
  		} else if (typeof value !== 'function') {
  			if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);
  		}
  	}
  }

  function eventProxy(e) {
  	return this._listeners[e.type](e);
  }

  var mounts = [];

  var diffLevel = 0;

  var isSvgMode = false;

  var hydrating = false;

  function flushMounts() {
  	var c;
  	while (c = mounts.shift()) {
  		if (c.componentDidMount) c.componentDidMount();
  	}
  }

  function diff(dom, vnode, context, mountAll, parent, componentRoot) {
  	if (!diffLevel++) {
  		isSvgMode = parent != null && parent.ownerSVGElement !== undefined;

  		hydrating = dom != null && !('__preactattr_' in dom);
  	}

  	var ret = idiff(dom, vnode, context, mountAll, componentRoot);

  	if (parent && ret.parentNode !== parent) parent.appendChild(ret);

  	if (! --diffLevel) {
  		hydrating = false;

  		if (!componentRoot) flushMounts();
  	}

  	return ret;
  }

  function idiff(dom, vnode, context, mountAll, componentRoot) {
  	var out = dom,
  	    prevSvgMode = isSvgMode;

  	if (vnode == null || typeof vnode === 'boolean') vnode = '';

  	if (typeof vnode === 'string' || typeof vnode === 'number') {
  		if (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {
  			if (dom.nodeValue != vnode) {
  				dom.nodeValue = vnode;
  			}
  		} else {
  			out = document.createTextNode(vnode);
  			if (dom) {
  				if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
  				recollectNodeTree(dom, true);
  			}
  		}

  		out['__preactattr_'] = true;

  		return out;
  	}

  	var vnodeName = vnode.nodeName;
  	if (typeof vnodeName === 'function') {
  		return buildComponentFromVNode(dom, vnode, context, mountAll);
  	}

  	isSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;

  	vnodeName = String(vnodeName);
  	if (!dom || !isNamedNode(dom, vnodeName)) {
  		out = createNode(vnodeName, isSvgMode);

  		if (dom) {
  			while (dom.firstChild) {
  				out.appendChild(dom.firstChild);
  			}
  			if (dom.parentNode) dom.parentNode.replaceChild(out, dom);

  			recollectNodeTree(dom, true);
  		}
  	}

  	var fc = out.firstChild,
  	    props = out['__preactattr_'],
  	    vchildren = vnode.children;

  	if (props == null) {
  		props = out['__preactattr_'] = {};
  		for (var a = out.attributes, i = a.length; i--;) {
  			props[a[i].name] = a[i].value;
  		}
  	}

  	if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {
  		if (fc.nodeValue != vchildren[0]) {
  			fc.nodeValue = vchildren[0];
  		}
  	} else if (vchildren && vchildren.length || fc != null) {
  			innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
  		}

  	diffAttributes(out, vnode.attributes, props);

  	isSvgMode = prevSvgMode;

  	return out;
  }

  function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
  	var originalChildren = dom.childNodes,
  	    children = [],
  	    keyed = {},
  	    keyedLen = 0,
  	    min = 0,
  	    len = originalChildren.length,
  	    childrenLen = 0,
  	    vlen = vchildren ? vchildren.length : 0,
  	    j,
  	    c,
  	    f,
  	    vchild,
  	    child;

  	if (len !== 0) {
  		for (var i = 0; i < len; i++) {
  			var _child = originalChildren[i],
  			    props = _child['__preactattr_'],
  			    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
  			if (key != null) {
  				keyedLen++;
  				keyed[key] = _child;
  			} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
  				children[childrenLen++] = _child;
  			}
  		}
  	}

  	if (vlen !== 0) {
  		for (var i = 0; i < vlen; i++) {
  			vchild = vchildren[i];
  			child = null;

  			var key = vchild.key;
  			if (key != null) {
  				if (keyedLen && keyed[key] !== undefined) {
  					child = keyed[key];
  					keyed[key] = undefined;
  					keyedLen--;
  				}
  			} else if (min < childrenLen) {
  					for (j = min; j < childrenLen; j++) {
  						if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
  							child = c;
  							children[j] = undefined;
  							if (j === childrenLen - 1) childrenLen--;
  							if (j === min) min++;
  							break;
  						}
  					}
  				}

  			child = idiff(child, vchild, context, mountAll);

  			f = originalChildren[i];
  			if (child && child !== dom && child !== f) {
  				if (f == null) {
  					dom.appendChild(child);
  				} else if (child === f.nextSibling) {
  					removeNode(f);
  				} else {
  					dom.insertBefore(child, f);
  				}
  			}
  		}
  	}

  	if (keyedLen) {
  		for (var i in keyed) {
  			if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);
  		}
  	}

  	while (min <= childrenLen) {
  		if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
  	}
  }

  function recollectNodeTree(node, unmountOnly) {
  	var component = node._component;
  	if (component) {
  		unmountComponent(component);
  	} else {
  		if (node['__preactattr_'] != null) applyRef(node['__preactattr_'].ref, null);

  		if (unmountOnly === false || node['__preactattr_'] == null) {
  			removeNode(node);
  		}

  		removeChildren(node);
  	}
  }

  function removeChildren(node) {
  	node = node.lastChild;
  	while (node) {
  		var next = node.previousSibling;
  		recollectNodeTree(node, true);
  		node = next;
  	}
  }

  function diffAttributes(dom, attrs, old) {
  	var name;

  	for (name in old) {
  		if (!(attrs && attrs[name] != null) && old[name] != null) {
  			setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
  		}
  	}

  	for (name in attrs) {
  		if (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {
  			setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
  		}
  	}
  }

  var recyclerComponents = [];

  function createComponent(Ctor, props, context) {
  	var inst,
  	    i = recyclerComponents.length;

  	if (Ctor.prototype && Ctor.prototype.render) {
  		inst = new Ctor(props, context);
  		Component.call(inst, props, context);
  	} else {
  		inst = new Component(props, context);
  		inst.constructor = Ctor;
  		inst.render = doRender;
  	}

  	while (i--) {
  		if (recyclerComponents[i].constructor === Ctor) {
  			inst.nextBase = recyclerComponents[i].nextBase;
  			recyclerComponents.splice(i, 1);
  			return inst;
  		}
  	}

  	return inst;
  }

  function doRender(props, state, context) {
  	return this.constructor(props, context);
  }

  function setComponentProps(component, props, renderMode, context, mountAll) {
  	if (component._disable) return;
  	component._disable = true;

  	component.__ref = props.ref;
  	component.__key = props.key;
  	delete props.ref;
  	delete props.key;

  	if (typeof component.constructor.getDerivedStateFromProps === 'undefined') {
  		if (!component.base || mountAll) {
  			if (component.componentWillMount) component.componentWillMount();
  		} else if (component.componentWillReceiveProps) {
  			component.componentWillReceiveProps(props, context);
  		}
  	}

  	if (context && context !== component.context) {
  		if (!component.prevContext) component.prevContext = component.context;
  		component.context = context;
  	}

  	if (!component.prevProps) component.prevProps = component.props;
  	component.props = props;

  	component._disable = false;

  	if (renderMode !== 0) {
  		if (renderMode === 1 || options.syncComponentUpdates !== false || !component.base) {
  			renderComponent(component, 1, mountAll);
  		} else {
  			enqueueRender(component);
  		}
  	}

  	applyRef(component.__ref, component);
  }

  function renderComponent(component, renderMode, mountAll, isChild) {
  	if (component._disable) return;

  	var props = component.props,
  	    state = component.state,
  	    context = component.context,
  	    previousProps = component.prevProps || props,
  	    previousState = component.prevState || state,
  	    previousContext = component.prevContext || context,
  	    isUpdate = component.base,
  	    nextBase = component.nextBase,
  	    initialBase = isUpdate || nextBase,
  	    initialChildComponent = component._component,
  	    skip = false,
  	    snapshot = previousContext,
  	    rendered,
  	    inst,
  	    cbase;

  	if (component.constructor.getDerivedStateFromProps) {
  		state = extend(extend({}, state), component.constructor.getDerivedStateFromProps(props, state));
  		component.state = state;
  	}

  	if (isUpdate) {
  		component.props = previousProps;
  		component.state = previousState;
  		component.context = previousContext;
  		if (renderMode !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
  			skip = true;
  		} else if (component.componentWillUpdate) {
  			component.componentWillUpdate(props, state, context);
  		}
  		component.props = props;
  		component.state = state;
  		component.context = context;
  	}

  	component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
  	component._dirty = false;

  	if (!skip) {
  		rendered = component.render(props, state, context);

  		if (component.getChildContext) {
  			context = extend(extend({}, context), component.getChildContext());
  		}

  		if (isUpdate && component.getSnapshotBeforeUpdate) {
  			snapshot = component.getSnapshotBeforeUpdate(previousProps, previousState);
  		}

  		var childComponent = rendered && rendered.nodeName,
  		    toUnmount,
  		    base;

  		if (typeof childComponent === 'function') {

  			var childProps = getNodeProps(rendered);
  			inst = initialChildComponent;

  			if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
  				setComponentProps(inst, childProps, 1, context, false);
  			} else {
  				toUnmount = inst;

  				component._component = inst = createComponent(childComponent, childProps, context);
  				inst.nextBase = inst.nextBase || nextBase;
  				inst._parentComponent = component;
  				setComponentProps(inst, childProps, 0, context, false);
  				renderComponent(inst, 1, mountAll, true);
  			}

  			base = inst.base;
  		} else {
  			cbase = initialBase;

  			toUnmount = initialChildComponent;
  			if (toUnmount) {
  				cbase = component._component = null;
  			}

  			if (initialBase || renderMode === 1) {
  				if (cbase) cbase._component = null;
  				base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
  			}
  		}

  		if (initialBase && base !== initialBase && inst !== initialChildComponent) {
  			var baseParent = initialBase.parentNode;
  			if (baseParent && base !== baseParent) {
  				baseParent.replaceChild(base, initialBase);

  				if (!toUnmount) {
  					initialBase._component = null;
  					recollectNodeTree(initialBase, false);
  				}
  			}
  		}

  		if (toUnmount) {
  			unmountComponent(toUnmount);
  		}

  		component.base = base;
  		if (base && !isChild) {
  			var componentRef = component,
  			    t = component;
  			while (t = t._parentComponent) {
  				(componentRef = t).base = base;
  			}
  			base._component = componentRef;
  			base._componentConstructor = componentRef.constructor;
  		}
  	}

  	if (!isUpdate || mountAll) {
  		mounts.push(component);
  	} else if (!skip) {

  		if (component.componentDidUpdate) {
  			component.componentDidUpdate(previousProps, previousState, snapshot);
  		}
  	}

  	while (component._renderCallbacks.length) {
  		component._renderCallbacks.pop().call(component);
  	}if (!diffLevel && !isChild) flushMounts();
  }

  function buildComponentFromVNode(dom, vnode, context, mountAll) {
  	var c = dom && dom._component,
  	    originalComponent = c,
  	    oldDom = dom,
  	    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
  	    isOwner = isDirectOwner,
  	    props = getNodeProps(vnode);
  	while (c && !isOwner && (c = c._parentComponent)) {
  		isOwner = c.constructor === vnode.nodeName;
  	}

  	if (c && isOwner && (!mountAll || c._component)) {
  		setComponentProps(c, props, 3, context, mountAll);
  		dom = c.base;
  	} else {
  		if (originalComponent && !isDirectOwner) {
  			unmountComponent(originalComponent);
  			dom = oldDom = null;
  		}

  		c = createComponent(vnode.nodeName, props, context);
  		if (dom && !c.nextBase) {
  			c.nextBase = dom;

  			oldDom = null;
  		}
  		setComponentProps(c, props, 1, context, mountAll);
  		dom = c.base;

  		if (oldDom && dom !== oldDom) {
  			oldDom._component = null;
  			recollectNodeTree(oldDom, false);
  		}
  	}

  	return dom;
  }

  function unmountComponent(component) {

  	var base = component.base;

  	component._disable = true;

  	if (component.componentWillUnmount) component.componentWillUnmount();

  	component.base = null;

  	var inner = component._component;
  	if (inner) {
  		unmountComponent(inner);
  	} else if (base) {
  		if (base['__preactattr_'] != null) applyRef(base['__preactattr_'].ref, null);

  		component.nextBase = base;

  		removeNode(base);
  		recyclerComponents.push(component);

  		removeChildren(base);
  	}

  	applyRef(component.__ref, null);
  }

  function Component(props, context) {
  	this._dirty = true;

  	this.context = context;

  	this.props = props;

  	this.state = this.state || {};

  	this._renderCallbacks = [];
  }

  extend(Component.prototype, {
  	setState: function setState(state, callback) {
  		if (!this.prevState) this.prevState = this.state;
  		this.state = extend(extend({}, this.state), typeof state === 'function' ? state(this.state, this.props) : state);
  		if (callback) this._renderCallbacks.push(callback);
  		enqueueRender(this);
  	},
  	forceUpdate: function forceUpdate(callback) {
  		if (callback) this._renderCallbacks.push(callback);
  		renderComponent(this, 2);
  	},
  	render: function render() {}
  });

  function render(vnode, parent, merge) {
    return diff(merge, vnode, {}, false, parent, false);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  var papaparse_min = createCommonjsModule(function (module, exports) {
  /* @license
  Papa Parse
  v4.6.3
  https://github.com/mholt/PapaParse
  License: MIT
  */
  Array.isArray||(Array.isArray=function(e){return "[object Array]"===Object.prototype.toString.call(e)}),function(e,t){module.exports=t();}(commonjsGlobal,function(){var s,e,f="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==f?f:{},n=!f.document&&!!f.postMessage,o=n&&/(\?|&)papaworker(=|&|$)/.test(f.location.search),a=!1,h={},u=0,k={parse:function(e,t){var r=(t=t||{}).dynamicTyping||!1;z(r)&&(t.dynamicTypingFunction=r,r={});if(t.dynamicTyping=r,t.transform=!!z(t.transform)&&t.transform,t.worker&&k.WORKERS_SUPPORTED){var i=function(){if(!k.WORKERS_SUPPORTED)return !1;if(!a&&null===k.SCRIPT_PATH)throw new Error("Script path cannot be determined automatically when Papa Parse is loaded asynchronously. You need to set Papa.SCRIPT_PATH manually.");var e=k.SCRIPT_PATH||s;e+=(-1!==e.indexOf("?")?"&":"?")+"papaworker";var t=new f.Worker(e);return t.onmessage=m,t.id=u++,h[t.id]=t}();return i.userStep=t.step,i.userChunk=t.chunk,i.userComplete=t.complete,i.userError=t.error,t.step=z(t.step),t.chunk=z(t.chunk),t.complete=z(t.complete),t.error=z(t.error),delete t.worker,void i.postMessage({input:e,config:t,workerId:i.id})}var n=null;"string"==typeof e?n=t.download?new c(t):new _(t):!0===e.readable&&z(e.read)&&z(e.on)?n=new g(t):(f.File&&e instanceof File||e instanceof Object)&&(n=new p(t));return n.stream(e)},unparse:function(e,t){var i=!1,g=!0,m=",",y="\r\n",n='"',r=!1;!function(){if("object"!=typeof t)return;"string"!=typeof t.delimiter||k.BAD_DELIMITERS.filter(function(e){return -1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter);("boolean"==typeof t.quotes||Array.isArray(t.quotes))&&(i=t.quotes);"boolean"!=typeof t.skipEmptyLines&&"string"!=typeof t.skipEmptyLines||(r=t.skipEmptyLines);"string"==typeof t.newline&&(y=t.newline);"string"==typeof t.quoteChar&&(n=t.quoteChar);"boolean"==typeof t.header&&(g=t.header);}();var s=new RegExp(M(n),"g");"string"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return o(null,e,r);if("object"==typeof e[0])return o(a(e[0]),e,r)}else if("object"==typeof e)return "string"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:a(e.data[0])),Array.isArray(e.data[0])||"object"==typeof e.data[0]||(e.data=[e.data])),o(e.fields||[],e.data||[],r);throw"exception: Unable to serialize unrecognized input";function a(e){if("object"!=typeof e)return [];var t=[];for(var r in e)t.push(r);return t}function o(e,t,r){var i="";"string"==typeof e&&(e=JSON.parse(e)),"string"==typeof t&&(t=JSON.parse(t));var n=Array.isArray(e)&&0<e.length,s=!Array.isArray(t[0]);if(n&&g){for(var a=0;a<e.length;a++)0<a&&(i+=m),i+=v(e[a],a);0<t.length&&(i+=y);}for(var o=0;o<t.length;o++){var h=n?e.length:t[o].length,u=!1,f=n?0===Object.keys(t[o]).length:0===t[o].length;if(r&&!n&&(u="greedy"===r?""===t[o].join("").trim():1===t[o].length&&0===t[o][0].length),"greedy"===r&&n){for(var d=[],l=0;l<h;l++){var c=s?e[l]:l;d.push(t[o][c]);}u=""===d.join("").trim();}if(!u){for(var p=0;p<h;p++){0<p&&!f&&(i+=m);var _=n&&s?e[p]:p;i+=v(t[o][_],p);}o<t.length-1&&(!r||0<h&&!f)&&(i+=y);}}return i}function v(e,t){if(null==e)return "";if(e.constructor===Date)return JSON.stringify(e).slice(1,25);e=e.toString().replace(s,n+n);var r="boolean"==typeof i&&i||Array.isArray(i)&&i[t]||function(e,t){for(var r=0;r<t.length;r++)if(-1<e.indexOf(t[r]))return !0;return !1}(e,k.BAD_DELIMITERS)||-1<e.indexOf(m)||" "===e.charAt(0)||" "===e.charAt(e.length-1);return r?n+e+n:e}}};if(k.RECORD_SEP=String.fromCharCode(30),k.UNIT_SEP=String.fromCharCode(31),k.BYTE_ORDER_MARK="\ufeff",k.BAD_DELIMITERS=["\r","\n",'"',k.BYTE_ORDER_MARK],k.WORKERS_SUPPORTED=!n&&!!f.Worker,k.SCRIPT_PATH=null,k.NODE_STREAM_INPUT=1,k.LocalChunkSize=10485760,k.RemoteChunkSize=5242880,k.DefaultDelimiter=",",k.Parser=v,k.ParserHandle=r,k.NetworkStreamer=c,k.FileStreamer=p,k.StringStreamer=_,k.ReadableStreamStreamer=g,f.jQuery){var d=f.jQuery;d.fn.parse=function(o){var r=o.config||{},h=[];return this.each(function(e){if(!("INPUT"===d(this).prop("tagName").toUpperCase()&&"file"===d(this).attr("type").toLowerCase()&&f.FileReader)||!this.files||0===this.files.length)return !0;for(var t=0;t<this.files.length;t++)h.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},r)});}),e(),this;function e(){if(0!==h.length){var e,t,r,i,n=h[0];if(z(o.before)){var s=o.before(n.file,n.inputElem);if("object"==typeof s){if("abort"===s.action)return e="AbortError",t=n.file,r=n.inputElem,i=s.reason,void(z(o.error)&&o.error({name:e},t,r,i));if("skip"===s.action)return void u();"object"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config));}else if("skip"===s)return void u()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){z(a)&&a(e,n.file,n.inputElem),u();},k.parse(n.file,n.instanceConfig);}else z(o.complete)&&o.complete();}function u(){h.splice(0,1),e();}};}function l(e){this._handle=null,this._finished=!1,this._completed=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=E(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new r(t),(this._handle.streamer=this)._config=t;}.call(this,e),this.parseChunk=function(e,t){if(this.isFirstChunk&&z(this._config.beforeFirstChunk)){var r=this._config.beforeFirstChunk(e);void 0!==r&&(e=r);}this.isFirstChunk=!1;var i=this._partialLine+e;this._partialLine="";var n=this._handle.parse(i,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=n.meta.cursor;this._finished||(this._partialLine=i.substring(s-this._baseIndex),this._baseIndex=s),n&&n.data&&(this._rowCount+=n.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(o)f.postMessage({results:n,workerId:k.WORKER_ID,finished:a});else if(z(this._config.chunk)&&!t){if(this._config.chunk(n,this._handle),this._handle.paused()||this._handle.aborted())return;n=void 0,this._completeResults=void 0;}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(n.data),this._completeResults.errors=this._completeResults.errors.concat(n.errors),this._completeResults.meta=n.meta),this._completed||!a||!z(this._config.complete)||n&&n.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),a||n&&n.meta.paused||this._nextChunk(),n}},this._sendError=function(e){z(this._config.error)?this._config.error(e):o&&this._config.error&&f.postMessage({workerId:k.WORKER_ID,error:e,finished:!1});};}function c(e){var i;(e=e||{}).chunkSize||(e.chunkSize=k.RemoteChunkSize),l.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded();}:function(){this._readChunk();},this.stream=function(e){this._input=e,this._nextChunk();},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(i=new XMLHttpRequest,this._config.withCredentials&&(i.withCredentials=this._config.withCredentials),n||(i.onload=w(this._chunkLoaded,this),i.onerror=w(this._chunkError,this)),i.open("GET",this._input,!n),this._config.downloadRequestHeaders){var e=this._config.downloadRequestHeaders;for(var t in e)i.setRequestHeader(t,e[t]);}if(this._config.chunkSize){var r=this._start+this._config.chunkSize-1;i.setRequestHeader("Range","bytes="+this._start+"-"+r),i.setRequestHeader("If-None-Match","webkit-no-cache");}try{i.send();}catch(e){this._chunkError(e.message);}n&&0===i.status?this._chunkError():this._start+=this._config.chunkSize;}},this._chunkLoaded=function(){4===i.readyState&&(i.status<200||400<=i.status?this._chunkError():(this._finished=!this._config.chunkSize||this._start>function(e){var t=e.getResponseHeader("Content-Range");if(null===t)return -1;return parseInt(t.substr(t.lastIndexOf("/")+1))}(i),this.parseChunk(i.responseText)));},this._chunkError=function(e){var t=i.statusText||e;this._sendError(new Error(t));};}function p(e){var i,n;(e=e||{}).chunkSize||(e.chunkSize=k.LocalChunkSize),l.call(this,e);var s="undefined"!=typeof FileReader;this.stream=function(e){this._input=e,n=e.slice||e.webkitSlice||e.mozSlice,s?((i=new FileReader).onload=w(this._chunkLoaded,this),i.onerror=w(this._chunkError,this)):i=new FileReaderSync,this._nextChunk();},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk();},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var t=Math.min(this._start+this._config.chunkSize,this._input.size);e=n.call(e,this._start,t);}var r=i.readAsText(e,this._config.encoding);s||this._chunkLoaded({target:{result:r}});},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result);},this._chunkError=function(){this._sendError(i.error);};}function _(e){var r;l.call(this,e=e||{}),this.stream=function(e){return r=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e=this._config.chunkSize,t=e?r.substr(0,e):r;return r=e?r.substr(e):"",this._finished=!r,this.parseChunk(t)}};}function g(e){l.call(this,e=e||{});var t=[],r=!0,i=!1;this.pause=function(){l.prototype.pause.apply(this,arguments),this._input.pause();},this.resume=function(){l.prototype.resume.apply(this,arguments),this._input.resume();},this.stream=function(e){this._input=e,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError);},this._checkIsFinished=function(){i&&1===t.length&&(this._finished=!0);},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):r=!0;},this._streamData=w(function(e){try{t.push("string"==typeof e?e:e.toString(this._config.encoding)),r&&(r=!1,this._checkIsFinished(),this.parseChunk(t.shift()));}catch(e){this._streamError(e);}},this),this._streamError=w(function(e){this._streamCleanUp(),this._sendError(e);},this),this._streamEnd=w(function(){this._streamCleanUp(),i=!0,this._streamData("");},this),this._streamCleanUp=w(function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError);},this);}function r(g){var a,o,h,i=/^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i,n=/(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/,t=this,r=0,s=0,u=!1,e=!1,f=[],d={data:[],errors:[],meta:{}};if(z(g.step)){var l=g.step;g.step=function(e){if(d=e,p())c();else{if(c(),0===d.data.length)return;r+=e.data.length,g.preview&&r>g.preview?o.abort():l(d,t);}};}function m(e){return "greedy"===g.skipEmptyLines?""===e.join("").trim():1===e.length&&0===e[0].length}function c(){if(d&&h&&(y("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+k.DefaultDelimiter+"'"),h=!1),g.skipEmptyLines)for(var e=0;e<d.data.length;e++)m(d.data[e])&&d.data.splice(e--,1);return p()&&function(){if(!d)return;for(var e=0;p()&&e<d.data.length;e++)for(var t=0;t<d.data[e].length;t++){var r=d.data[e][t];g.trimHeaders&&(r=r.trim()),f.push(r);}d.data.splice(0,1);}(),function(){if(!d||!g.header&&!g.dynamicTyping&&!g.transform)return d;for(var e=0;e<d.data.length;e++){var t,r=g.header?{}:[];for(t=0;t<d.data[e].length;t++){var i=t,n=d.data[e][t];g.header&&(i=t>=f.length?"__parsed_extra":f[t]),g.transform&&(n=g.transform(n,i)),n=_(i,n),"__parsed_extra"===i?(r[i]=r[i]||[],r[i].push(n)):r[i]=n;}d.data[e]=r,g.header&&(t>f.length?y("FieldMismatch","TooManyFields","Too many fields: expected "+f.length+" fields but parsed "+t,s+e):t<f.length&&y("FieldMismatch","TooFewFields","Too few fields: expected "+f.length+" fields but parsed "+t,s+e));}g.header&&d.meta&&(d.meta.fields=f);return s+=d.data.length,d}()}function p(){return g.header&&0===f.length}function _(e,t){return r=e,g.dynamicTypingFunction&&void 0===g.dynamicTyping[r]&&(g.dynamicTyping[r]=g.dynamicTypingFunction(r)),!0===(g.dynamicTyping[r]||g.dynamicTyping)?"true"===t||"TRUE"===t||"false"!==t&&"FALSE"!==t&&(i.test(t)?parseFloat(t):n.test(t)?new Date(t):""===t?null:t):t;var r;}function y(e,t,r,i){d.errors.push({type:e,code:t,message:r,row:i});}this.parse=function(e,t,r){var i=g.quoteChar||'"';if(g.newline||(g.newline=function(e,t){e=e.substr(0,1048576);var r=new RegExp(M(t)+"([^]*?)"+M(t),"gm"),i=(e=e.replace(r,"")).split("\r"),n=e.split("\n"),s=1<n.length&&n[0].length<i[0].length;if(1===i.length||s)return "\n";for(var a=0,o=0;o<i.length;o++)"\n"===i[o][0]&&a++;return a>=i.length/2?"\r\n":"\r"}(e,i)),h=!1,g.delimiter)z(g.delimiter)&&(g.delimiter=g.delimiter(e),d.meta.delimiter=g.delimiter);else{var n=function(e,t,r,i){for(var n,s,a,o=[",","\t","|",";",k.RECORD_SEP,k.UNIT_SEP],h=0;h<o.length;h++){var u=o[h],f=0,d=0,l=0;a=void 0;for(var c=new v({comments:i,delimiter:u,newline:t,preview:10}).parse(e),p=0;p<c.data.length;p++)if(r&&m(c.data[p]))l++;else{var _=c.data[p].length;d+=_,void 0!==a?1<_&&(f+=Math.abs(_-a),a=_):a=0;}0<c.data.length&&(d/=c.data.length-l),(void 0===s||s<f)&&1.99<d&&(s=f,n=u);}return {successful:!!(g.delimiter=n),bestDelimiter:n}}(e,g.newline,g.skipEmptyLines,g.comments);n.successful?g.delimiter=n.bestDelimiter:(h=!0,g.delimiter=k.DefaultDelimiter),d.meta.delimiter=g.delimiter;}var s=E(g);return g.preview&&g.header&&s.preview++,a=e,o=new v(s),d=o.parse(a,t,r),c(),u?{meta:{paused:!0}}:d||{meta:{paused:!1}}},this.paused=function(){return u},this.pause=function(){u=!0,o.abort(),a=a.substr(o.getCharIndex());},this.resume=function(){u=!1,t.streamer.parseChunk(a,!0);},this.aborted=function(){return e},this.abort=function(){e=!0,o.abort(),d.meta.aborted=!0,z(g.complete)&&g.complete(d),a="";};}function M(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function v(e){var S,O=(e=e||{}).delimiter,x=e.newline,T=e.comments,I=e.step,A=e.preview,D=e.fastMode,L=S=void 0===e.quoteChar?'"':e.quoteChar;if(void 0!==e.escapeChar&&(L=e.escapeChar),("string"!=typeof O||-1<k.BAD_DELIMITERS.indexOf(O))&&(O=","),T===O)throw"Comment character same as delimiter";!0===T?T="#":("string"!=typeof T||-1<k.BAD_DELIMITERS.indexOf(T))&&(T=!1),"\n"!==x&&"\r"!==x&&"\r\n"!==x&&(x="\n");var P=0,F=!1;this.parse=function(i,t,r){if("string"!=typeof i)throw"Input must be a string";var n=i.length,e=O.length,s=x.length,a=T.length,o=z(I),h=[],u=[],f=[],d=P=0;if(!i)return C();if(D||!1!==D&&-1===i.indexOf(S)){for(var l=i.split(x),c=0;c<l.length;c++){if(f=l[c],P+=f.length,c!==l.length-1)P+=x.length;else if(r)return C();if(!T||f.substr(0,a)!==T){if(o){if(h=[],k(f.split(O)),R(),F)return C()}else k(f.split(O));if(A&&A<=c)return h=h.slice(0,A),C(!0)}}return C()}for(var p,_=i.indexOf(O,P),g=i.indexOf(x,P),m=new RegExp(M(L)+M(S),"g");;)if(i[P]!==S)if(T&&0===f.length&&i.substr(P,a)===T){if(-1===g)return C();P=g+s,g=i.indexOf(x,P),_=i.indexOf(O,P);}else if(-1!==_&&(_<g||-1===g))f.push(i.substring(P,_)),P=_+e,_=i.indexOf(O,P);else{if(-1===g)break;if(f.push(i.substring(P,g)),w(g+s),o&&(R(),F))return C();if(A&&h.length>=A)return C(!0)}else for(p=P,P++;;){if(-1===(p=i.indexOf(S,p+1)))return r||u.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:h.length,index:P}),E();if(p===n-1)return E(i.substring(P,p).replace(m,S));if(S!==L||i[p+1]!==L){if(S===L||0===p||i[p-1]!==L){var y=b(-1===g?_:Math.min(_,g));if(i[p+1+y]===O){f.push(i.substring(P,p).replace(m,S)),P=p+1+y+e,_=i.indexOf(O,P),g=i.indexOf(x,P);break}var v=b(g);if(i.substr(p+1+v,s)===x){if(f.push(i.substring(P,p).replace(m,S)),w(p+1+v+s),_=i.indexOf(O,P),o&&(R(),F))return C();if(A&&h.length>=A)return C(!0);break}u.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:h.length,index:P}),p++;}}else p++;}return E();function k(e){h.push(e),d=P;}function b(e){var t=0;if(-1!==e){var r=i.substring(p+1,e);r&&""===r.trim()&&(t=r.length);}return t}function E(e){return r||(void 0===e&&(e=i.substr(P)),f.push(e),P=n,k(f),o&&R()),C()}function w(e){P=e,k(f),f=[],g=i.indexOf(x,P);}function C(e){return {data:h,errors:u,meta:{delimiter:O,linebreak:x,aborted:F,truncated:!!e,cursor:d+(t||0)}}}function R(){I(C()),h=[],u=[];}},this.abort=function(){F=!0;},this.getCharIndex=function(){return P};}function m(e){var t=e.data,r=h[t.workerId],i=!1;if(t.error)r.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){i=!0,y(t.workerId,{data:[],errors:[],meta:{aborted:!0}});},pause:b,resume:b};if(z(r.userStep)){for(var s=0;s<t.results.data.length&&(r.userStep({data:[t.results.data[s]],errors:t.results.errors,meta:t.results.meta},n),!i);s++);delete t.results;}else z(r.userChunk)&&(r.userChunk(t.results,n,t.file),delete t.results);}t.finished&&!i&&y(t.workerId,t.results);}function y(e,t){var r=h[e];z(r.userComplete)&&r.userComplete(t),r.terminate(),delete h[e];}function b(){throw"Not implemented."}function E(e){if("object"!=typeof e||null===e)return e;var t=Array.isArray(e)?[]:{};for(var r in e)t[r]=E(e[r]);return t}function w(e,t){return function(){e.apply(t,arguments);}}function z(e){return "function"==typeof e}return o?f.onmessage=function(e){var t=e.data;void 0===k.WORKER_ID&&t&&(k.WORKER_ID=t.workerId);if("string"==typeof t.input)f.postMessage({workerId:k.WORKER_ID,results:k.parse(t.input,t.config),finished:!0});else if(f.File&&t.input instanceof File||t.input instanceof Object){var r=k.parse(t.input,t.config);r&&f.postMessage({workerId:k.WORKER_ID,results:r,finished:!0});}}:k.WORKERS_SUPPORTED&&(e=document.getElementsByTagName("script"),s=e.length?e[e.length-1].src:"",document.body?document.addEventListener("DOMContentLoaded",function(){a=!0;},!0):a=!0),(c.prototype=Object.create(l.prototype)).constructor=c,(p.prototype=Object.create(l.prototype)).constructor=p,(_.prototype=Object.create(_.prototype)).constructor=_,(g.prototype=Object.create(l.prototype)).constructor=g,k});
  });

  /**
   * BioMap data model
   */
  var BioMapModel =
  /*#__PURE__*/
  function () {
    /**
     * create a BioMapModel
     * @param {Object} params having the following properties:
     * @param {String} name - the map name
     * @param {Object} source - the DataSourceModel where bioMap was loaded from
     * @param {Object} coordinates - object w/ start and stop props
     * @param {Array} features - an array of Feature instances.
     */
    function BioMapModel(_ref) {
      var name = _ref.name,
          source = _ref.source,
          features = _ref.features,
          tags = _ref.tags,
          _ref$coordinates = _ref.coordinates,
          coordinates = _ref$coordinates === void 0 ? {
        start: 0,
        stop: 0
      } : _ref$coordinates,
          config = _ref.config;

      _classCallCheck(this, BioMapModel);

      this.name = name;
      this.source = source;
      this.features = features;
      this.tags = tags;
      this.coordinates = coordinates;
      this.config = config;
    }
    /**
     * getter for length (coordinates.stop - coordinates.start)
     * @returns {number}
     */


    _createClass(BioMapModel, [{
      key: "length",
      get: function get() {
        return this.coordinates.stop - this.coordinates.start;
      }
      /**
       *
       * getter for unique name (prefix map name the id of data source)
       * @returns {string}
       */

    }, {
      key: "uniqueName",
      get: function get() {
        return "".concat(this.source.id, "/").concat(this.name);
      }
    }]);

    return BioMapModel;
  }();

  /**
   * Feature
   * A base class for biological map feature
   */
  var Feature =
  /*#__PURE__*/
  function () {
    /**
     * Create a Feature
     *
     * @param {Object} params - having the following properties
     * @param {String} name - name of feature
     * @param {Object} tags - array of String, optional slugs or tags, optional
     * @param {Object} aliases - array of alternate names, optional
     * @returns {Object}
     */
    function Feature(_ref) {
      var source = _ref.source,
          _ref$coordinates = _ref.coordinates,
          coordinates = _ref$coordinates === void 0 ? {
        start: 0,
        stop: 0
      } : _ref$coordinates,
          name = _ref.name,
          _ref$tags = _ref.tags,
          tags = _ref$tags === void 0 ? [] : _ref$tags,
          _ref$aliases = _ref.aliases,
          aliases = _ref$aliases === void 0 ? [] : _ref$aliases,
          data = _ref.data;

      _classCallCheck(this, Feature);

      this.source = source;
      this.coordinates = Object.freeze(coordinates); // object w/ start and end props

      this.name = name;
      this.tags = tags;
      this.aliases = aliases;
      this.data = data; //the entire feature data set returned for later use.
    }
    /**
     *
     * @returns {number}
     */


    _createClass(Feature, [{
      key: "typeLinkedBy",

      /**
       *
       * @param linkout
       * @returns {Array|*|boolean}
       */
      value: function typeLinkedBy(linkout) {
        return linkout.featuretypePattern !== undefined ? this.tags.some(function (t) {
          return linkout.featuretypePattern.test(t);
        }) : this.tags.indexOf(linkout.featuretype) !== -1;
      }
    }, {
      key: "length",
      get: function get() {
        return this.coordinates.stop - this.coordinates.start;
      }
      /**
       *
       * @returns {boolean}
       */

    }, {
      key: "typeHasLinkouts",
      get: function get() {
        var _this = this;

        return this.source.linkouts.some(function (l) {
          return _this.typeLinkedBy(l);
        });
      }
    }]);

    return Feature;
  }();
  /**
   * @param Array features1 - 1st collection of features
   * @param Array features2 - 2nd collection of features
   * @return Array - tuples of results in common [[feat1, feat2], ...]
   */

  /**
   * Find the common features based on name and aliases.
   * @param features1
   * @param features2
   * @returns {*[][]}
   */
  // TODO: support more than two collections of features


  function featuresInCommon(features1, features2) {
    var setupDict = function setupDict(features) {
      var dict = {};
      features.forEach(function (f) {
        dict[f.name] = f;
        f.aliases.forEach(function (a) {
          if (a && a !== 'NULL') dict[a] = f;
        });
      });
      return dict;
    };

    var dict1 = setupDict(features1);
    var dict2 = setupDict(features2);
    var intersectedKeys = Object.keys(dict1).filter(function (key) {
      return dict2[key];
    });
    return intersectedKeys.map(function (key) {
      return [dict1[key], dict2[key]];
    });
  }

  /**
   * fetch
   */
  //import preact from 'preact';
  function checkStatus(response, promiseStep) {
    if (response.ok) {
      return response;
    } else {
      var error = new Error("While processing ".concat(promiseStep, ": ").concat(response.statusText));
      error.response = response;
      return Promise.reject(error);
    }
  }

  var BioMapConfigModel =
  /*#__PURE__*/
  function () {
    /**
     * create a BioMapConfigModel
     * @param url
     * @param method
     */
    function BioMapConfigModel(_ref) {
      var url = _ref.url,
          method = _ref.method;

      _classCallCheck(this, BioMapConfigModel);

      this.url = url;
      this.method = method;
    }
    /**
     *
     */


    _createClass(BioMapConfigModel, [{
      key: "load",
      value: function load() {
        return checkStatus(this);
      }
    }]);

    return BioMapConfigModel;
  }();
  /**
   * Constant that defines the default configuration of cmap maps
   * when no other configuration information is present.
   *
   * @type {{backbone: {width: number, fillColor: string, lineWeight: number, lineColor: string}, ruler: {width: number, padding: number, fillColor: string, lineWeight: number, lineColor: string, labelFace: string, labelSize: number, labelColor: string, innerLineWeight: number, innerLineColor: string, precision: number, steps: number, side: string}, track: {width: number, padding: number, fillColor: string, lineWeight: number, lineColor: string, labelFace: string, labelSize: number, labelColor: string, internalPadding: string}, marker: {lineWeight: number, lineColor: string, labelFace: string, labelSize: number, labelStyle: string, labelColor: string, filter: Array}, manhattan: {width: number, fillColor: string, lineWeight: number, lineColor: string, labelFace: string, labelSize: number, labelStyle: string, labelColor: string, displayWidth: number, featureLineWeight: number, featureLineColor: string, rulerWeight: number, rulerColor: string, rulerMajorMark: number, rulerMinorMark: number, type: string}, qtl: {padding: number, width: number, fillColor: string[], labelSize: number, labelFace: string, labelColor: string, labelStyle: string, trackMinWidth: number, internalPadding: number, position: number, type: string}, invert: boolean}}
   */

  var defaultConfig = {
    'backbone': {
      'width': 20,
      'fillColor': '#fff6e8',
      'lineWeight': 0,
      'lineColor': 'black'
    },
    'ruler': {
      'width': 10,
      'padding': 5,
      'fillColor': 'aqua',
      'lineWeight': 0,
      'lineColor': 'black',
      'labelFace': 'Nunito',
      'labelSize': 12,
      'labelColor': 'black',
      'innerLineWeight': 1.0,
      'innerLineColor': 'black',
      'precision': 2,
      'steps': 100,
      'position': -1
    },
    'track': {
      'width': 5,
      'padding': 5,
      'fillColor': '#636081',
      'lineWeight': 0,
      'lineColor': 'black',
      'labelFace': 'Nunito',
      'labelSize': 12,
      'labelColor': 'black',
      'internalPadding': '5'
    },
    'marker': {
      'lineWeight': 1,
      'lineColor': 'black',
      'labelFace': 'Nunito',
      'labelSize': 12,
      'labelStyle': 'block',
      'labelColor': 'black',
      'labelPosition': 1,
      'labelPadding': 0,
      'filter': []
    },
    'manhattan': {
      'width': 2,
      'fillColor': 'green',
      'lineWeight': 1,
      'lineColor': 'black',
      'labelFace': 'Nunito',
      'labelSize': 10,
      'labelStyle': 'none',
      'labelColor': 'black',
      'displayWidth': 50,
      'featureLineWeight': 3,
      'featureLineColor': 'red',
      'rulerWeight': 2,
      'rulerColor': 'black',
      'rulerMajorMark': 10,
      'rulerMinorMark': 2,
      'type': 'manhattan'
    },
    'qtl': {
      'padding': 20,
      'width': 5,
      'fillColor': ['green'],
      'labelSize': 12,
      'labelFace': 'Nunito',
      'labelColor': 'black',
      'labelStyle': 'block',
      'trackMinWidth': 50,
      'internalPadding': 5,
      'position': 1,
      'type': 'qtl'
    },
    'invert': false
  };

  var DataSourceModel =
  /*#__PURE__*/
  function () {
    /**
     * create a DataSourceModel
     * @param {Object} params having the following properties:
     * @param {String} id - uniqueId string for the data source (required)
     * @param {String} method - HTTP method, get or post (required)
     * @param {String} url - HTTP URL (required)
     * @param {Object} data - query string parameters for the request (optional)
     */
    function DataSourceModel(_ref) {
      var _this = this;

      var id = _ref.id,
          method = _ref.method,
          data = _ref.data,
          url = _ref.url,
          filters = _ref.filters,
          linkouts = _ref.linkouts,
          config = _ref.config;

      _classCallCheck(this, DataSourceModel);

      this.id = id;
      this.method = method;
      this.data = data;
      this.url = url;
      this.config = config || {};
      this.bioConfig = {
        'default': defaultConfig
      }; // request bioconfig urlpage as a promise, if it is gettable, fill in all
      // default values that aren't defined using the base config, otherwise
      // set the default values to the base config (found in BioMapConfigModel).

      (function () {
        // promise generator
        var cfg = new BioMapConfigModel(_this.config);
        return cfg.load();
      })().then( // promise resolution
      function (item) {
        // success
        _this.bioConfig = item;

        var _arr = Object.keys(_this.bioConfig);

        for (var _i = 0; _i < _arr.length; _i++) {
          var configGroup = _arr[_i];

          var _arr2 = Object.keys(defaultConfig);

          for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
            var key = _arr2[_i2];

            if (_this.bioConfig[configGroup][key] === undefined) {
              _this.bioConfig[configGroup][key] = _this.bioConfig.default[key] || defaultConfig[key];
            }

            var _arr3 = Object.keys(defaultConfig[key]);

            for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
              var subkey = _arr3[_i3];

              if (_this.bioConfig[configGroup][key][subkey] === undefined) {
                _this.bioConfig[configGroup][key][subkey] = _this.bioConfig.default[key][subkey] || defaultConfig[key][subkey];
              }
            }
          }
        }
      }, function () {
        // failure
        _this.bioConfig.default = defaultConfig;
      });
      this.filters = filters || [];
      this.linkouts = linkouts || [];
      this.linkouts.forEach(function (l) {
        l.featuretypePattern !== undefined ? l.featuretypePattern = new RegExp(l.featuretypePattern) : undefined;
      });
      this.background = true; // mithril not to redraw upon completion
    }
    /**
     *Load the data source with mithril request
     * @returns {*}
     */


    _createClass(DataSourceModel, [{
      key: "load",
      value: function load() {
        var _this2 = this;

        return fetch(this.url, {
          method: this.method
        }).then(function (r) {
          return checkStatus(r, _this2.url);
        }).then(function (r) {
          return r.text();
        }).then(function (data) {
          return _this2.deserialize(data);
        });
      }
      /**
       * Callback from mithril request(); instead of the default deserialization
       * which is JSON, use the papaparse library to parse csv or tab delimited
       * content.
       * @param {String} data - delimited text, csv or tsv
       */

    }, {
      key: "deserialize",
      value: function deserialize(data) {
        var _this3 = this;

        var res = papaparse_min.parse(data, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true
        });

        if (res.errors.length) {
          console.error(res.errors);
          throw new Error("There were parsing errors in ".concat(this.url, " please see console.")); //alert(`There were parsing errors in ${this.url}, please see console.`);
        } // apply filters from config file


        res.data = res.data.filter(function (d) {
          return _this3.includeRecord(d);
        });
        this.parseResult = res;
      }
      /**
       * Check record against filters and return true for inclusion. All filters are
       * processed sequentially and the result is all or nothing, effectively like
       * SQL AND.
       *
       * @param {Object} d - key/value properties of 1 record
       * @return {Boolean} true for include, false for exclude
       */

    }, {
      key: "includeRecord",
      value: function includeRecord(d) {
        var hits = 0;
        this.filters.forEach(function (f) {
          var col = f.column;

          if (d.hasOwnProperty(col)) {
            var testVal = d[col];
            var match;

            if (f.operator === 'equals') {
              match = testVal === f.value;
            } else if (f.operator === 'regex') {
              match = testVal.match(f.value);
            }

            if (f.not) {
              if (!match) ++hits;
            } else {
              if (match) ++hits;
            }
          }
        });
        return hits === this.filters.length;
      }
      /**
       * bioMaps getter; return a mapping of the uniquified map name to
       * an instance of BioMapModel.
       *
       * @return {Object} key: prefix + map_name -> val: BioMapModel instance
       */

    }, {
      key: "bioMaps",
      get: function get() {
        var _this4 = this;

        var res = {};

        try {
          var typeField = this.parseResult.meta.fields.indexOf('feature_type') !== -1 ? 'feature_type' : 'feature_type_acc';
          this.parseResult.data.forEach(function (d) {
            if (!d.map_name) return;
            var uniqueMapName = "".concat(_this4.id, "/").concat(d.map_name);

            if (!res[uniqueMapName]) {
              var model = new BioMapModel({
                source: _this4,
                name: d.map_name,
                features: [],
                tags: [],
                coordinates: {
                  start: d.map_start,
                  stop: d.map_stop
                },
                config: _this4.bioConfig[d.map_name] || _this4.bioConfig.default
              });
              res[uniqueMapName] = model;
            } else {
              if (d.map_stop > res[uniqueMapName].coordinates.stop) {
                res[uniqueMapName].coordinates.stop = d.map_stop;
              }
            }

            res[uniqueMapName].features.push(new Feature({
              source: _this4,
              name: d.feature_name,
              tags: [d[typeField] !== '' ? d[typeField] : null],
              aliases: d.feature_aliases && d.feature_aliases !== '' ? d.feature_aliases.split(',') : [],
              coordinates: {
                start: d.feature_start,
                stop: d.feature_stop
              },
              data: d
            }));

            if (d[typeField] !== '' && res[uniqueMapName].tags.indexOf(d[typeField]) === -1) {
              res[uniqueMapName].tags.push(d[typeField]);
            }
          });
        } catch (e) {
          console.error(e);
          console.trace();
        }

        return res;
      }
    }]);

    return DataSourceModel;
  }();

  /**
   * DataLoader - orchestrate loading of data from provided maps and views
   *
   * */
  function loadDataSources() {
    var sources = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var maps = [];
    var promises = sources.map(function (config) {
      var dsm = new DataSourceModel(config);
      maps.push(dsm);
      return dsm.load();
    }); // wait for all data sources are loaded, then set this.bioMaps with
    // only the maps named in initialView
    //

    return Promise.all(promises).then(function () {
      return maps;
    }).catch(function (error) {
      console.error('loadDataSources', error);
      throw error;
    });
  }
  function loadMaps() {
    var maps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return maps.map(function (src) {
      return Object.values(src.bioMaps);
    }).concatAll();
  }

  var AppModel =
  /*#__PURE__*/
  function () {
    function AppModel(configURL, sub) {
      _classCallCheck(this, AppModel);

      this.key = 'moo';
      this.allMaps = [];
      this.bioMaps = [];
      this.header = '';
      this.attribution = '';
      this.status = 'Loading configuration file.';
      this.busy = true;
      this.error = false;
      this.onChanges = [sub];
      this.testString = 'mu';
      this.initialConfig = {};

      this._loadDataFromConfig(configURL); //Set data from configuration file

    } // "reducers" for making model changes and informing Parent Component

    /**
     * Alerts parent component that there are changes to propegate
     * this is why you need to pass the onChanges setState({}) callback
     */


    _createClass(AppModel, [{
      key: "inform",
      value: function inform() {
        this.onChanges.forEach(function (callBack) {
          return callBack();
        });
      }
      /**
       * Update status message without changing busy or error state
       * @param string
       */

    }, {
      key: "updateStatus",
      value: function updateStatus(string) {
        this.status = string;
        this.inform();
      }
      /**
       * Adds BioMaps to the active bioMap array
       * @param maps
       * @param direction - 0 for add left, otherwise add right;
       */

    }, {
      key: "addBioMap",
      value: function addBioMap(maps) {
        var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        //test if map is actually an array of maps
        if (maps.constructor !== Array) maps = [maps];

        if (direction === 0) {
          this.bioMaps = maps.concat(this.bioMaps);
        } else {
          this.bioMaps = this.bioMaps.concat(maps);
        }

        this.inform();
      }
      /**
       * Removes BioMaps from the active bioMap array
       * @param maps
       */

    }, {
      key: "removeBioMap",
      value: function removeBioMap(maps) {
        var _this = this;

        if (maps.constructor !== Array) maps = [maps];
        maps.forEach(function (map) {
          _this.bioMaps.splice(_this.bioMaps.indexOf(map), 1);
        });
        this.inform();
      }
      /**
       * Toggles busy state
       */

    }, {
      key: "toggleBusy",
      value: function toggleBusy() {
        this.busy = !this.busy;
        this.inform();
      }
      /**
       * Toggle error state
       */

    }, {
      key: "toggleError",
      value: function toggleError() {
        this.error = !this.error;
        this.inform();
      }
    }, {
      key: "editFeatureTracks",
      value: function editFeatureTracks(baseMap, featureTracks) {
        this.bioMaps.some(function (map) {
          if (map === baseMap) {
            map.tracks = featureTracks;
            return true;
          }

          return false;
        });
        this.inform();
      } // Private Functions

      /**
       * Sets the Initial View after successful loading of data maps
       * @private
       */

    }, {
      key: "_setInitialView",
      value: function _setInitialView() {
        if (!this.initialView.length) {
          this._defaultInitialView();
        } else {
          this._setupInitialView();
        }
      }
      /**
       * create this.bioMaps based on initialView of config file.
       * @private
       */

    }, {
      key: "_setupInitialView",
      value: function _setupInitialView() {
        var _this2 = this;

        this.bioMaps = this.initialView.map(function (viewConf) {
          var res = _this2.allMaps.filter(function (map) {
            return viewConf.source === map.source.id && viewConf.map === map.name;
          });

          if (res.length === 0) {
            // TODO: make a nice mithril component to display errors in the UI
            var info = JSON.stringify(viewConf);
            var msg = "failed to resolve initialView entry: ".concat(info);
            console.error(msg);
            console.trace();
            alert(msg);
          }

          if (viewConf.tracks) {
            res[0].tracks = viewConf.tracks;
          }

          if (viewConf.qtl) {
            res[0].qtlGroups = viewConf.qtl;
          }

          return res;
        }).concatAll();
      }
      /**
       * create this.bioMaps based on first map from each datasource (e.g if
       * initialView was not defined in config file).
       * @private
       */

    }, {
      key: "_defaultInitialView",
      value: function _defaultInitialView() {
        this.bioMaps = this.sources.map(function (src) {
          return Object.values(src.bioMaps)[0];
        });
      }
      /**
       * Request configuration file and map sets
       * @param configURL
       * @private
       */

    }, {
      key: "_loadDataFromConfig",
      value: function _loadDataFromConfig(configURL) {
        var _this3 = this;

        fetch(configURL, {
          cache: 'no-cache'
        }).then(function (r) {
          return checkStatus(r, configURL);
        }) // load config files
        .then(function (r) {
          return r.json();
        }).then(function (data) {
          _this3.header = data.header || '';
          _this3.attribution = data.attribution || '';
          _this3.initialConfig = data;
          var numSources = data.sources.length;
          var plural = numSources > 1 ? 's' : '';

          _this3.updateStatus("loading ".concat(numSources, " data file").concat(plural, "...")); //update status and let index know about it.


          _this3.initialView = data.initialView; // load config data sources as a set of promises to speed up process
          // and make error catching smoother.

          return loadDataSources(data.sources).then(function (dataSources) {
            _this3.sources = dataSources;
            _this3.allMaps = loadMaps(dataSources);

            _this3.bioMaps.push(_this3.allMaps[0]);

            _this3._setInitialView();

            _this3.status = 'Maps Loaded';

            _this3.toggleBusy();
          }).catch(function (e) {
            console.error(e);
            throw e;
          });
        }).catch(function (error) {
          //by this point, error should let it be known where the error comes from.
          _this3.status = error.toString();

          _this3.toggleError();
        }).finally(function () {
          return _this3.inform();
        });
      }
    }]);

    return AppModel;
  }();

  var LayoutBase =
  /*#__PURE__*/
  function (_Component) {
    _inherits(LayoutBase, _Component);

    // constructor() - prefer do not use in mithril dataSourceComponents

    /**
     * mithril lifecycle callback
     * @param vnode
     */
    function LayoutBase() {
      _classCallCheck(this, LayoutBase);

      return _possibleConstructorReturn(this, _getPrototypeOf(LayoutBase).call(this));
    }
    /**
     * mithril lifecycle method
     * @param vnode
     */


    _createClass(LayoutBase, [{
      key: "componentDidMount",
      value: function componentDidMount() {// save a reference to this component's dom element
        //this.bounds = new Bounds(this.base.getBoundingClientRect());
      }
    }, {
      key: "render",
      value: function render$$1() {
        return h("div", null, " Placeholder Div, Please Ignore ");
      }
    }]);

    return LayoutBase;
  }(Component);

  /**
   * @description Helper function for detecting null or undefined.
   */
  var isNil = function isNil(o) {
    return o === null || o === undefined;
  };

  var Bounds =
  /*#__PURE__*/
  function () {
    /**
     * Create a Bounds, as is traditional must pass in at least top and left corners.
     *
     * @param {Object} params - having the following properties:
     * @param {Number} bottom
     * @param {Number} left
     * @param {Number} right
     * @param {Number} top
     * @param {Number} width
     * @param {Number} height
     * @returns {Object}
     */
    function Bounds(_ref) {
      var top = _ref.top,
          left = _ref.left,
          bottom = _ref.bottom,
          right = _ref.right,
          width = _ref.width,
          height = _ref.height,
          _ref$allowSubpixel = _ref.allowSubpixel,
          allowSubpixel = _ref$allowSubpixel === void 0 ? true : _ref$allowSubpixel;

      _classCallCheck(this, Bounds);

      this._bottom = bottom;
      this._left = left;
      this._right = right;
      this._top = top;
      this._height = height;
      this._width = width;
      this.allowSubpixel = allowSubpixel;
      if (isNil(this.width)) this._width = this.right - this.left;
      if (isNil(this.height)) this._height = this.bottom - this.top;
      if (isNil(this.bottom)) this._bottom = this.top + this.height;
      if (isNil(this.right)) this._right = this.left + this.width;

      if (!allowSubpixel) {
        // noinspection JSSuspiciousNameCombination
        this._bottom = Math.floor(this.bottom); // noinspection JSSuspiciousNameCombination

        this._top = Math.floor(this.top);
        this._left = Math.floor(this.left);
        this._right = Math.floor(this.right);
        this._width = Math.floor(this.width); // noinspection JSSuspiciousNameCombination

        this._height = Math.floor(this.height);
        if (this.x) this.x = Math.floor(this.x);

        if (this.y) {
          // noinspection JSSuspiciousNameCombination
          this.y = Math.floor(this.y);
        }
      }
    }
    /**
     * Getters and setters, should be allowed to update bounds without having to
     * resort to making a new bounds object.
     */


    _createClass(Bounds, [{
      key: "equals",

      /**
       * Instance method call of Bounds.equals()
       */
      value: function equals(otherBounds) {
        return Bounds.equals(this, otherBounds);
      }
      /**
       * Area equality, rounds to integer pixel.
       */

    }, {
      key: "areaEquals",
      value: function areaEquals(otherBounds) {
        return Bounds.areaEquals(this, otherBounds);
      }
      /**
       * Translates bounds by x and y
       */

    }, {
      key: "translate",
      value: function translate(x, y) {
        if (this.allowSubpixel) {
          if (x !== 0) {
            this._left += x;
            this._right += x;
          }

          if (y !== 0) {
            this._top += y;
            this._bottom += y;
          }
        } else {
          if (x !== 0) {
            x = Math.floor(x);
            this._left += x;
            this._right += x;
          }

          if (y !== 0) {
            y = Math.floor(y);
            this._top += y;
            this._bottom += y;
          }
        }
      }
    }, {
      key: "bottom",
      get: function get() {
        return this._bottom;
      },
      set: function set(val) {
        if (this.allowSubpixel) {
          this._bottom = val;
          this._height = this._bottom - this._top;
        } else {
          this._bottom = Math.floor(val);
          this._height = Math.floor(this._bottom - this._top);
        }
      }
    }, {
      key: "top",
      get: function get() {
        return this._top;
      },
      set: function set(val) {
        if (this.allowSubpixel) {
          this._top = val;
          this._height = this._bottom - this._top;
        } else {
          this._top = Math.floor(val);
          this._height = Math.floor(this._bottom - this._top);
        }
      }
    }, {
      key: "left",
      get: function get() {
        return this._left;
      },
      set: function set(val) {
        if (this.allowSubpixel) {
          this._left = val;
          this._width = this._right - this._left;
        } else {
          this._left = Math.floor(val);
          this._width = Math.floor(this._right - this._left);
        }
      }
    }, {
      key: "right",
      get: function get() {
        return this._right;
      },
      set: function set(val) {
        if (this.allowSubpixel) {
          this._right = val;
          this._width = this._right - this._left;
        } else {
          this._right = Math.floor(val);
          this._width = Math.floor(this._right - this._left);
        }
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(val) {
        if (this.allowSubpixel) {
          this._width = val;
          this._right = this._left + this._width;
        } else {
          this._right = Math.floor(val);
          this._width = Math.floor(this._left + this._width);
        }
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(val) {
        if (this.allowSubpixel) {
          this._height = val;
          this._bottom = this._top + this._height;
        } else {
          this._height = Math.floor(val);
          this._bottom = Math.floor(this._top + this._height);
        }
      }
      /**
       * Check if width or height is zero, making the Bounds effectively empty.
       */

    }, {
      key: "isEmptyArea",
      get: function get() {
        return !this.width || !this.height;
      }
      /**
       * Area of bounds (width * height)
       */

    }, {
      key: "area",
      get: function get() {
        return this.width * this.height;
      }
      /**
       * Class method- test whether two bounds are equal (rounds to nearest pixel)
       *
       * @param bounds1 - DOMRect or Bounds instance
       * @param bounds2 - DOMRect or Bounds instance
       * @returns Boolean
       */

    }], [{
      key: "equals",
      value: function equals(bounds1, bounds2) {
        var p, n1, n2;
        if (!bounds1 || !bounds2) return false; // check for null args

        for (var i = 0; i < PROPS.length; i++) {
          p = PROPS[i];
          n1 = bounds1[p];
          n2 = bounds2[p];

          if (n1 === undefined || n2 === undefined) {
            // skip test, see note about x,y
            continue;
          } // cast properties from float to int before equality comparison


          if (Math.floor(n1) !== Math.floor(n2)) return false;
        }

        return true;
      }
      /**
       * Class method- test whether two bounds are equal in area (rounds to nearest pixel)
       *
       * @param bounds1 - DOMRect or Bounds instance
       * @param bounds2 - DOMRect or Bounds instance
       * @returns Boolean
       */

    }, {
      key: "areaEquals",
      value: function areaEquals(bounds1, bounds2) {
        if (!bounds1 || !bounds2) return false; // check for null args

        return Math.floor(bounds1.area) === Math.floor(bounds2.area);
      }
    }]);

    return Bounds;
  }(); // DOMRect may *not* have iterable properties, so hardcode them here

  var PROPS = [// note: x any y may not exist!
  'bottom', 'left', 'right', 'top', 'width', 'height', 'x', 'y'];

  var hammer = createCommonjsModule(function (module) {
  /*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license */
  (function(window, document, exportName, undefined) {

  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');

  var TYPE_FUNCTION = 'function';

  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;

  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */
  function setTimeoutContext(fn, timeout, context) {
      return setTimeout(bindFn(fn, context), timeout);
  }

  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */
  function invokeArrayArg(arg, fn, context) {
      if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
      }
      return false;
  }

  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */
  function each(obj, iterator, context) {
      var i;

      if (!obj) {
          return;
      }

      if (obj.forEach) {
          obj.forEach(iterator, context);
      } else if (obj.length !== undefined) {
          i = 0;
          while (i < obj.length) {
              iterator.call(context, obj[i], i, obj);
              i++;
          }
      } else {
          for (i in obj) {
              obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
      }
  }

  /**
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */
  function deprecate(method, name, message) {
      var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
      return function() {
          var e = new Error('get-stack-trace');
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
              .replace(/^\s+at\s+/gm, '')
              .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

          var log = window.console && (window.console.warn || window.console.log);
          if (log) {
              log.call(window.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
      };
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */
  var assign;
  if (typeof Object.assign !== 'function') {
      assign = function assign(target) {
          if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
          }

          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
              var source = arguments[index];
              if (source !== undefined && source !== null) {
                  for (var nextKey in source) {
                      if (source.hasOwnProperty(nextKey)) {
                          output[nextKey] = source[nextKey];
                      }
                  }
              }
          }
          return output;
      };
  } else {
      assign = Object.assign;
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]
   * @returns {Object} dest
   */
  var extend = deprecate(function extend(dest, src, merge) {
      var keys = Object.keys(src);
      var i = 0;
      while (i < keys.length) {
          if (!merge || (merge && dest[keys[i]] === undefined)) {
              dest[keys[i]] = src[keys[i]];
          }
          i++;
      }
      return dest;
  }, 'extend', 'Use `assign`.');

  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */
  var merge = deprecate(function merge(dest, src) {
      return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');

  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */
  function inherit(child, base, properties) {
      var baseP = base.prototype,
          childP;

      childP = child.prototype = Object.create(baseP);
      childP.constructor = child;
      childP._super = baseP;

      if (properties) {
          assign(childP, properties);
      }
  }

  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */
  function bindFn(fn, context) {
      return function boundFn() {
          return fn.apply(context, arguments);
      };
  }

  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */
  function boolOrFn(val, args) {
      if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined : undefined, args);
      }
      return val;
  }

  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */
  function ifUndefined(val1, val2) {
      return (val1 === undefined) ? val2 : val1;
  }

  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function addEventListeners(target, types, handler) {
      each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
      });
  }

  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function removeEventListeners(target, types, handler) {
      each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
      });
  }

  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  function hasParent(node, parent) {
      while (node) {
          if (node == parent) {
              return true;
          }
          node = node.parentNode;
      }
      return false;
  }

  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */
  function inStr(str, find) {
      return str.indexOf(find) > -1;
  }

  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */
  function splitStr(str) {
      return str.trim().split(/\s+/g);
  }

  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */
  function inArray(src, find, findByKey) {
      if (src.indexOf && !findByKey) {
          return src.indexOf(find);
      } else {
          var i = 0;
          while (i < src.length) {
              if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                  return i;
              }
              i++;
          }
          return -1;
      }
  }

  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */
  function toArray(obj) {
      return Array.prototype.slice.call(obj, 0);
  }

  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */
  function uniqueArray(src, key, sort) {
      var results = [];
      var values = [];
      var i = 0;

      while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
              results.push(src[i]);
          }
          values[i] = val;
          i++;
      }

      if (sort) {
          if (!key) {
              results = results.sort();
          } else {
              results = results.sort(function sortUniqueArray(a, b) {
                  return a[key] > b[key];
              });
          }
      }

      return results;
  }

  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */
  function prefixed(obj, property) {
      var prefix, prop;
      var camelProp = property[0].toUpperCase() + property.slice(1);

      var i = 0;
      while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = (prefix) ? prefix + camelProp : property;

          if (prop in obj) {
              return prop;
          }
          i++;
      }
      return undefined;
  }

  /**
   * get a unique id
   * @returns {number} uniqueId
   */
  var _uniqueId = 1;
  function uniqueId() {
      return _uniqueId++;
  }

  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */
  function getWindowForElement(element) {
      var doc = element.ownerDocument || element;
      return (doc.defaultView || doc.parentWindow || window);
  }

  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

  var SUPPORT_TOUCH = ('ontouchstart' in window);
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';

  var COMPUTE_INTERVAL = 25;

  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;

  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;

  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];

  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */
  function Input(manager, callback) {
      var self = this;
      this.manager = manager;
      this.callback = callback;
      this.element = manager.element;
      this.target = manager.options.inputTarget;

      // smaller wrapper around the handler, for the scope and the enabled state of the manager,
      // so when disabled the input events are completely bypassed.
      this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
              self.handler(ev);
          }
      };

      this.init();

  }

  Input.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() { },

      /**
       * bind the events
       */
      init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      },

      /**
       * unbind the events
       */
      destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      }
  };

  /**
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */
  function createInputInstance(manager) {
      var Type;
      var inputClass = manager.options.inputClass;

      if (inputClass) {
          Type = inputClass;
      } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
      } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
      } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
      } else {
          Type = TouchMouseInput;
      }
      return new (Type)(manager, inputHandler);
  }

  /**
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */
  function inputHandler(manager, eventType, input) {
      var pointersLen = input.pointers.length;
      var changedPointersLen = input.changedPointers.length;
      var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
      var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

      input.isFirst = !!isFirst;
      input.isFinal = !!isFinal;

      if (isFirst) {
          manager.session = {};
      }

      // source event is the normalized value of the domEvents
      // like 'touchstart, mouseup, pointerdown'
      input.eventType = eventType;

      // compute scale, rotation etc
      computeInputData(manager, input);

      // emit secret event
      manager.emit('hammer.input', input);

      manager.recognize(input);
      manager.session.prevInput = input;
  }

  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */
  function computeInputData(manager, input) {
      var session = manager.session;
      var pointers = input.pointers;
      var pointersLength = pointers.length;

      // store the first input to calculate the distance and direction
      if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
      }

      // to compute scale and rotation we need to store the multiple touches
      if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
      } else if (pointersLength === 1) {
          session.firstMultiple = false;
      }

      var firstInput = session.firstInput;
      var firstMultiple = session.firstMultiple;
      var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

      var center = input.center = getCenter(pointers);
      input.timeStamp = now();
      input.deltaTime = input.timeStamp - firstInput.timeStamp;

      input.angle = getAngle(offsetCenter, center);
      input.distance = getDistance(offsetCenter, center);

      computeDeltaXY(session, input);
      input.offsetDirection = getDirection(input.deltaX, input.deltaY);

      var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
      input.overallVelocityX = overallVelocity.x;
      input.overallVelocityY = overallVelocity.y;
      input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

      input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
      input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

      input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
          session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

      computeIntervalInputData(session, input);

      // find the correct target
      var target = manager.element;
      if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
      }
      input.target = target;
  }

  function computeDeltaXY(session, input) {
      var center = input.center;
      var offset = session.offsetDelta || {};
      var prevDelta = session.prevDelta || {};
      var prevInput = session.prevInput || {};

      if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
          };

          offset = session.offsetDelta = {
              x: center.x,
              y: center.y
          };
      }

      input.deltaX = prevDelta.x + (center.x - offset.x);
      input.deltaY = prevDelta.y + (center.y - offset.y);
  }

  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */
  function computeIntervalInputData(session, input) {
      var last = session.lastInterval || input,
          deltaTime = input.timeStamp - last.timeStamp,
          velocity, velocityX, velocityY, direction;

      if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;

          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);

          session.lastInterval = input;
      } else {
          // use latest velocity info if it doesn't overtake a minimum period
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
      }

      input.velocity = velocity;
      input.velocityX = velocityX;
      input.velocityY = velocityY;
      input.direction = direction;
  }

  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */
  function simpleCloneInputData(input) {
      // make a simple copy of the pointers because we will get a reference if we don't
      // we only need clientXY for the calculations
      var pointers = [];
      var i = 0;
      while (i < input.pointers.length) {
          pointers[i] = {
              clientX: round(input.pointers[i].clientX),
              clientY: round(input.pointers[i].clientY)
          };
          i++;
      }

      return {
          timeStamp: now(),
          pointers: pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
      };
  }

  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */
  function getCenter(pointers) {
      var pointersLength = pointers.length;

      // no need to loop when only one touch
      if (pointersLength === 1) {
          return {
              x: round(pointers[0].clientX),
              y: round(pointers[0].clientY)
          };
      }

      var x = 0, y = 0, i = 0;
      while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
      }

      return {
          x: round(x / pointersLength),
          y: round(y / pointersLength)
      };
  }

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */
  function getVelocity(deltaTime, x, y) {
      return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
      };
  }

  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */
  function getDirection(x, y) {
      if (x === y) {
          return DIRECTION_NONE;
      }

      if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }

  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */
  function getDistance(p1, p2, props) {
      if (!props) {
          props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];

      return Math.sqrt((x * x) + (y * y));
  }

  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */
  function getAngle(p1, p2, props) {
      if (!props) {
          props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
      return Math.atan2(y, x) * 180 / Math.PI;
  }

  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */
  function getRotation(start, end) {
      return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }

  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */
  function getScale(start, end) {
      return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }

  var MOUSE_INPUT_MAP = {
      mousedown: INPUT_START,
      mousemove: INPUT_MOVE,
      mouseup: INPUT_END
  };

  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

  /**
   * Mouse events input
   * @constructor
   * @extends Input
   */
  function MouseInput() {
      this.evEl = MOUSE_ELEMENT_EVENTS;
      this.evWin = MOUSE_WINDOW_EVENTS;

      this.pressed = false; // mousedown state

      Input.apply(this, arguments);
  }

  inherit(MouseInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];

          // on start we want to have the left mouse button down
          if (eventType & INPUT_START && ev.button === 0) {
              this.pressed = true;
          }

          if (eventType & INPUT_MOVE && ev.which !== 1) {
              eventType = INPUT_END;
          }

          // mouse must be down
          if (!this.pressed) {
              return;
          }

          if (eventType & INPUT_END) {
              this.pressed = false;
          }

          this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
          });
      }
  });

  var POINTER_INPUT_MAP = {
      pointerdown: INPUT_START,
      pointermove: INPUT_MOVE,
      pointerup: INPUT_END,
      pointercancel: INPUT_CANCEL,
      pointerout: INPUT_CANCEL
  };

  // in IE10 the pointer types is defined as an enum
  var IE10_POINTER_TYPE_ENUM = {
      2: INPUT_TYPE_TOUCH,
      3: INPUT_TYPE_PEN,
      4: INPUT_TYPE_MOUSE,
      5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
  };

  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

  // IE10 has prefixed support, and case-sensitive
  if (window.MSPointerEvent && !window.PointerEvent) {
      POINTER_ELEMENT_EVENTS = 'MSPointerDown';
      POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }

  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */
  function PointerEventInput() {
      this.evEl = POINTER_ELEMENT_EVENTS;
      this.evWin = POINTER_WINDOW_EVENTS;

      Input.apply(this, arguments);

      this.store = (this.manager.session.pointerEvents = []);
  }

  inherit(PointerEventInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;

          var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

          var isTouch = (pointerType == INPUT_TYPE_TOUCH);

          // get index of the event in the store
          var storeIndex = inArray(store, ev.pointerId, 'pointerId');

          // start and mouse must be down
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                  store.push(ev);
                  storeIndex = store.length - 1;
              }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
              removePointer = true;
          }

          // it not found, so the pointer hasn't been down (so it's probably a hover)
          if (storeIndex < 0) {
              return;
          }

          // update the event in the store
          store[storeIndex] = ev;

          this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType: pointerType,
              srcEvent: ev
          });

          if (removePointer) {
              // remove from the store
              store.splice(storeIndex, 1);
          }
      }
  });

  var SINGLE_TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
  };

  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Touch events input
   * @constructor
   * @extends Input
   */
  function SingleTouchInput() {
      this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
      this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
      this.started = false;

      Input.apply(this, arguments);
  }

  inherit(SingleTouchInput, Input, {
      handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

          // should we handle the touch events?
          if (type === INPUT_START) {
              this.started = true;
          }

          if (!this.started) {
              return;
          }

          var touches = normalizeSingleTouches.call(this, ev, type);

          // when done, reset the started state
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
          }

          this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
          });
      }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function normalizeSingleTouches(ev, type) {
      var all = toArray(ev.touches);
      var changed = toArray(ev.changedTouches);

      if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), 'identifier', true);
      }

      return [all, changed];
  }

  var TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
  };

  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */
  function TouchInput() {
      this.evTarget = TOUCH_TARGET_EVENTS;
      this.targetIds = {};

      Input.apply(this, arguments);
  }

  inherit(TouchInput, Input, {
      handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
              return;
          }

          this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
          });
      }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function getTouches(ev, type) {
      var allTouches = toArray(ev.touches);
      var targetIds = this.targetIds;

      // when there is only one touch, the process can be simplified
      if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
      }

      var i,
          targetTouches,
          changedTouches = toArray(ev.changedTouches),
          changedTargetTouches = [],
          target = this.target;

      // get target touches from touches
      targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
      });

      // collect touches
      if (type === INPUT_START) {
          i = 0;
          while (i < targetTouches.length) {
              targetIds[targetTouches[i].identifier] = true;
              i++;
          }
      }

      // filter changed touches to only contain touches that exist in the collected target ids
      i = 0;
      while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
              changedTargetTouches.push(changedTouches[i]);
          }

          // cleanup removed touches
          if (type & (INPUT_END | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i].identifier];
          }
          i++;
      }

      if (!changedTargetTouches.length) {
          return;
      }

      return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
          changedTargetTouches
      ];
  }

  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */

  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DISTANCE = 25;

  function TouchMouseInput() {
      Input.apply(this, arguments);

      var handler = bindFn(this.handler, this);
      this.touch = new TouchInput(this.manager, handler);
      this.mouse = new MouseInput(this.manager, handler);

      this.primaryTouch = null;
      this.lastTouches = [];
  }

  inherit(TouchMouseInput, Input, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
              isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
          }

          // when we're in a touch event, record touches to  de-dupe synthetic mouse event
          if (isTouch) {
              recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
              return;
          }

          this.callback(manager, inputEvent, inputData);
      },

      /**
       * remove the event listeners
       */
      destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
      }
  });

  function recordTouches(eventType, eventData) {
      if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
      }
  }

  function setLastTouch(eventData) {
      var touch = eventData.changedPointers[0];

      if (touch.identifier === this.primaryTouch) {
          var lastTouch = {x: touch.clientX, y: touch.clientY};
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
              var i = lts.indexOf(lastTouch);
              if (i > -1) {
                  lts.splice(i, 1);
              }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
      }
  }

  function isSyntheticEvent(eventData) {
      var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
      for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
          }
      }
      return false;
  }

  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

  // magical touchAction value
  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  var TOUCH_ACTION_MAP = getTouchActionProps();

  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */
  function TouchAction(manager, value) {
      this.manager = manager;
      this.set(value);
  }

  TouchAction.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(value) {
          // find out the touch-action by the event handlers
          if (value == TOUCH_ACTION_COMPUTE) {
              value = this.compute();
          }

          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
      },

      /**
       * just re-set the touchAction value
       */
      update: function() {
          this.set(this.manager.options.touchAction);
      },

      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                  actions = actions.concat(recognizer.getTouchAction());
              }
          });
          return cleanTouchActions(actions.join(' '));
      },

      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;

          // if the touch action did prevented once this session
          if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
          }

          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

          if (hasNone) {
              //do not prevent defaults if this is a tap gesture

              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;

              if (isTapPointer && isTapMovement && isTapTouchTime) {
                  return;
              }
          }

          if (hasPanX && hasPanY) {
              // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
              return;
          }

          if (hasNone ||
              (hasPanY && direction & DIRECTION_HORIZONTAL) ||
              (hasPanX && direction & DIRECTION_VERTICAL)) {
              return this.preventSrc(srcEvent);
          }
      },

      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
      }
  };

  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */
  function cleanTouchActions(actions) {
      // none
      if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
      }

      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

      // if both pan-x and pan-y are set (different recognizers
      // for different directions, e.g. horizontal pan but vertical swipe?)
      // we need none (as otherwise with pan-x pan-y combined none of these
      // recognizers will work, since the browser would handle all panning
      if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
      }

      // pan-x OR pan-y
      if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
      }

      // manipulation
      if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
      }

      return TOUCH_ACTION_AUTO;
  }

  function getTouchActionProps() {
      if (!NATIVE_TOUCH_ACTION) {
          return false;
      }
      var touchMap = {};
      var cssSupports = window.CSS && window.CSS.supports;
      ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

          // If css.supports is not supported but there is native touch-action assume it supports
          // all values. This is the case for IE 10 and 11.
          touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
      });
      return touchMap;
  }

  /**
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */
  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;

  /**
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */
  function Recognizer(options) {
      this.options = assign({}, this.defaults, options || {});

      this.id = uniqueId();

      this.manager = null;

      // default is enable true
      this.options.enable = ifUndefined(this.options.enable, true);

      this.state = STATE_POSSIBLE;

      this.simultaneous = {};
      this.requireFail = [];
  }

  Recognizer.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},

      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(options) {
          assign(this.options, options);

          // also update the touchAction, in case something changed about the directions/enabled state
          this.manager && this.manager.touchAction.update();
          return this;
      },

      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
              return this;
          }

          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
          }
          return this;
      },

      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
              return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
      },

      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
              return this;
          }

          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
          }
          return this;
      },

      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
              return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
              this.requireFail.splice(index, 1);
          }
          return this;
      },

      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
          return this.requireFail.length > 0;
      },

      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
      },

      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(input) {
          var self = this;
          var state = this.state;

          function emit(event) {
              self.manager.emit(event, input);
          }

          // 'panstart' and 'panmove'
          if (state < STATE_ENDED) {
              emit(self.options.event + stateStr(state));
          }

          emit(self.options.event); // simple 'eventName' events

          if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
              emit(input.additionalEvent);
          }

          // panend and pancancel
          if (state >= STATE_ENDED) {
              emit(self.options.event + stateStr(state));
          }
      },

      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(input) {
          if (this.canEmit()) {
              return this.emit(input);
          }
          // it's failing anyway
          this.state = STATE_FAILED;
      },

      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
              if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                  return false;
              }
              i++;
          }
          return true;
      },

      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(inputData) {
          // make a new copy of the inputData
          // so we can change the inputData without messing up the other recognizers
          var inputDataClone = assign({}, inputData);

          // is is enabled and allow recognizing?
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
          }

          // reset when we've reached the end
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
          }

          this.state = this.process(inputDataClone);

          // the recognizer has recognized a gesture
          // so trigger an event
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
          }
      },

      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(inputData) { }, // jshint ignore:line

      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() { },

      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() { }
  };

  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */
  function stateStr(state) {
      if (state & STATE_CANCELLED) {
          return 'cancel';
      } else if (state & STATE_ENDED) {
          return 'end';
      } else if (state & STATE_CHANGED) {
          return 'move';
      } else if (state & STATE_BEGAN) {
          return 'start';
      }
      return '';
  }

  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */
  function directionStr(direction) {
      if (direction == DIRECTION_DOWN) {
          return 'down';
      } else if (direction == DIRECTION_UP) {
          return 'up';
      } else if (direction == DIRECTION_LEFT) {
          return 'left';
      } else if (direction == DIRECTION_RIGHT) {
          return 'right';
      }
      return '';
  }

  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */
  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
      var manager = recognizer.manager;
      if (manager) {
          return manager.get(otherRecognizer);
      }
      return otherRecognizer;
  }

  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */
  function AttrRecognizer() {
      Recognizer.apply(this, arguments);
  }

  inherit(AttrRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
      },

      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
      },

      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(input) {
          var state = this.state;
          var eventType = input.eventType;

          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);

          // on cancel input and we've recognized before, return STATE_CANCELLED
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
              if (eventType & INPUT_END) {
                  return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                  return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
          }
          return STATE_FAILED;
      }
  });

  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function PanRecognizer() {
      AttrRecognizer.apply(this, arguments);

      this.pX = null;
      this.pY = null;
  }

  inherit(PanRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
          event: 'pan',
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
      },

      getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
      },

      directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;

          // lock to axis?
          if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                  direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                  hasMoved = x != this.pX;
                  distance = Math.abs(input.deltaX);
              } else {
                  direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                  hasMoved = y != this.pY;
                  distance = Math.abs(input.deltaY);
              }
          }
          input.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
      },

      attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) &&
              (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
      },

      emit: function(input) {

          this.pX = input.deltaX;
          this.pY = input.deltaY;

          var direction = directionStr(input.direction);

          if (direction) {
              input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
      }
  });

  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */
  function PinchRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(PinchRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
          event: 'pinch',
          threshold: 0,
          pointers: 2
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
      },

      attrTest: function(input) {
          return this._super.attrTest.call(this, input) &&
              (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
      },

      emit: function(input) {
          if (input.scale !== 1) {
              var inOut = input.scale < 1 ? 'in' : 'out';
              input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
      }
  });

  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */
  function PressRecognizer() {
      Recognizer.apply(this, arguments);

      this._timer = null;
      this._input = null;
  }

  inherit(PressRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
          event: 'press',
          pointers: 1,
          time: 251, // minimal time of the pointer to be pressed
          threshold: 9 // a minimal movement is ok, but keep it low
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
      },

      process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;

          this._input = input;

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
              this.reset();
          } else if (input.eventType & INPUT_START) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
              }, options.time, this);
          } else if (input.eventType & INPUT_END) {
              return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
      },

      reset: function() {
          clearTimeout(this._timer);
      },

      emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
              return;
          }

          if (input && (input.eventType & INPUT_END)) {
              this.manager.emit(this.options.event + 'up', input);
          } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
          }
      }
  });

  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */
  function RotateRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(RotateRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
          event: 'rotate',
          threshold: 0,
          pointers: 2
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
      },

      attrTest: function(input) {
          return this._super.attrTest.call(this, input) &&
              (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
      }
  });

  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function SwipeRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(SwipeRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
          event: 'swipe',
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
      },

      getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
      },

      attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;

          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
          }

          return this._super.attrTest.call(this, input) &&
              direction & input.offsetDirection &&
              input.distance > this.options.threshold &&
              input.maxPointers == this.options.pointers &&
              abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
      },

      emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
              this.manager.emit(this.options.event + direction, input);
          }

          this.manager.emit(this.options.event, input);
      }
  });

  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */
  function TapRecognizer() {
      Recognizer.apply(this, arguments);

      // previous time and center,
      // used for tap counting
      this.pTime = false;
      this.pCenter = false;

      this._timer = null;
      this._input = null;
      this.count = 0;
  }

  inherit(TapRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
          event: 'tap',
          pointers: 1,
          taps: 1,
          interval: 300, // max time between the multi-tap taps
          time: 250, // max time of the pointer to be down (like finger on the screen)
          threshold: 9, // a minimal movement is ok, but keep it low
          posThreshold: 10 // a multi-tap can be a bit off the initial position
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
      },

      process: function(input) {
          var options = this.options;

          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;

          this.reset();

          if ((input.eventType & INPUT_START) && (this.count === 0)) {
              return this.failTimeout();
          }

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END) {
                  return this.failTimeout();
              }

              var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

              this.pTime = input.timeStamp;
              this.pCenter = input.center;

              if (!validMultiTap || !validInterval) {
                  this.count = 1;
              } else {
                  this.count += 1;
              }

              this._input = input;

              // if tap count matches we have recognized it,
              // else it has began recognizing...
              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                  // no failing requirements, immediately trigger the tap event
                  // or wait as long as the multitap interval to trigger
                  if (!this.hasRequireFailures()) {
                      return STATE_RECOGNIZED;
                  } else {
                      this._timer = setTimeoutContext(function() {
                          this.state = STATE_RECOGNIZED;
                          this.tryEmit();
                      }, options.interval, this);
                      return STATE_BEGAN;
                  }
              }
          }
          return STATE_FAILED;
      },

      failTimeout: function() {
          this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
      },

      reset: function() {
          clearTimeout(this._timer);
      },

      emit: function() {
          if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
          }
      }
  });

  /**
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Hammer(element, options) {
      options = options || {};
      options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
      return new Manager(element, options);
  }

  /**
   * @const {string}
   */
  Hammer.VERSION = '2.0.7';

  /**
   * default settings
   * @namespace
   */
  Hammer.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: false,

      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: TOUCH_ACTION_COMPUTE,

      /**
       * @type {Boolean}
       * @default true
       */
      enable: true,

      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,

      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,

      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, {enable: false}],
          [PinchRecognizer, {enable: false}, ['rotate']],
          [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
          [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
          [TapRecognizer],
          [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
          [PressRecognizer]
      ],

      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: 'none',

          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: 'none',

          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: 'none',

          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: 'none',

          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: 'none',

          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: 'rgba(0,0,0,0)'
      }
  };

  var STOP = 1;
  var FORCED_STOP = 2;

  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Manager(element, options) {
      this.options = assign({}, Hammer.defaults, options || {});

      this.options.inputTarget = this.options.inputTarget || element;

      this.handlers = {};
      this.session = {};
      this.recognizers = [];
      this.oldCssProps = {};

      this.element = element;
      this.input = createInputInstance(this);
      this.touchAction = new TouchAction(this, this.options.touchAction);

      toggleCssProps(this, true);

      each(this.options.recognizers, function(item) {
          var recognizer = this.add(new (item[0])(item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
      }, this);
  }

  Manager.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(options) {
          assign(this.options, options);

          // Options that need a little more setup
          if (options.touchAction) {
              this.touchAction.update();
          }
          if (options.inputTarget) {
              // Clean up existing event listeners and reinitialize
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
          }
          return this;
      },

      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
      },

      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
              return;
          }

          // run the touch-action polyfill
          this.touchAction.preventDefaults(inputData);

          var recognizer;
          var recognizers = this.recognizers;

          // this holds the recognizer that is being recognized.
          // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
          // if no recognizer is detecting a thing, it is set to `null`
          var curRecognizer = session.curRecognizer;

          // reset when the last recognizer is recognized
          // or when we're in a new session
          if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
              curRecognizer = session.curRecognizer = null;
          }

          var i = 0;
          while (i < recognizers.length) {
              recognizer = recognizers[i];

              // find out if we are allowed try to recognize the input for this one.
              // 1.   allow if the session is NOT forced stopped (see the .stop() method)
              // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
              //      that is being recognized.
              // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
              //      this can be setup with the `recognizeWith()` method on the recognizer.
              if (session.stopped !== FORCED_STOP && ( // 1
                      !curRecognizer || recognizer == curRecognizer || // 2
                      recognizer.canRecognizeWith(curRecognizer))) { // 3
                  recognizer.recognize(inputData);
              } else {
                  recognizer.reset();
              }

              // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
              // current active recognizer. but only if we don't already have an active recognizer
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                  curRecognizer = session.curRecognizer = recognizer;
              }
              i++;
          }
      },

      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
              return recognizer;
          }

          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
              if (recognizers[i].options.event == recognizer) {
                  return recognizers[i];
              }
          }
          return null;
      },

      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(recognizer) {
          if (invokeArrayArg(recognizer, 'add', this)) {
              return this;
          }

          // remove existing
          var existing = this.get(recognizer.options.event);
          if (existing) {
              this.remove(existing);
          }

          this.recognizers.push(recognizer);
          recognizer.manager = this;

          this.touchAction.update();
          return recognizer;
      },

      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(recognizer) {
          if (invokeArrayArg(recognizer, 'remove', this)) {
              return this;
          }

          recognizer = this.get(recognizer);

          // let's make sure this recognizer exists
          if (recognizer) {
              var recognizers = this.recognizers;
              var index = inArray(recognizers, recognizer);

              if (index !== -1) {
                  recognizers.splice(index, 1);
                  this.touchAction.update();
              }
          }

          return this;
      },

      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(events, handler) {
          if (events === undefined) {
              return;
          }
          if (handler === undefined) {
              return;
          }

          var handlers = this.handlers;
          each(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
          });
          return this;
      },

      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(events, handler) {
          if (events === undefined) {
              return;
          }

          var handlers = this.handlers;
          each(splitStr(events), function(event) {
              if (!handler) {
                  delete handlers[event];
              } else {
                  handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
          });
          return this;
      },

      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(event, data) {
          // we also want to trigger dom events
          if (this.options.domEvents) {
              triggerDomEvent(event, data);
          }

          // no handlers, so skip it all
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
              return;
          }

          data.type = event;
          data.preventDefault = function() {
              data.srcEvent.preventDefault();
          };

          var i = 0;
          while (i < handlers.length) {
              handlers[i](data);
              i++;
          }
      },

      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
          this.element && toggleCssProps(this, false);

          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
      }
  };

  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */
  function toggleCssProps(manager, add) {
      var element = manager.element;
      if (!element.style) {
          return;
      }
      var prop;
      each(manager.options.cssProps, function(value, name) {
          prop = prefixed(element.style, name);
          if (add) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value;
          } else {
              element.style[prop] = manager.oldCssProps[prop] || '';
          }
      });
      if (!add) {
          manager.oldCssProps = {};
      }
  }

  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */
  function triggerDomEvent(event, data) {
      var gestureEvent = document.createEvent('Event');
      gestureEvent.initEvent(event, true, true);
      gestureEvent.gesture = data;
      data.target.dispatchEvent(gestureEvent);
  }

  assign(Hammer, {
      INPUT_START: INPUT_START,
      INPUT_MOVE: INPUT_MOVE,
      INPUT_END: INPUT_END,
      INPUT_CANCEL: INPUT_CANCEL,

      STATE_POSSIBLE: STATE_POSSIBLE,
      STATE_BEGAN: STATE_BEGAN,
      STATE_CHANGED: STATE_CHANGED,
      STATE_ENDED: STATE_ENDED,
      STATE_RECOGNIZED: STATE_RECOGNIZED,
      STATE_CANCELLED: STATE_CANCELLED,
      STATE_FAILED: STATE_FAILED,

      DIRECTION_NONE: DIRECTION_NONE,
      DIRECTION_LEFT: DIRECTION_LEFT,
      DIRECTION_RIGHT: DIRECTION_RIGHT,
      DIRECTION_UP: DIRECTION_UP,
      DIRECTION_DOWN: DIRECTION_DOWN,
      DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
      DIRECTION_VERTICAL: DIRECTION_VERTICAL,
      DIRECTION_ALL: DIRECTION_ALL,

      Manager: Manager,
      Input: Input,
      TouchAction: TouchAction,

      TouchInput: TouchInput,
      MouseInput: MouseInput,
      PointerEventInput: PointerEventInput,
      TouchMouseInput: TouchMouseInput,
      SingleTouchInput: SingleTouchInput,

      Recognizer: Recognizer,
      AttrRecognizer: AttrRecognizer,
      Tap: TapRecognizer,
      Pan: PanRecognizer,
      Swipe: SwipeRecognizer,
      Pinch: PinchRecognizer,
      Rotate: RotateRecognizer,
      Press: PressRecognizer,

      on: addEventListeners,
      off: removeEventListeners,
      each: each,
      merge: merge,
      extend: extend,
      assign: assign,
      inherit: inherit,
      bindFn: bindFn,
      prefixed: prefixed
  });

  // this prevents errors when Hammer is loaded in the presence of an AMD
  //  style loader but by script tag, not by the loader.
  var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
  freeGlobal.Hammer = Hammer;

  if (typeof undefined === 'function' && undefined.amd) {
      undefined(function() {
          return Hammer;
      });
  } else if (module.exports) {
      module.exports = Hammer;
  } else {
      window[exportName] = Hammer;
  }

  })(window, document, 'Hammer');
  });

  /**
   * Conversion table from react event to hammer event.
   */

  var handlerToEvent = {
    action: 'tap press',
    onDoubleTap: 'doubletap',
    onPan: 'pan',
    onPanCancel: 'pancancel',
    onPanEnd: 'panend',
    onPanStart: 'panstart',
    onPinch: 'pinch',
    onPinchCancel: 'pinchcancel',
    onPinchEnd: 'pinchend',
    onPinchIn: 'pinchin',
    onPinchOut: 'pinchout',
    onPinchStart: 'pinchstart',
    onPress: 'press',
    onPressUp: 'pressup',
    onRotate: 'rotate',
    onRotateCancel: 'rotatecancel',
    onRotateEnd: 'rotateend',
    onRotateMove: 'rotatemove',
    onRotateStart: 'rotatestart',
    onSwipe: 'swipe',
    onSwipeRight: 'swiperight',
    onSwipeLeft: 'swipeleft',
    onSwipeUp: 'swipeup',
    onSwipeDown: 'swipedown',
    onTap: 'tap'
  }; // Array for props that are to be used to setup hammer

  var hammerProps = {
    children: true,
    direction: true,
    options: true,
    recognizeWith: true,
    vertical: true
  }; // add above events to the protected events

  Object.keys(handlerToEvent).forEach(function (event) {
    hammerProps[event] = true;
  });

  function hammerSetup(hammer$$1, props) {
    // setup directions for hammer to watch on pan and swipe
    var direction = props.direction;

    if (direction) {
      hammer$$1.get('pan').set({
        direction: hammer[direction]
      });
      hammer$$1.get('swipe').set({
        direction: hammer[direction]
      });
    } // can pass an options property to toggle hammer options, see hammer docs.


    if (props.options) {
      Object.keys(props.options).forEach(function (option) {
        if (option === 'recognizers') {
          Object.keys(props.options.recognizers).forEach(function (gesture) {
            var recognizer = hammer$$1.get(gesture);
            recognizer.set(props.options.recognizers[gesture]);

            if (props.options.recognizers[gesture].requireFailure) {
              recognizer.requireFailure(props.options.recognizers[gesture].requireFailure);
            }
          });
        } else {
          var optionObj = {};
          optionObj[option] = props.options[option];
          hammer$$1.set(optionObj);
        }
      });
    } // setup hammer recognize with props


    if (props.recognizeWith) {
      Object.keys(props.recognizeWith).forEach(function (gesture) {
        var recognizer = hammer$$1.get(gesture);
        recognizer.recognizeWith(props.recognizeWith[gesture]);
      });
    } // convert prop event to hammer event and register


    Object.keys(props).forEach(function (prop) {
      var event = handlerToEvent[prop];

      if (event) {
        hammer$$1.off(event);
        hammer$$1.on(event, props[prop]);
      }
    });
  }

  var GestureWrapper =
  /*#__PURE__*/
  function (_Component) {
    _inherits(GestureWrapper, _Component);

    function GestureWrapper() {
      _classCallCheck(this, GestureWrapper);

      return _possibleConstructorReturn(this, _getPrototypeOf(GestureWrapper).apply(this, arguments));
    }

    _createClass(GestureWrapper, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.hammer = new hammer(this.base);
        hammerSetup(this.hammer, this.props);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        if (this.hammer) {
          hammerSetup(this.hammer, this.props);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.hammer) {
          this.hammer.stop();
          this.hammer.destroy();
        }

        this.hammer = null;
      }
    }, {
      key: "render",
      value: function render$$1(props) {
        var _this = this;

        var childProps = {};
        Object.keys(props).forEach(function (prop) {
          if (!hammerProps[prop]) {
            childProps[prop] = _this.props[prop];
          }
        }); //clone child passed and give it new props from the hammer stuff

        return cloneElement(props.children[0], childProps);
      }
    }]);

    return GestureWrapper;
  }(Component);

  var quickselect = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
  	module.exports = factory();
  }(commonjsGlobal, (function () {
  function quickselect(arr, k, left, right, compare) {
      quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
  }

  function quickselectStep(arr, k, left, right, compare) {

      while (right > left) {
          if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z = Math.log(n);
              var s = 0.5 * Math.exp(2 * z / 3);
              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr, k, newLeft, newRight, compare);
          }

          var t = arr[k];
          var i = left;
          var j = right;

          swap(arr, left, k);
          if (compare(arr[right], t) > 0) swap(arr, left, right);

          while (i < j) {
              swap(arr, i, j);
              i++;
              j--;
              while (compare(arr[i], t) < 0) i++;
              while (compare(arr[j], t) > 0) j--;
          }

          if (compare(arr[left], t) === 0) swap(arr, left, j);
          else {
              j++;
              swap(arr, j, right);
          }

          if (j <= k) left = j + 1;
          if (k <= j) right = j - 1;
      }
  }

  function swap(arr, i, j) {
      var tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
  }

  function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
  }

  return quickselect;

  })));
  });

  var rbush_1 = rbush;
  var default_1 = rbush;



  function rbush(maxEntries, format) {
      if (!(this instanceof rbush)) return new rbush(maxEntries, format);

      // max entries in a node is 9 by default; min node fill is 40% for best performance
      this._maxEntries = Math.max(4, maxEntries || 9);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

      if (format) {
          this._initFormat(format);
      }

      this.clear();
  }

  rbush.prototype = {

      all: function () {
          return this._all(this.data, []);
      },

      search: function (bbox) {

          var node = this.data,
              result = [],
              toBBox = this.toBBox;

          if (!intersects(bbox, node)) return result;

          var nodesToSearch = [],
              i, len, child, childBBox;

          while (node) {
              for (i = 0, len = node.children.length; i < len; i++) {

                  child = node.children[i];
                  childBBox = node.leaf ? toBBox(child) : child;

                  if (intersects(bbox, childBBox)) {
                      if (node.leaf) result.push(child);
                      else if (contains(bbox, childBBox)) this._all(child, result);
                      else nodesToSearch.push(child);
                  }
              }
              node = nodesToSearch.pop();
          }

          return result;
      },

      collides: function (bbox) {

          var node = this.data,
              toBBox = this.toBBox;

          if (!intersects(bbox, node)) return false;

          var nodesToSearch = [],
              i, len, child, childBBox;

          while (node) {
              for (i = 0, len = node.children.length; i < len; i++) {

                  child = node.children[i];
                  childBBox = node.leaf ? toBBox(child) : child;

                  if (intersects(bbox, childBBox)) {
                      if (node.leaf || contains(bbox, childBBox)) return true;
                      nodesToSearch.push(child);
                  }
              }
              node = nodesToSearch.pop();
          }

          return false;
      },

      load: function (data) {
          if (!(data && data.length)) return this;

          if (data.length < this._minEntries) {
              for (var i = 0, len = data.length; i < len; i++) {
                  this.insert(data[i]);
              }
              return this;
          }

          // recursively build the tree with the given data from scratch using OMT algorithm
          var node = this._build(data.slice(), 0, data.length - 1, 0);

          if (!this.data.children.length) {
              // save as is if tree is empty
              this.data = node;

          } else if (this.data.height === node.height) {
              // split root if trees have the same height
              this._splitRoot(this.data, node);

          } else {
              if (this.data.height < node.height) {
                  // swap trees if inserted one is bigger
                  var tmpNode = this.data;
                  this.data = node;
                  node = tmpNode;
              }

              // insert the small tree into the large tree at appropriate level
              this._insert(node, this.data.height - node.height - 1, true);
          }

          return this;
      },

      insert: function (item) {
          if (item) this._insert(item, this.data.height - 1);
          return this;
      },

      clear: function () {
          this.data = createNode$1([]);
          return this;
      },

      remove: function (item, equalsFn) {
          if (!item) return this;

          var node = this.data,
              bbox = this.toBBox(item),
              path = [],
              indexes = [],
              i, parent, index, goingUp;

          // depth-first iterative tree traversal
          while (node || path.length) {

              if (!node) { // go up
                  node = path.pop();
                  parent = path[path.length - 1];
                  i = indexes.pop();
                  goingUp = true;
              }

              if (node.leaf) { // check current node
                  index = findItem(item, node.children, equalsFn);

                  if (index !== -1) {
                      // item found, remove the item and condense tree upwards
                      node.children.splice(index, 1);
                      path.push(node);
                      this._condense(path);
                      return this;
                  }
              }

              if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                  path.push(node);
                  indexes.push(i);
                  i = 0;
                  parent = node;
                  node = node.children[0];

              } else if (parent) { // go right
                  i++;
                  node = parent.children[i];
                  goingUp = false;

              } else node = null; // nothing found
          }

          return this;
      },

      toBBox: function (item) { return item; },

      compareMinX: compareNodeMinX,
      compareMinY: compareNodeMinY,

      toJSON: function () { return this.data; },

      fromJSON: function (data) {
          this.data = data;
          return this;
      },

      _all: function (node, result) {
          var nodesToSearch = [];
          while (node) {
              if (node.leaf) result.push.apply(result, node.children);
              else nodesToSearch.push.apply(nodesToSearch, node.children);

              node = nodesToSearch.pop();
          }
          return result;
      },

      _build: function (items, left, right, height) {

          var N = right - left + 1,
              M = this._maxEntries,
              node;

          if (N <= M) {
              // reached leaf level; return leaf
              node = createNode$1(items.slice(left, right + 1));
              calcBBox(node, this.toBBox);
              return node;
          }

          if (!height) {
              // target height of the bulk-loaded tree
              height = Math.ceil(Math.log(N) / Math.log(M));

              // target number of root entries to maximize storage utilization
              M = Math.ceil(N / Math.pow(M, height - 1));
          }

          node = createNode$1([]);
          node.leaf = false;
          node.height = height;

          // split the items into M mostly square tiles

          var N2 = Math.ceil(N / M),
              N1 = N2 * Math.ceil(Math.sqrt(M)),
              i, j, right2, right3;

          multiSelect(items, left, right, N1, this.compareMinX);

          for (i = left; i <= right; i += N1) {

              right2 = Math.min(i + N1 - 1, right);

              multiSelect(items, i, right2, N2, this.compareMinY);

              for (j = i; j <= right2; j += N2) {

                  right3 = Math.min(j + N2 - 1, right2);

                  // pack each entry recursively
                  node.children.push(this._build(items, j, right3, height - 1));
              }
          }

          calcBBox(node, this.toBBox);

          return node;
      },

      _chooseSubtree: function (bbox, node, level, path) {

          var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

          while (true) {
              path.push(node);

              if (node.leaf || path.length - 1 === level) break;

              minArea = minEnlargement = Infinity;

              for (i = 0, len = node.children.length; i < len; i++) {
                  child = node.children[i];
                  area = bboxArea(child);
                  enlargement = enlargedArea(bbox, child) - area;

                  // choose entry with the least area enlargement
                  if (enlargement < minEnlargement) {
                      minEnlargement = enlargement;
                      minArea = area < minArea ? area : minArea;
                      targetNode = child;

                  } else if (enlargement === minEnlargement) {
                      // otherwise choose one with the smallest area
                      if (area < minArea) {
                          minArea = area;
                          targetNode = child;
                      }
                  }
              }

              node = targetNode || node.children[0];
          }

          return node;
      },

      _insert: function (item, level, isNode) {

          var toBBox = this.toBBox,
              bbox = isNode ? item : toBBox(item),
              insertPath = [];

          // find the best node for accommodating the item, saving all nodes along the path too
          var node = this._chooseSubtree(bbox, this.data, level, insertPath);

          // put the item into the node
          node.children.push(item);
          extend$1(node, bbox);

          // split on node overflow; propagate upwards if necessary
          while (level >= 0) {
              if (insertPath[level].children.length > this._maxEntries) {
                  this._split(insertPath, level);
                  level--;
              } else break;
          }

          // adjust bboxes along the insertion path
          this._adjustParentBBoxes(bbox, insertPath, level);
      },

      // split overflowed node into two
      _split: function (insertPath, level) {

          var node = insertPath[level],
              M = node.children.length,
              m = this._minEntries;

          this._chooseSplitAxis(node, m, M);

          var splitIndex = this._chooseSplitIndex(node, m, M);

          var newNode = createNode$1(node.children.splice(splitIndex, node.children.length - splitIndex));
          newNode.height = node.height;
          newNode.leaf = node.leaf;

          calcBBox(node, this.toBBox);
          calcBBox(newNode, this.toBBox);

          if (level) insertPath[level - 1].children.push(newNode);
          else this._splitRoot(node, newNode);
      },

      _splitRoot: function (node, newNode) {
          // split root node
          this.data = createNode$1([node, newNode]);
          this.data.height = node.height + 1;
          this.data.leaf = false;
          calcBBox(this.data, this.toBBox);
      },

      _chooseSplitIndex: function (node, m, M) {

          var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

          minOverlap = minArea = Infinity;

          for (i = m; i <= M - m; i++) {
              bbox1 = distBBox(node, 0, i, this.toBBox);
              bbox2 = distBBox(node, i, M, this.toBBox);

              overlap = intersectionArea(bbox1, bbox2);
              area = bboxArea(bbox1) + bboxArea(bbox2);

              // choose distribution with minimum overlap
              if (overlap < minOverlap) {
                  minOverlap = overlap;
                  index = i;

                  minArea = area < minArea ? area : minArea;

              } else if (overlap === minOverlap) {
                  // otherwise choose distribution with minimum area
                  if (area < minArea) {
                      minArea = area;
                      index = i;
                  }
              }
          }

          return index;
      },

      // sorts node children by the best axis for split
      _chooseSplitAxis: function (node, m, M) {

          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
              compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
              xMargin = this._allDistMargin(node, m, M, compareMinX),
              yMargin = this._allDistMargin(node, m, M, compareMinY);

          // if total distributions margin value is minimal for x, sort by minX,
          // otherwise it's already sorted by minY
          if (xMargin < yMargin) node.children.sort(compareMinX);
      },

      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin: function (node, m, M, compare) {

          node.children.sort(compare);

          var toBBox = this.toBBox,
              leftBBox = distBBox(node, 0, m, toBBox),
              rightBBox = distBBox(node, M - m, M, toBBox),
              margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
              i, child;

          for (i = m; i < M - m; i++) {
              child = node.children[i];
              extend$1(leftBBox, node.leaf ? toBBox(child) : child);
              margin += bboxMargin(leftBBox);
          }

          for (i = M - m - 1; i >= m; i--) {
              child = node.children[i];
              extend$1(rightBBox, node.leaf ? toBBox(child) : child);
              margin += bboxMargin(rightBBox);
          }

          return margin;
      },

      _adjustParentBBoxes: function (bbox, path, level) {
          // adjust bboxes along the given tree path
          for (var i = level; i >= 0; i--) {
              extend$1(path[i], bbox);
          }
      },

      _condense: function (path) {
          // go through the path, removing empty nodes and updating bboxes
          for (var i = path.length - 1, siblings; i >= 0; i--) {
              if (path[i].children.length === 0) {
                  if (i > 0) {
                      siblings = path[i - 1].children;
                      siblings.splice(siblings.indexOf(path[i]), 1);

                  } else this.clear();

              } else calcBBox(path[i], this.toBBox);
          }
      },

      _initFormat: function (format) {
          // data format (minX, minY, maxX, maxY accessors)

          // uses eval-type function compilation instead of just accepting a toBBox function
          // because the algorithms are very sensitive to sorting functions performance,
          // so they should be dead simple and without inner calls

          var compareArr = ['return a', ' - b', ';'];

          this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
          this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

          this.toBBox = new Function('a',
              'return {minX: a' + format[0] +
              ', minY: a' + format[1] +
              ', maxX: a' + format[2] +
              ', maxY: a' + format[3] + '};');
      }
  };

  function findItem(item, items, equalsFn) {
      if (!equalsFn) return items.indexOf(item);

      for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) return i;
      }
      return -1;
  }

  // calculate node's bbox from bboxes of its children
  function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
  }

  // min bounding rectangle of node children from k to p-1
  function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) destNode = createNode$1(null);
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;

      for (var i = k, child; i < p; i++) {
          child = node.children[i];
          extend$1(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
  }

  function extend$1(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
  }

  function compareNodeMinX(a, b) { return a.minX - b.minX; }
  function compareNodeMinY(a, b) { return a.minY - b.minY; }

  function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
  function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

  function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
             (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
  }

  function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX),
          minY = Math.max(a.minY, b.minY),
          maxX = Math.min(a.maxX, b.maxX),
          maxY = Math.min(a.maxY, b.maxY);

      return Math.max(0, maxX - minX) *
             Math.max(0, maxY - minY);
  }

  function contains(a, b) {
      return a.minX <= b.minX &&
             a.minY <= b.minY &&
             b.maxX <= a.maxX &&
             b.maxY <= a.maxY;
  }

  function intersects(a, b) {
      return b.minX <= a.maxX &&
             b.minY <= a.maxY &&
             b.maxX >= a.minX &&
             b.maxY >= a.minY;
  }

  function createNode$1(children) {
      return {
          children: children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
      };
  }

  // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
  // combines selection algorithm with binary divide & conquer approach

  function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right],
          mid;

      while (stack.length) {
          right = stack.pop();
          left = stack.pop();

          if (right - left <= n) continue;

          mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);

          stack.push(left, mid, mid, right);
      }
  }
  rbush_1.default = default_1;

  var SceneGraphNodeBase =
  /*#__PURE__*/
  function () {
    /**
     * Create a SceneGraphNode.
     * Constructor uses ES6 destructuring of parameters from an object.
     * e.g. new SceneGraphNode({param: .., param2, etc.})
     *
     * @param {Object} params - having the following properties:
     * @param {Array} tags - an label or slug
     * @param {Object} parent - the parent node
     * @param {Object} bounds - local Canvas bounds, relative to our parent.
     * This is not the same as DOM bounds of the canvas element!
     * @param {Number} rotation - degrees, default 0.
     */
    function SceneGraphNodeBase(_ref) {
      var parent = _ref.parent,
          bounds = _ref.bounds,
          _ref$rotation = _ref.rotation,
          rotation = _ref$rotation === void 0 ? 0 : _ref$rotation,
          _ref$tags = _ref.tags,
          tags = _ref$tags === void 0 ? [] : _ref$tags;

      _classCallCheck(this, SceneGraphNodeBase);

      this.parent = parent;
      this._rotation = rotation;
      this._tags = tags;
      this.bounds = bounds;
      this._children = []; // note: subclasses implement own children data structure

      this.locMap = rbush_1();
      this._visble = [];
    }
    /* getters and setters */

    /* define getters for our properties; note subclasses can override setters,
      e.g. to perform layout or calculations based on new state */

    /* getters */

    /**
     * Children scene graph nodes
     * @returns {Array|*} any child nodes this node has
     */


    _createClass(SceneGraphNodeBase, [{
      key: "translatePointToGlobal",

      /* public methods */

      /**
       * Translate coordinates to canvas space. When an element wants to draw on
       * canvas, it requires translating into global coordinates for the canvas.
       *
       * @param {Object} params - object with following properties:
       * @param {Number} x - x location
       * @param {Number} y - y location
       * @returns {Object} - { x, y } x,y location in global terms
       */
      value: function translatePointToGlobal(_ref2) {
        var x = _ref2.x,
            y = _ref2.y;
        var gb = this.canvasBounds;
        return {
          x: x + gb.left,
          y: y + gb.top
        };
      }
      /**
       * Adds a child node to the _children array
       * and changes child node's parent to this node
       *
       * @param {object} node - SceneGraphNode derived item to insert as a child
       **/

    }, {
      key: "addChild",
      value: function addChild(node) {
        if (node.parent) {
          node.parent.removeChild(node);
        }

        node.parent = this;
        if (this._children.indexOf(node) === -1) this._children.push(node);
      }
      /**
       * Removes a child node from the _children array
       * and changes child node's parent to undefined
       *
       * @param {object} node - SceneGraphNode derived node to remove
       **/

    }, {
      key: "removeChild",
      value: function removeChild(node) {
        var index = this._children.indexOf(node);

        if (index > -1) {
          this._children.splice(index, 1);
        }

        node.parent = null;
      }
      /**
       * Traverse children and call their draw on the provided context
       *
       * @param {object} ctx - canvas context
       */

    }, {
      key: "draw",
      value: function draw(ctx) {
        this.children.forEach(function (child) {
          return child.draw(ctx);
        });
      }
    }, {
      key: "children",
      get: function get() {
        return this._children;
      }
      /**
       * Local bounds
       * @returns {*} local bounds
       */
      ,

      /* setters */

      /**
       * Child scene graph nodes
       * @param {Array|*} b
       */
      set: function set(b) {
        this._children = b;
      }
      /**
       * Nodes local bounds
       * @param b - bounds object
       */

    }, {
      key: "bounds",
      get: function get() {
        return this._bounds;
      }
      /**
       *  Rotation applied on this and subsequent children
       * @returns {*} rotation
       */
      ,
      set: function set(b) {
        this._bounds = b;
      }
      /**
       * Rotation
       * @param {number} degrees - rotation in degrees
       */

    }, {
      key: "rotation",
      get: function get() {
        return this._rotation;
      }
      /**
       * Info tags
       * @returns {*} tags
       */
      ,
      set: function set(degrees) {
        this._rotation = degrees;
      }
      /**
       * Tags
       * @param {array} tags - object's descriptive tags
       */

    }, {
      key: "tags",
      get: function get() {
        return this._tags;
      }
      /**
       * Traverse all parents bounds to calculate self Bounds on Canvas.
       * @returns {Object} - Bounds instance
       */
      ,
      set: function set(tags) {
        this._tags = tags;
      }
    }, {
      key: "canvasBounds",
      get: function get() {
        if (!this.parent) return this.bounds;
        var gb = this.parent.canvasBounds;
        return new Bounds({
          top: this.bounds.top + gb.top,
          bottom: this.bounds.bottom + gb.top,
          left: this.bounds.left + gb.left,
          right: this.bounds.right + gb.left,
          width: this.bounds.width,
          height: this.bounds.height
        });
      }
      /**
       * Use rbush to return children nodes that may be visible.
       * At this level, it is assumed that there is no viewport
       * constraints to the filter.
       *
       *  @return {Array} - array of rbush nodes
       */

    }, {
      key: "visible",
      get: function get() {
        var vis = [];
        var childVisible = this.children.map(function (child) {
          return child.locMap.all();
        });
        childVisible.forEach(function (item) {
          vis = vis.concat(item);
        });
        return vis;
      }
      /**
       *  Traverse children, returning hitmap
       *  @returns {Array} - array of rbush entries
       */

    }, {
      key: "hitMap",
      get: function get() {
        var hits = [];
        var childMap = this.children.map(function (child) {
          return child.hitMap;
        });
        childMap.forEach(function (item) {
          hits = hits.concat(item);
        });
        return hits;
      }
    }]);

    return SceneGraphNodeBase;
  }();

  var SceneGraphNodeCanvas =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(SceneGraphNodeCanvas, _SceneGraphNodeBase);

    /**
     * constructor
     * @param model - data model for canvas
     * @param appState - app state model
     */
    function SceneGraphNodeCanvas(_ref) {
      var _this;

      var model = _ref.model,
          appState = _ref.appState,
          sub = _ref.sub;

      _classCallCheck(this, SceneGraphNodeCanvas);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SceneGraphNodeCanvas).call(this, {}));
      _this.model = model;
      _this.appState = appState;
      _this.verticalScale = 1;
      _this.info = {
        visible: false,
        top: 0,
        left: 0
      };
      _this.onChanges = [sub];
      return _this;
    }
    /**
     * Getter if canvas has focus
     * @returns {boolean}
     */


    _createClass(SceneGraphNodeCanvas, [{
      key: "inform",

      /**
       *  informs parent context that canvas has updated property
       */
      value: function inform() {
        this.onChanges.forEach(function (callBack) {
          return callBack();
        });
      }
    }, {
      key: "setCanvas",
      value: function setCanvas(cvs) {
        this.canvas = cvs;
        this.context2d = cvs.getContext('2d');
        this.dirty = true; //this.drawLazily(this.domBounds);
      }
    }, {
      key: "setDomBounds",
      value: function setDomBounds(bounds) {
        this.domBounds = bounds;
      } //view() {
      //  // store these bounds, for checking in drawLazily()
      //  if (this.domBounds && !this.domBounds.isEmptyArea) {
      //    this.lastDrawnMithrilBounds = this.domBounds;
      //  }
      //  let b = this.domBounds || {};
      //  let selectedClass = this.selected ? 'selected' : '';
      //  return m('canvas', {
      //    class: `cmap-canvas cmap-biomap ${selectedClass}`,
      //    style: `left: ${b.left}px; top: ${b.top}px;
      //             width: ${b.width}px; height: ${b.height}px;
      //             transform: rotate(${this.rotation}deg);`,
      //    width: b.width,
      //    height: b.height
      //  });
      //}

      /**
       * draw our scene graph children on canvas element
       */

    }, {
      key: "draw",
      value: function draw() {
        var ctx = this.context2d;
        if (!ctx) return;
        if (!this.domBounds) return;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.save(); //ctx.translate(0.5, 0.5); // prevent subpixel rendering of 1px lines

        this.visible.map(function (child) {
          child && child.data.draw(ctx);
        });
        ctx.restore(); // store these bounds, for checking in drawLazily()

        this.lastDrawnCanvasBounds = this.bounds;
        this.inform(); //this.dirty = false;
      }
      /**
       * lazily draw on the canvas, because (p)react updates the dom asynchronously.
       * The canvas will be cleared when the width and height are changed.
       * So we cannot draw upon the canvas until after that.
       */

    }, {
      key: "drawLazily",
      value: function drawLazily(wantedBounds) {
        var _this2 = this;

        if (wantedBounds.area === 0) return;
        if (this._drawLazilyTimeoutId) clearTimeout(this._drawLazilyTimeoutId);

        if (!Bounds.areaEquals(this.lastDrawnBounds, wantedBounds)) {
          var tid1 = this._drawLazilyTimeoutId = setTimeout(function () {
            if (tid1 !== _this2._drawLazilyTimeoutId) return;

            _this2.drawLazily(wantedBounds);
          });
        } else {
          console.log('scheduling lazy draw for: ', wantedBounds.width, wantedBounds.height);
          var tid2 = this._drawLazilyTimeoutId = setTimeout(function () {
            if (tid2 !== _this2._drawLazilyTimeoutId) return;

            if (!Bounds.areaEquals(_this2.lastDrawnCanvasBounds, wantedBounds)) {
              _this2.draw();
            }
          });
        }
      }
    }, {
      key: "selected",
      get: function get() {
        return this.appState.selection.bioMaps.indexOf(this) !== -1;
      }
    }]);

    return SceneGraphNodeCanvas;
  }(SceneGraphNodeBase);

  var SceneGraphNodeGroup =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(SceneGraphNodeGroup, _SceneGraphNodeBase);

    /**
     * constructor
     * @param params
     */
    function SceneGraphNodeGroup(params) {
      _classCallCheck(this, SceneGraphNodeGroup);

      return _possibleConstructorReturn(this, _getPrototypeOf(SceneGraphNodeGroup).call(this, params));
    }
    /**
     * Return visible children elements
     * @returns {Array}
     */


    _createClass(SceneGraphNodeGroup, [{
      key: "visible",
      get: function get() {
        var vis = [];
        var cVis = this.children.map(function (child) {
          return child.visible;
        });
        cVis.forEach(function (item) {
          vis = vis.concat(item);
        });
        return vis;
      }
    }]);

    return SceneGraphNodeGroup;
  }(SceneGraphNodeBase);

  var SceneGraphNodeTrack =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(SceneGraphNodeTrack, _SceneGraphNodeBase);

    /**
     * Constructor
     * @param params
     */
    function SceneGraphNodeTrack(params) {
      _classCallCheck(this, SceneGraphNodeTrack);

      return _possibleConstructorReturn(this, _getPrototypeOf(SceneGraphNodeTrack).call(this, params));
    }

    return SceneGraphNodeTrack;
  }(SceneGraphNodeBase);

  /**
   * @file Helper functions for calculating canvas points.
   */

  /**
   * Takes a point on a map and translates it from the newScale to the baseScale scale
   * @param point - Map point in terms of new scale
   * @param baseScale - largest and smallest possible values of the scale
   * @param newScale - largest and smallest values of the adjusted scale
   * @param {boolean} invert - is the scale to be drawn "flipped"
   * @returns {number} point converted from location on new scale to location on base scale
   */
  function translateScale(point, baseScale, newScale, invert) {
    var loc = (baseScale.stop - baseScale.start) * (point - newScale.start) / (newScale.stop - newScale.start) + baseScale.start - baseScale.start;

    if (invert) {
      loc = baseScale.start + baseScale.stop - loc;
    }

    return loc;
  }
  function remToPix(rem) {
    return rem * parseFloat(getComputedStyle(document.getElementById('cmap-app')).fontSize);
  }

  var Ruler =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(Ruler, _SceneGraphNodeBase);

    /**
     * Constructor
     * @param parent - parent scene graph node
     * @param bioMap - map data
     * @param config - ruler configuration object
     */
    function Ruler(_ref) {
      var _this;

      var parent = _ref.parent,
          bioMap = _ref.bioMap,
          config = _ref.config;

      _classCallCheck(this, Ruler);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Ruler).call(this, {
        parent: parent
      }));
      _this.config = config;
      _this.mapCoordinates = bioMap.view;
      _this.offset = _this.mapCoordinates.base.start * -1;
      _this.pixelScaleFactor = _this.mapCoordinates.pixelScaleFactor;
      _this.invert = _this.mapCoordinates.invert;
      _this.fillColor = config.fillColor;
      _this.textFace = config.labelFace;
      _this.textSize = config.labelSize;
      _this.textColor = config.labelColor;
      _this.rulerPrecision = config.precision;
      _this.rulerWidth = config.width;
      _this.rulerPadding = config.padding;
      _this.innerSize = config.innerLineWeight;
      _this.innerColor = config.innerLineColor;
      var b = _this.parent.backbone.bounds;
      var leftloc;

      if (config.position < 0) {
        leftloc = b.left - config.width - config.padding - config.lineWeight; //arbitrary spacing to look goo
      } else {
        leftloc = b.right + config.width + config.padding + config.lineWeight; //arbitrary spacing to look goo
      }

      _this.bounds = new Bounds({
        allowSubpixel: false,
        top: 0,
        left: leftloc,
        //arbitrary spacing to look goo
        width: config.width,
        height: b.height
      });
      return _this;
    }
    /**
     * Draw ruler and zoom bar
     * @param ctx - linked canvas2D context
     */


    _createClass(Ruler, [{
      key: "draw",
      value: function draw(ctx) {
        var config = this.config;
        var vStart = this.invert ? this.mapCoordinates.visible.stop : this.mapCoordinates.visible.start;
        var vStop = this.invert ? this.mapCoordinates.visible.start : this.mapCoordinates.visible.stop;
        var start = translateScale(vStart, this.mapCoordinates.base, this.mapCoordinates.base, this.invert) * this.pixelScaleFactor;
        var stop = translateScale(vStop, this.mapCoordinates.base, this.mapCoordinates.base, this.invert) * this.pixelScaleFactor;
        var text;

        if (config.side === 'left') {
          text = [this.mapCoordinates.base.start.toFixed(config.precision), this.mapCoordinates.base.stop.toFixed(config.precision)];
        } else {
          text = [this.mapCoordinates.visible.start.toFixed(config.precision), this.mapCoordinates.visible.stop.toFixed(config.precision)];
        }

        this.textWidth = ctx.measureText(text[0]).width > ctx.measureText(text[1]).width ? ctx.measureText(text[0]).width : ctx.measureText(text[1]).width;
        var gb = this.canvasBounds || {}; // draw baseline labels

        ctx.font = "".concat(config.labelSize, "px ").concat(config.labelFace);
        ctx.fillStyle = config.labelColor;
        ctx.textAlign = 'left';

        if (this.invert) {
          ctx.fillText(text[1], gb.left - ctx.measureText(text[1]).width - gb.width / 2, Math.floor(gb.top - config.labelSize / 2));
          ctx.fillText(text[0], gb.left - ctx.measureText(text[0]).width - gb.width / 2, Math.floor(gb.bottom + config.labelSize + 2));
        } else {
          ctx.fillText(text[0], gb.left - ctx.measureText(text[0]).width - gb.width / 2, Math.floor(gb.top - config.labelSize / 2));
          ctx.fillText(text[1], gb.left - ctx.measureText(text[1]).width - gb.width / 2, Math.floor(gb.bottom + config.labelSize + 2));
        } // Draw zoom position labels


        if (config.side === 'left') {
          text = [this.mapCoordinates.visible.start.toFixed(config.precision), this.mapCoordinates.visible.stop.toFixed(config.precision)];
        } else {
          text = [this.mapCoordinates.base.start.toFixed(config.precision), this.mapCoordinates.base.stop.toFixed(config.precision)];
        }

        if (this.invert) {
          ctx.fillText(text[1], gb.left + config.width + config.padding, Math.floor(gb.top - config.labelSize / 2));
          ctx.fillText(text[0], gb.left + config.width + config.padding, gb.bottom + config.labelSize + 2);
        } else {
          ctx.fillText(text[0], gb.left + config.width + config.padding, Math.floor(gb.top - config.labelSize / 2));
          ctx.fillText(text[1], gb.left + config.width + config.padding, gb.bottom + config.labelSize + 2);
        } //Draw baseline ruler


        ctx.beginPath();
        ctx.lineWidth = config.innerLineWeight;
        ctx.strokeStyle = config.innerLineColor; // noinspection JSSuspiciousNameCombination

        ctx.moveTo(Math.floor(gb.left + gb.width / 2), Math.floor(gb.top)); // noinspection JSSuspiciousNameCombination

        ctx.lineTo(Math.floor(gb.left + gb.width / 2), Math.floor(gb.bottom));
        ctx.stroke(); // Draw "zoom box"

        ctx.fillStyle = config.fillColor; //'aqua';

        var height = stop - start > 1 ? stop - start : 1.0; // noinspection JSSuspiciousNameCombination

        ctx.fillRect(Math.floor(gb.left), Math.floor(start + gb.top), Math.floor(gb.width), Math.floor(height)); //draw border if asked for

        if (config.lineWeight > 0) {
          ctx.strokeStyle = config.lineColor;
          ctx.lineWidth = config.lineWeight;
          ctx.strokeRect(Math.floor(gb.left), Math.floor(start + gb.top), Math.floor(gb.width), Math.floor(height));
        } ////debugging rectangle to test group bounds
        //ctx.fillStyle = 'red';
        //ctx.fillRect(
        //  Math.floor(gb.left),
        //  Math.floor(gb.top),
        //  Math.floor(gb.width),
        //  Math.floor(gb.height)
        //);


        this.children.forEach(function (child) {
          return child.draw(ctx);
        });
      }
      /**
       * Return the ruler as data for an scenegraph visibility check. (Ruler by definition is
       * always visible, and does own logic for the position bar)
       * @returns {{data: Ruler}}
       */

    }, {
      key: "visible",
      get: function get() {
        return {
          data: this
        };
      }
    }]);

    return Ruler;
  }(SceneGraphNodeBase);

  var FeatureMark =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(FeatureMark, _SceneGraphNodeBase);

    /**
     * Constructor
     * @param parent - parent scene graph node
     * @param bioMap - map data
     * @param featureModel - feature data
     */
    function FeatureMark(_ref) {
      var _this;

      var parent = _ref.parent,
          bioMap = _ref.bioMap,
          featureModel = _ref.featureModel,
          config = _ref.config;

      _classCallCheck(this, FeatureMark);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FeatureMark).call(this, {
        parent: parent,
        tags: [featureModel.name]
      }));
      _this.model = featureModel;
      _this.featureMap = bioMap;
      _this.config = config;
      _this.offset = _this.featureMap.view.base.start * -1;
      _this.invert = _this.featureMap.view.invert;
      _this.start = _this.model.coordinates.start;
      _this.pixelScaleFactor = _this.featureMap.view.pixelScaleFactor;
      _this.bounds = new Bounds({
        allowSubpixel: false,
        top: 0,
        left: 0,
        width: parent.bounds.width,
        height: config.lineWeight
      });
      return _this;
    }
    /**
     * Draw the marker
     * @param ctx - active canvas2D context
     */


    _createClass(FeatureMark, [{
      key: "draw",
      value: function draw(ctx) {
        var config = this.config;
        var y = translateScale(this.start, this.featureMap.view.base, this.featureMap.view.visible, this.invert) * this.pixelScaleFactor;
        this.bounds.translate(0, y - this.bounds.top);
        var gb = this.canvasBounds || {};
        ctx.beginPath();
        ctx.strokeStyle = config.lineColor;
        ctx.lineWidth = config.lineWeight; // noinspection JSSuspiciousNameCombination

        ctx.moveTo(Math.floor(gb.left), Math.floor(gb.top)); // noinspection JSSuspiciousNameCombination

        ctx.lineTo(Math.floor(gb.right), Math.floor(gb.top));
        ctx.stroke(); // reset bounding box to fit the new stroke location/width
        // lineWidth adds equal percent of passed width above and below path
        //this.bounds.translate(0,-config.lineWeight/2);
      }
    }]);

    return FeatureMark;
  }(SceneGraphNodeBase);

  var MapBackbone =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(MapBackbone, _SceneGraphNodeBase);

    /**
     * Constructor
     * @param parent - Parent scene graph node
     * @param bioMap - Map data
     */
    function MapBackbone(_ref) {
      var _this;

      var parent = _ref.parent,
          bioMap = _ref.bioMap,
          config = _ref.config;

      _classCallCheck(this, MapBackbone);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MapBackbone).call(this, {
        parent: parent
      }));
      _this.config = config;
      var b = parent.bounds;
      var backboneWidth = config.width;
      _this.bounds = new Bounds({
        allowSubpixel: false,
        top: 0,
        left: b.width * 0.5 - backboneWidth * 0.5,
        width: backboneWidth + config.lineWeight,
        height: b.height
      });
      bioMap.view.backbone = _this.canvasBounds;
      return _this;
    }
    /**
     * Draw the map backbone, then iterate through and draw its children
     * @param ctx - currently active canvas2D context
     */


    _createClass(MapBackbone, [{
      key: "draw",
      value: function draw(ctx) {
        var config = this.config;
        var gb = this.canvasBounds || {};
        ctx.fillStyle = config.fillColor; // noinspection JSSuspiciousNameCombination
        // noinspection JSSuspiciousNameCombination

        ctx.fillRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(gb.width), Math.floor(gb.height));

        if (this.lineWidth > 0) {
          ctx.strokeStyle = config.lineColor;
          ctx.lineWidth = config.lineWeight;
          ctx.strokeRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(gb.width), Math.floor(gb.height));
        }

        this.children.forEach(function (child) {
          return child.draw(ctx);
        });
      }
    }]);

    return MapBackbone;
  }(SceneGraphNodeBase);

  var Dot =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(Dot, _SceneGraphNodeBase);

    /**
     * Constructor
     *
     * @param parent - parent scene graph node
     * @param bioMap - map data
     * @param featureModel - feature data
     * @param config - configuration information object
     */
    function Dot(_ref) {
      var _this;

      var parent = _ref.parent,
          bioMap = _ref.bioMap,
          featureModel = _ref.featureModel,
          config = _ref.config;

      _classCallCheck(this, Dot);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Dot).call(this, {
        parent: parent,
        tags: [featureModel.name]
      })); //setup config

      _this.config = config;
      _this.model = featureModel;
      _this.view = bioMap.view;
      _this.pixelScaleFactor = _this.view.pixelScaleFactor;
      _this.invert = bioMap.view.invert;
      _this.start = _this.model.coordinates.start;
      _this.radius = config.width;
      _this.depth = 0; // setup initial placement

      if (_this.model.coordinates.depth) {
        _this.depth = translateScale(_this.model.coordinates.depth, {
          start: 0,
          stop: config.displayWidth
        }, config.view, false);
      }

      _this.bounds = new Bounds({
        top: 0,
        left: 0,
        width: 2 * _this.radius,
        //this.fontSize*(this.model.name.length),
        height: 2 * _this.radius,
        allowSubpixel: false
      });
      return _this;
    }
    /**
     * Draw label on cmap canvas context
     * @param ctx
     */


    _createClass(Dot, [{
      key: "draw",
      value: function draw(ctx) {
        //Setup a base offset based on parent track
        if (this.start < this.view.visible.start || this.start > this.view.visible.stop) return;

        if (!this.offset) {
          var left = this.canvasBounds.left;
          var top = this.canvasBounds.top;
          this.offset = {
            top: top,
            left: left
          };
        }

        var config = this.config;
        var y = translateScale(this.start, this.view.base, this.view.visible, this.invert) * this.pixelScaleFactor;
        var x = this.depth; // Draw dot

        ctx.beginPath();
        ctx.fillStyle = config.fillColor;
        ctx.arc(x + this.offset.left, y + this.offset.top, this.radius, 0, 2 * Math.PI, false);
        ctx.fill();
        ctx.lineWidth = config.lineWeight;
        ctx.strokeStyle = config.lineColor;
        ctx.stroke(); //update bounding box

        this.bounds.translate(x - this.radius - this.bounds.left, y - this.radius - this.bounds.top);
      }
    }]);

    return Dot;
  }(SceneGraphNodeBase);

  var manhattanRuler =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(manhattanRuler, _SceneGraphNodeBase);

    /**
     * Construct the QTL feature
     * @param parent - parent scene graph node
     * @param bioMap - map data
     * @param featureModel - feature data
     * @param initialConfig - configuration object for display variables
     */
    function manhattanRuler(_ref) {
      var _this;

      var parent = _ref.parent,
          featureModel = _ref.featureModel,
          config = _ref.config;

      _classCallCheck(this, manhattanRuler);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(manhattanRuler).call(this, {
        parent: parent
      }));
      _this.config = config;
      _this.manhattanPlot = featureModel;
      _this.bounds = new Bounds({
        allowSubpixel: false,
        top: 0,
        left: 0,
        width: config.displayWidth,
        height: _this.parent.bounds.height
      });
      return _this;
    }
    /**
     *
     * @param ctx
     */


    _createClass(manhattanRuler, [{
      key: "draw",
      value: function draw(ctx) {
        var _this2 = this;

        var config = this.config;
        ctx.save();
        ctx.globalAlpha = .5;
        var cb = this.canvasBounds;
        var depth = 0;

        if (this.manhattanPlot) {
          //Draw "ruler"
          ctx.strokeStyle = config.rulerColor;
          ctx.lineWidth = config.rulerWeight; //Baseline marks

          ctx.beginPath();
          ctx.moveTo(cb.left, cb.top);
          ctx.lineTo(cb.right, cb.top);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cb.left, cb.bottom);
          ctx.lineTo(cb.right, cb.bottom);
          ctx.stroke(); //Ruler

          for (var i = 0; i <= this.manhattanPlot.view.stop; i++) {
            if (i % config.rulerMinorMark === 0 || i % config.rulerMajorMark === 0) {
              depth = translateScale(i, {
                start: 0,
                stop: config.displayWidth
              }, this.manhattanPlot.view, false);
              ctx.beginPath();
              ctx.moveTo(cb.left + depth, cb.top);
              ctx.lineTo(cb.left + depth, cb.top - 10);
              ctx.stroke();

              if (i % config.rulerMajorMark === 0) {
                ctx.font = config.labelSize;
                ctx.fillStyle = config.labelColor;
                ctx.textAlign = 'center';
                ctx.fillText(String(i), cb.left + depth, cb.top - 11);
              }
            }
          }

          ctx.fillText('-log10(p)', cb.left + config.displayWidth / 2, cb.top - 25); // Reference lines

          if (this.manhattanPlot.lines) {
            this.manhattanPlot.lines.forEach(function (line) {
              depth = translateScale(line.value, {
                start: 0,
                stop: config.displayWidth
              }, _this2.manhattanPlot.view, false);
              ctx.strokeStyle = line.lineColor;
              ctx.lineWidth = line.lineWeight;
              ctx.beginPath();
              ctx.moveTo(cb.left + depth, cb.top);
              ctx.lineTo(cb.left + depth, cb.bottom);
              ctx.stroke();
            });
          }
        }

        ctx.restore();
        this.children.forEach(function (child) {
          return child.draw(ctx);
        });
      }
    }]);

    return manhattanRuler;
  }(SceneGraphNodeBase);

  var ManhattanPlot =
  /*#__PURE__*/
  function (_SceneGraphNodeTrack) {
    _inherits(ManhattanPlot, _SceneGraphNodeTrack);

    /**
     * Constructor - sets up a track that's a group of QTL rectangles
     * @param params
     */
    function ManhattanPlot(params) {
      var _this;

      _classCallCheck(this, ManhattanPlot);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ManhattanPlot).call(this, params));
      var manhattanPlot = params.config;
      var b = _this.parent.bounds;
      _this.trackPos = params.position || 1;
      _this.bounds = new Bounds({
        allowSubpixel: false,
        top: 0,
        left: 0,
        width: 0,
        height: b.height
      });

      if (manhattanPlot !== null) {
        var manhattanInfo = manhattanPlot; //merge configuration information with default config

        for (var key in _this.parent.model.config.manhattan) {
          if (!manhattanInfo.hasOwnProperty(key)) {
            manhattanInfo[key] = _this.parent.model.config.manhattan[key];
          }
        }

        manhattanInfo.lines.forEach(function (line) {
          if (!line.lineWeight) {
            line.lineWeigth = manhattanInfo.featureLineWeight;
          }

          if (!line.lineColor) {
            line.lineColor = manhattanInfo.featureLineColor;
          }
        }); // If data hasn't been attached to this map to plot, filter and attach it.

        if (manhattanInfo.data === undefined) {
          manhattanInfo.view = {
            start: 0,
            stop: manhattanInfo.maxValue || 0
          };

          var baseData = _this.parent.sources.filter(function (model) {
            return model.id === manhattanInfo.dataId;
          });

          var prefix = manhattanInfo.prefix || '';
          manhattanInfo.data = baseData[0].parseResult.data.filter(function (mdata) {
            if (prefix + mdata[manhattanInfo.targetField] === _this.parent.model.name) {
              if (manhattanInfo.max === undefined && -Math.log10(mdata[manhattanInfo.pField]) >= manhattanInfo.view.stop) {
                //determine max value while filtering data
                manhattanInfo.view.stop = Math.ceil(-Math.log10(mdata[manhattanInfo.pField]));
              }

              return true;
            }

            return false;
          });
        } //Draw manhattan plot
        //let left = this.parent.bbGroup.bounds.right;


        _this.bounds = new Bounds({
          allowSubpixel: false,
          top: 0,
          left: 0,
          width: manhattanInfo.displayWidth || 0,
          height: b.height
        });
        var fmData = [];
        var locData = [];
        _this.fmData = fmData;
        _this.manhattanMarks = manhattanInfo.data.map(function (model) {
          model.coordinates = {
            start: model[manhattanInfo.posField],
            depth: -Math.log10(model[manhattanInfo.pField])
          };

          if (model.coordinates.start > _this.parent.model.view.base.stop || model.coordinates.start < _this.parent.model.view.base.start) {
            return;
          }

          var fm = new Dot({
            featureModel: model,
            parent: _assertThisInitialized(_assertThisInitialized(_this)),
            bioMap: _this.parent.model,
            config: manhattanInfo
          });
          fmData.push(fm);
          var loc = {
            minY: model.coordinates.start,
            maxY: model.coordinates.start,
            minX: fm.canvasBounds.left,
            maxX: fm.canvasBounds.right,
            data: fm
          };
          locData.push(loc);
          return fm;
        });
        _this.ruler = {
          minY: 0,
          maxY: 100000000,
          minX: _this.canvasBounds.left,
          maxX: _this.canvasBounds.right,
          data: new manhattanRuler({
            featureModel: manhattanInfo,
            parent: _assertThisInitialized(_assertThisInitialized(_this)),
            config: manhattanInfo
          })
        };

        _this.locMap.load(locData);

        _this.tags = ['manhattan'];
      }

      return _this;
    }
    /**
     *
     */


    _createClass(ManhattanPlot, [{
      key: "draw",
      // /**
      //  * Debug draw to check track positioning
      //  * @param ctx
      //  */
      value: function draw(ctx) {
        // ctx.save();
        // ctx.globalAlpha = .5;
        // ctx.fillStyle = 'green';
        // let cb = this.canvasBounds;
        // ctx.fillRect(cb.left,cb.top,cb.width,cb.height);
        // ctx.restore();
        this.children.forEach(function (child) {
          return child.draw(ctx);
        });
      } // /**
      //  * Get RTree children that are visible in the canvas' current zoom bounds
      //   * @returns {Array}
      //   */
      //

    }, {
      key: "visible",
      get: function get() {
        return this.locMap.all().concat(this.ruler);
      }
    }, {
      key: "hitMap",
      get: function get() {
        //return this.locMap.all();
        return this.children.map(function (child) {
          return {
            minY: child.canvasBounds.top,
            maxY: child.canvasBounds.bottom,
            minX: child.canvasBounds.left,
            maxX: child.canvasBounds.right,
            data: child
          };
        });
      }
    }]);

    return ManhattanPlot;
  }(SceneGraphNodeTrack);

  var QTL =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(QTL, _SceneGraphNodeBase);

    /**
     * Construct the QTL feature
     * @param parent - parent scene graph node
     * @param bioMap - map data
     * @param featureModel - feature data
     * @param initialConfig - configuration object for display variables
     */
    function QTL(_ref) {
      var _this;

      var parent = _ref.parent,
          bioMap = _ref.bioMap,
          featureModel = _ref.featureModel,
          initialConfig = _ref.initialConfig,
          config = _ref.config;

      _classCallCheck(this, QTL);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(QTL).call(this, {
        parent: parent,
        tags: [featureModel.name]
      }));
      _this.model = featureModel;
      _this.featureMap = bioMap;
      _this.view = _this.featureMap.view;
      _this.lineWidth = 1.0; //min and max location in pixels

      _this.pixelScaleFactor = _this.featureMap.view.pixelScaleFactor;
      _this.fill = config.fillColor;

      if (initialConfig.fillColor) {
        _this.fill = initialConfig.fillColor[initialConfig.filters.indexOf(_this.model.tags[0])] || initialConfig.fillColor[0];
      }

      _this.width = initialConfig.width || config.width;
      _this.trackSpacing = initialConfig.internalPadding || config.internalPadding;
      _this.offset = _this.trackSpacing;
      _this.invert = _this.view.invert;
      _this.start = _this.invert ? _this.model.coordinates.stop : _this.model.coordinates.start;
      _this.stop = _this.invert ? _this.model.coordinates.start : _this.model.coordinates.stop;

      if (initialConfig.labelStyle !== 'none') {
        _this.labelColor = initialConfig.labelColor || config.labelColor;
        _this.labelSize = initialConfig.labelSize || config.labelSize;
        _this.labelFace = initialConfig.labelFace || config.labelFace;
        if (initialConfig.labelStyle === 'feature') _this.offset += _this.labelSize;
      } // Calculate start/end position, then
      // Iterate across QTLs in group and try to place QTL region where it can
      // minimize stack width in parent group 


      var y1 = translateScale(_this.start, _this.view.base, _this.view.visible, _this.invert) * _this.pixelScaleFactor;

      var y2 = translateScale(_this.stop, _this.view.base, _this.view.visible, _this.invert) * _this.pixelScaleFactor;

      var leftLoc = 0;
      var leftArr;
      leftArr = _this.parent.locMap.search({
        minY: _this.model.coordinates.start,
        maxY: _this.model.coordinates.stop,
        minX: 0,
        maxX: 10000
      });
      leftArr = leftArr.sort(function (a, b) {
        return a.data.bounds.right - b.data.bounds.right;
      });
      var stepOffset = _this.width + _this.offset;
      var stackEnd = leftArr.length;

      for (var i = 0; i <= stackEnd; ++i) {
        leftLoc = i * stepOffset;

        if (leftArr[i] && leftArr[i].data.bounds.left !== leftLoc) {
          break;
        }
      }

      _this.bounds = new Bounds({
        allowSubpixel: false,
        top: y1,
        left: leftLoc,
        width: _this.width,
        height: y2 - y1
      });
      return _this;
    }
    /**
     *
     * @param ctx
     */


    _createClass(QTL, [{
      key: "draw",
      value: function draw(ctx) {
        // Get start and stop of QTL on current region, if it isn't located in
        // current view, don't draw, else cutoff when it gets to end of currently
        // visible region.
        if (this.model.coordinates.stop < this.view.visible.start || this.model.coordinates.start > this.view.visible.stop) return;
        var y1pos = this.model.coordinates.start > this.view.visible.start ? this.model.coordinates.start : this.view.visible.start;
        var y2pos = this.model.coordinates.stop < this.view.visible.stop ? this.model.coordinates.stop : this.view.visible.stop;
        this.start = y1pos;
        this.stop = y2pos;

        if (this.invert) {
          this.start = y2pos;
          this.stop = y1pos;
        }

        var y1 = translateScale(this.start, this.view.base, this.view.visible, this.invert) * this.pixelScaleFactor;
        var y2 = translateScale(this.stop, this.view.base, this.view.visible, this.invert) * this.pixelScaleFactor; //setup bounds and draw

        this.bounds = new Bounds({
          top: y1,
          height: y2 - y1,
          left: this.bounds.left,
          width: this.width
        });
        var gb = this.canvasBounds || {};
        var qtlHeight = gb.height > 1 ? gb.height : 1;
        ctx.fillStyle = this.fill; // noinspection JSSuspiciousNameCombination

        ctx.fillRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(this.width), Math.floor(qtlHeight)); // Draw any children

        this.children.forEach(function (child) {
          return child.draw(ctx);
        });
      }
    }]);

    return QTL;
  }(SceneGraphNodeBase);

  var QtlTrack =
  /*#__PURE__*/
  function (_SceneGraphNodeTrack) {
    _inherits(QtlTrack, _SceneGraphNodeTrack);

    /**
     * Constructor - sets up a track that's a group of QTL rectangles
     * @param params
     */

    /**
     * TODO: Allow for subtracks
     */
    function QtlTrack(params) {
      var _this;

      _classCallCheck(this, QtlTrack);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(QtlTrack).call(this, params));
      _this.filteredFeatures = [];
      var b = _this.parent.bounds;
      var order = _this.parent.children.length;
      var left = order > 0 ? _this.parent.children[_this.parent.children.length - 1].bounds.right : 0;
      _this.bounds = new Bounds({
        allowSubpixel: false,
        top: 0,
        left: left,
        width: _this.parent.model.config.qtl.trackMinWidth,
        height: b.height
      });
      var qtlConf = params.config;

      for (var key in _this.parent.model.config.qtl) {
        if (!qtlConf.hasOwnProperty(key)) {
          qtlConf[key] = _this.parent.model.config.qtl[key];
        }
      }

      var filteredFeatures = [];
      qtlConf.filters.forEach(function (filter, order) {
        var test;
        test = _this.parent.model.features.filter(function (model) {
          return model.tags[0].match(filter) !== null;
        });

        if (test.length === 0) {
          // get rid of any tags that don't actually get used
          qtlConf.filters.splice(order, 1);
        } else {
          filteredFeatures = filteredFeatures.concat(test);
        }
      });
      filteredFeatures = filteredFeatures.sort(function (a, b) {
        return a.coordinates.start - b.coordinates.start;
      });
      var fmData = [];
      var featureGroup = new SceneGraphNodeGroup({
        parent: _assertThisInitialized(_assertThisInitialized(_this))
      });
      featureGroup.bounds = new Bounds({
        allowSubpixel: false,
        top: 0,
        left: 0,
        width: 100,
        height: _this.bounds.height
      });
      _this.maxLoc = 0;
      var featureData = filteredFeatures.map(function (model) {
        var fm = new QTL({
          featureModel: model,
          parent: featureGroup,
          bioMap: _this.parent.model,
          initialConfig: qtlConf,
          config: _this.parent.model.config.qtl
        });
        featureGroup.addChild(fm);
        var loc = {
          minY: model.coordinates.start,
          maxY: model.coordinates.stop,
          minX: fm.canvasBounds.left,
          maxX: fm.canvasBounds.right,
          data: fm
        };
        featureGroup.locMap.insert(loc);

        _this.locMap.insert(loc);

        fmData.push(loc);

        if (fm.canvasBounds.right > _this.canvasBounds.right) {
          _this.bounds.right = fm.canvasBounds.right - _this.canvasBounds.left;
          featureGroup.bounds.right = fm.canvasBounds.right - _this.canvasBounds.left;
          _this.parent.bounds.right += fm.canvasBounds.right - _this.parent.canvasBounds.right;
        }

        return fm;
      });
      _this.featureData = featureData;

      _this.addChild(featureGroup);

      _this.featureGroup = featureGroup;
      _this.model = _this.parent.model;
      _this.labelGroup = label({
        parent: _assertThisInitialized(_assertThisInitialized(_this)),
        config: params.config
      });
      _this.parent.labels = _this.labelGroup;

      if (_this.labelGroup) {
        // chances are the label group is going to break the parent's bounds, so move things as needed.
        _this.addChild(_this.parent.labels);

        var offset = _this.labelGroup.offset || 0;

        if (offset < 0) {
          offset = -offset;
          _this.featureGroup.bounds.left += offset;
          _this.labelGroup.bounds.left += offset;
        }

        _this.featureGroup.bounds.right += offset;
        _this.labelGroup.bounds.right += offset;
        _this.parent.bounds.right += offset; //(this0.parent.canvasBounds.right-featureGroup.canvasBounds.right);

        _this.bounds.right += offset;
      }

      _this.locMap.clear();

      _this.locMap.load(fmData);

      return _this;
    }
    /**
     *
     */


    _createClass(QtlTrack, [{
      key: "draw",

      /**
       * Debug draw to check track positioning
       * @param ctx
       */
      value: function draw(ctx) {
        ctx.save();
        ctx.globalAlpha = .5;
        ctx.fillStyle = '#ADD8E6';
        this.children.forEach(function (child) {
          var cb = child.canvasBounds; // noinspection JSSuspiciousNameCombination
          // noinspection JSSuspiciousNameCombination

          ctx.fillRect(Math.floor(cb.left), Math.floor(cb.top), Math.floor(cb.width), Math.floor(cb.height));
        });
        ctx.restore();
      }
      /**
       * Get RTree children that are visible in the canvas' current zoom bounds
       * @returns {Array}
       */

    }, {
      key: "visible",
      get: function get() {
        // let visible = [];
        // this.children.forEach(child => {
        //   visible = visible.concat(child.locMap.all());
        // });
        //
        // return visible;
        return this.locMap.all(); // return this.locMap.all().concat([{data:this}]); // debugging statement to test track width bounds
      }
    }, {
      key: "hitMap",
      get: function get() {
        //return this.locMap.all();
        return this.featureGroup.children.map(function (child) {
          return {
            minY: child.canvasBounds.top,
            maxY: child.canvasBounds.bottom,
            minX: child.canvasBounds.left,
            maxX: child.canvasBounds.right,
            data: child
          };
        });
      }
    }]);

    return QtlTrack;
  }(SceneGraphNodeTrack);

  var FeatureLabel =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(FeatureLabel, _SceneGraphNodeBase);

    /**
     * Constructor
     *
     * @param parent - parent scene graph node
     * @param bioMap - map data
     * @param featureModel - feature data
     * @param config - base configuration
     */
    function FeatureLabel(_ref) {
      var _this;

      var parent = _ref.parent,
          bioMap = _ref.bioMap,
          featureModel = _ref.featureModel,
          config = _ref.config;

      _classCallCheck(this, FeatureLabel);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FeatureLabel).call(this, {
        parent: parent,
        tags: [featureModel.name]
      }));
      _this.config = config;
      _this.labelPos = config.labelPosition || config.position;
      _this.fm = featureModel;
      _this.model = featureModel.model;
      _this.view = bioMap.view;
      _this.pixelScaleFactor = _this.view.pixelScaleFactor;
      _this.invert = bioMap.view.invert;
      _this.position = _this.invert ? _this.model.coordinates.start : _this.model.coordinates.stop;

      var y1 = translateScale(_this.position, _this.view.base, _this.view.visible, _this.invert) * _this.pixelScaleFactor;

      _this.show = true;
      var padding = 2;
      var width = config.labelSize + padding;
      _this.offset = _this.labelPos >= 0 ? 0 : padding;
      var left = _this.labelPos >= 0 ? _this.fm.bounds.right : _this.fm.bounds.left - width;
      _this.show = false;
      _this.bounds = new Bounds({
        top: y1,
        left: left,
        width: width,
        height: -_this.config.labelSize * _this.model.name.length / 2,
        allowSubpixel: false
      });
      return _this;
    }
    /**
     * Draw label on cmap canvas context
     * @param ctx
     */


    _createClass(FeatureLabel, [{
      key: "draw",
      value: function draw(ctx) {
        var config = this.config;
        ctx.font = "".concat(config.labelSize, "px ").concat(config.labelFace);
        var y1 = translateScale(this.position, this.view.base, this.view.visible, this.invert) * this.pixelScaleFactor;
        this.bounds.top = y1;
        this.bounds.height = -ctx.measureText(this.model.name).width;
        if (!this.show) return;
        var gb = this.canvasBounds || {};
        ctx.save();
        ctx.translate(gb.right, gb.top);
        ctx.textAlign = 'left';
        ctx.fillStyle = config.labelColor;
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(this.model.name, 0, -this.offset); // config.labelSize-2);

        ctx.restore();
        this.show = false; // reset show for next draw cycle
      }
    }]);

    return FeatureLabel;
  }(SceneGraphNodeBase);

  var FeatureLabelTrack =
  /*#__PURE__*/
  function (_SceneGraphNodeTrack) {
    _inherits(FeatureLabelTrack, _SceneGraphNodeTrack);

    /**
     * Constructor - sets up a track that's a group labels for other features
     * @param params
     */
    function FeatureLabelTrack(params) {
      var _this;

      _classCallCheck(this, FeatureLabelTrack);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FeatureLabelTrack).call(this, params));
      _this.dirty = true;
      _this.trackPos = _this.parent.trackPos;

      _this.generateFeatureLabels(params);

      return _this;
    }
    /**
     * Gets all visible labels, hiding ones that may otherwise be
     * an issue due to overlapping
     */


    _createClass(FeatureLabelTrack, [{
      key: "draw",

      /**
       * Debug draw to check track positioning
       * @param ctx
       */
      value: function draw(ctx) {
        ctx.save();
        ctx.globalAlpha = .5;
        ctx.fillStyle = 'green';
        var gb = this.canvasBounds;
        ctx.fillRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(gb.width), Math.floor(gb.height));
        this.children.forEach(function (child) {
          var cb = child.canvasBounds; // noinspection JSSuspiciousNameCombination
          // noinspection JSSuspiciousNameCombination

          ctx.fillRect(Math.floor(cb.left), Math.floor(cb.top), Math.floor(cb.width), Math.floor(cb.height));
        });
        ctx.restore();
      }
      /**
       * Get RTree children that are visible in the canvas' current zoom bounds
       * @returns {Array}
       */

    }, {
      key: "generateFeatureLabels",
      value: function generateFeatureLabels(params) {
        var _this2 = this;

        this.filteredFeatures = [];
        var b = this.parent.bounds;
        this.bounds = new Bounds({
          allowSubpixel: false,
          top: 0,
          left: 0,
          width: this.parent.bounds.width,
          height: b.height
        });
        var fmData = [];
        this.offset = 0;
        this.maxLoc = 0;
        var qtlConf = params.config;

        for (var key in this.parent.model.config.qtl) {
          if (!qtlConf.hasOwnProperty(key)) {
            qtlConf[key] = this.parent.model.config.qtl[key];
          }
        }

        this.qtlMarks = this.parent.featureData.map(function (model) {
          var fm = new FeatureLabel({
            featureModel: model,
            parent: _this2,
            bioMap: _this2.parent.model,
            initialConfig: qtlConf,
            config: qtlConf
          });

          _this2.addChild(fm);

          var gb = fm.canvasBounds;
          var loc = {
            minY: gb.top < gb.bottom ? gb.top : gb.bottom,
            maxY: gb.top > gb.bottom ? gb.top : gb.bottom,
            minX: gb.left,
            maxX: gb.right,
            data: fm
          };

          _this2.locMap.insert(loc);

          if (fm.bounds.left < _this2.bounds.left && fm.bounds.left < _this2.offset) {
            _this2.offset = -fm.bounds.left;
          }

          if (fm.bounds.right > _this2.bounds.right && fm.bounds.right > _this2.offset) {
            _this2.offset = fm.bounds.right - _this2.bounds.right;
          } //if (gb.right > this.canvasBounds.right) {
          //  this.bounds.right += gb.right - this.canvasBounds.right;
          //}


          fmData.push(loc);
          return fm;
        });
        this.locMap.clear();
        this.locMap.load(fmData);
      }
    }, {
      key: "visible",
      get: function get() {
        var _this3 = this;

        this.locMap.clear();
        this.locMap.load(this.hitMap);
        var view = this.parent.model.view;
        var startY = view.inverse ? view.visible.stop : view.visible.start;
        var stopY = view.inverse ? view.visible.start : view.visible.stop;
        var vis = this.locMap.all().sort(function (a, b) {
          return a.minY - b.minY;
        }).map(function (child) {
          child.data.show = false;

          if (!(child.data.position > stopY || child.data.position < startY)) {
            var b = child.data.canvasBounds;

            var hits = _this3.locMap.search({
              maxY: b.top > b.bottom ? b.top : b.bottom,
              minY: b.top < b.bottom ? b.top : b.bottom,
              maxX: b.right,
              minX: b.left
            });

            if (hits.length === 1) {
              child.data.show = true;
            } else {
              var visHits = hits.filter(function (hit) {
                return hit.data.show;
              });

              if (visHits.length === 0) {
                child.data.show = true;
              }
            }
          }

          return child;
        }); //
        //return visible;

        return vis; //return this.locMap.all();
        //return vis.concat([{data:this}]);
        //return [{data:this}];
        //return this.locMap.all().concat([{data:this}]); // debugging statement to test track width bounds
      }
    }, {
      key: "hitMap",
      get: function get() {
        //return this.locMap.all();
        return this.children.map(function (child) {
          return {
            maxY: child.canvasBounds.top,
            minY: child.canvasBounds.bottom,
            minX: child.canvasBounds.left,
            maxX: child.canvasBounds.right,
            data: child
          };
        });
      }
    }]);

    return FeatureLabelTrack;
  }(SceneGraphNodeTrack);

  var BlockLabel =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(BlockLabel, _SceneGraphNodeBase);

    /**
     * Constructor
     *
     * @param parent - parent scene graph node
     * @param bioMap - map data
     * @param featureModel - feature data
     * @param config - base configuration
     * @param tempCtx - temp canvas to measure display size for offsets
     */
    function BlockLabel(_ref) {
      var _this;

      var parent = _ref.parent,
          bioMap = _ref.bioMap,
          featureModel = _ref.featureModel,
          config = _ref.config,
          tempCtx = _ref.tempCtx;

      _classCallCheck(this, BlockLabel);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(BlockLabel).call(this, {
        parent: parent,
        tags: [featureModel.name]
      }));
      _this.config = config;
      _this.fm = featureModel;
      _this.model = featureModel.model;
      _this.view = bioMap.view;
      _this.pixelScaleFactor = _this.view.pixelScaleFactor;
      _this.invert = bioMap.view.invert;
      _this.position = _this.invert ? _this.model.coordinates.stop : _this.model.coordinates.start;
      _this.labelPos = config.labelPosition || config.position;
      _this.padding = config.labelPadding || 0;

      var y1 = translateScale(_this.position, _this.view.base, _this.view.visible, _this.invert) * _this.pixelScaleFactor;

      _this.show = false;
      tempCtx.font = "".concat(config.labelSize, "px ").concat(config.labelFace);
      _this.width = tempCtx.measureText(_this.model.name).width + _this.padding;

      if (_this.width > _this.parent.trackMaxWidth) {
        _this.parent.trackMaxWidth = _this.width;
      }

      _this.bounds = new Bounds({
        top: y1 + config.labelSize / 2,
        bottom: y1 - config.labelSize / 2,
        left: 0,
        width: 0,
        allowSubpixel: false
      });
      return _this;
    }
    /**
     * Draw label on cmap canvas context
     * @param ctx
     */


    _createClass(BlockLabel, [{
      key: "draw",
      value: function draw(ctx) {
        var config = this.config;
        ctx.font = "".concat(config.labelSize, "px ").concat(config.labelFace);
        var y1 = translateScale(this.position, this.view.base, this.view.visible, this.invert) * this.pixelScaleFactor;
        var height = config.labelSize;
        var width = this.bounds.width;

        if (width === 0) {
          // only need to do new bounds once as fully replacing takes longer than shifting.
          this.bounds = new Bounds({
            top: y1 + height / 2,
            bottom: y1 - height / 2,
            left: this.labelPos >= 0 ? this.padding : this.parent.trackMaxWidth - this.width,
            width: this.width,
            allowSubpixel: false
          });
        } else {
          this.bounds.translate(0, y1 + height / 2 - this.bounds.top);
        }

        if (!this.show) return;
        var gb = this.canvasBounds || {};
        ctx.save();
        ctx.translate(gb.left, gb.top);
        ctx.textAlign = 'left';
        ctx.fillStyle = config.labelColor;
        ctx.fillText(this.model.name, 0, 0);
        ctx.restore(); // reset bounding box to fit the new stroke location/width

        this.show = false;
      }
    }]);

    return BlockLabel;
  }(SceneGraphNodeBase);

  var BlockLabelTrack =
  /*#__PURE__*/
  function (_SceneGraphNodeTrack) {
    _inherits(BlockLabelTrack, _SceneGraphNodeTrack);

    /**
     * Constructor - sets up a track that's a group labels for other features
     * @param params
     */
    function BlockLabelTrack(params) {
      var _this;

      _classCallCheck(this, BlockLabelTrack);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(BlockLabelTrack).call(this, params));
      _this.dirty = true;
      _this.trackPos = _this.parent.trackPos; //don't draw labels if they aren't to be shown

      _this.generateBlockLabels(params);

      return _this;
    }
    /**
     * Gets all visible labels, hiding ones that may otherwise be
     * an issue due to overlapping
     */


    _createClass(BlockLabelTrack, [{
      key: "draw",

      /**
       * Debug draw to check track positioning
       * @param ctx
       */
      value: function draw(ctx) {
        ctx.save();
        ctx.globalAlpha = .5;
        ctx.fillStyle = 'green';
        var gb = this.canvasBounds;
        ctx.fillRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(gb.width), Math.floor(gb.height));
        this.children.forEach(function (child) {
          var cb = child.canvasBounds; // noinspection JSSuspiciousNameCombination
          // noinspection JSSuspiciousNameCombination

          ctx.fillRect(Math.floor(cb.left), Math.floor(cb.top), Math.floor(cb.width), Math.floor(cb.height));
        });
        ctx.restore();
      }
      /**
       * Get RTree children that are visible in the canvas' current zoom bounds
       * @returns {Array}
       */

    }, {
      key: "generateBlockLabels",
      value: function generateBlockLabels(params) {
        var _this2 = this;

        this.filteredFeatures = [];
        this.trackMaxWidth = 10;
        var b = this.parent.bounds;
        var trackpos = params.config.labelPosition || params.config.position || 1;
        var startLeft = trackpos >= 0 ? b.right : b.left;
        this.bounds = new Bounds({
          allowSubpixel: false,
          top: 0,
          left: startLeft,
          right: this.parent.featureGroup.bounds.right,
          height: b.height
        });
        var fmData = [];
        this.maxLoc = 0;
        var qtlConf = params.config; // create a temp canvas context to

        var tempCanvas = document.createElement('canvas');
        tempCanvas.setAttribute('width', 1000);
        tempCanvas.setAttribute('height', 1000);
        var tempCtx = tempCanvas.getContext('2d'); //for( let key in this.parent.model.config.qtl){
        //  if(!qtlConf.hasOwnProperty(key)){
        //    qtlConf[key] = this.parent.model.config.qtl[key];
        //  }
        //}

        this.qtlMarks = this.parent.featureData.map(function (model) {
          var fm = new BlockLabel({
            featureModel: model,
            parent: _this2,
            bioMap: _this2.parent.model,
            initialConfig: qtlConf,
            config: qtlConf,
            tempCtx: tempCtx
          }); //if(this.bounds.left+this.trackMaxWidth > this.bounds.right){
          //  this.bounds.width = this.trackMaxWidth;
          //}

          _this2.addChild(fm);

          var gb = fm.canvasBounds;
          var loc = {
            minY: gb.top,
            maxY: gb.bottom,
            minX: _this2.canvasBounds.left,
            maxX: _this2.canvasBounds.right,
            data: fm
          };

          _this2.locMap.insert(loc);

          fmData.push(loc);
          return fm;
        });
        this.bounds = new Bounds({
          allowSubpixel: false,
          top: 0,
          left: trackpos > 0 ? b.right : -this.trackMaxWidth,
          width: this.trackMaxWidth,
          height: b.height
        });
        this.offset = trackpos > 0 ? this.trackMaxWidth : -this.trackMaxWidth;
        this.locMap.clear();
        this.locMap.load(fmData);
      }
    }, {
      key: "visible",
      get: function get() {
        var _this3 = this;

        this.locMap.clear();
        this.locMap.load(this.hitMap);
        var view = this.parent.model.view;
        var startY = view.inverse ? view.visible.stop : view.visible.start;
        var stopY = view.inverse ? view.visible.start : view.visible.stop;
        var vis = this.locMap.all().sort(function (a, b) {
          return a.minY - b.minY;
        }).map(function (child) {
          var modelBounds = child.data.model.coordinates;
          if (modelBounds.start > stopY || modelBounds.stop < startY) return child;

          if (!(child.data.position > stopY || child.data.position < startY)) {
            var b = child.data.canvasBounds;

            var hits = _this3.locMap.search({
              maxY: b.top > b.bottom ? b.top : b.bottom,
              minY: b.top < b.bottom ? b.top : b.bottom,
              maxX: b.right,
              minX: b.left
            });

            if (hits.length === 1) {
              child.data.show = true;
            } else {
              var visHits = hits.filter(function (hit) {
                return hit.data.show;
              });

              if (visHits.length === 0) {
                child.data.show = true;
              }
            }
          }

          return child;
        }); //
        //return visible;

        return vis; //return this.locMap.all();
        //return vis.concat([{data:this}]);
        //return [{data:this}];
        //return this.locMap.all().concat([{data:this}]); // debugging statement to test track width bounds
      }
    }, {
      key: "hitMap",
      get: function get() {
        //return this.locMap.all();
        return this.children.map(function (child) {
          return {
            maxY: child.canvasBounds.top,
            minY: child.canvasBounds.bottom,
            minX: child.canvasBounds.left,
            maxX: child.canvasBounds.right,
            data: child
          };
        });
      }
    }]);

    return BlockLabelTrack;
  }(SceneGraphNodeTrack);

  /**
   * TrackSelector
   * A meta-class that reduces overhead when creating new tracks.
   *
   * @extends SceneGraphNodeTrack
   */
  function feature(params) {
    var featureStyle = params.featureStyle;

    if (featureStyle === 'qtl') {
      return new QtlTrack(params);
    } else if (featureStyle === 'manhattan') {
      return new ManhattanPlot(params);
    }

    return undefined;
  }
  function label(params) {
    var labelStyle = params.config.labelStyle;

    if (labelStyle === 'feature') {
      return new FeatureLabelTrack(params);
    } else if (labelStyle === 'block') {
      return new BlockLabelTrack(params);
    }

    return undefined;
  }

  var MapTrack =
  /*#__PURE__*/
  function (_SceneGraphNodeTrack) {
    _inherits(MapTrack, _SceneGraphNodeTrack);

    /**
     *
     * @param params
     */
    function MapTrack(params) {
      var _this;

      _classCallCheck(this, MapTrack);

      console.log('MapTrack-> Constructing Map');
      _this = _possibleConstructorReturn(this, _getPrototypeOf(MapTrack).call(this, params));
      var b = _this.parent.bounds;
      _this.model = _this.parent.model; //const backboneWidth = b.width * 0.2;

      var backboneWidth = _this.model.config.backbone.width;
      _this.bounds = new Bounds({
        allowSubpixel: false,
        top: 0,
        left: 0,
        width: backboneWidth,
        height: b.height
      });
      _this.mC = _this.parent.mapCoordinates;
      _this.backbone = new MapBackbone({
        parent: _assertThisInitialized(_assertThisInitialized(_this)),
        bioMap: _this.model,
        config: _this.model.config.backbone
      });

      _this.addChild(_this.backbone); // calculate scale factor between backbone coordinates in pixels


      _this.model.view.pixelScaleFactor = _this.backbone.bounds.height / _this.model.length;
      _this.model.view.backbone = _this.canvasBounds; // Setup groups for markers and labels

      var markerGroup = new SceneGraphNodeGroup({
        parent: _assertThisInitialized(_assertThisInitialized(_this))
      });

      _this.addChild(markerGroup);

      _this.markerGroup = markerGroup;
      markerGroup.bounds = _this.backbone.bounds;

      _this.addChild(markerGroup); // Filter features for drawing, if there is an array of tags to filter, use them, otherwise
      // use length of individual models.


      var filterArr = _this.model.config.marker.filter;

      if (filterArr.length > 0) {
        _this.filteredFeatures = _this.model.features.filter(function (model) {
          return filterArr.some(function (tag) {
            return model.tags.indexOf(tag) !== -1;
          });
        });
      } else {
        _this.filteredFeatures = _this.model.features.filter(function (model) {
          return model.length <= 0.00001;
        });
      } //Place features and their labels, prepare to add to rtree


      var fmData = [];
      _this.featureMarks = _this.filteredFeatures.map(function (model) {
        var fm = new FeatureMark({
          featureModel: model,
          parent: _this.backbone,
          bioMap: _this.model,
          config: _this.model.config.marker
        }); //  let lm = new OldFeatureLabel({
        //    featureModel: model,
        //    parent: this.labelGroup,
        //    bioMap: this.parent.model,
        //    config: this.model.config.marker
        //  });

        markerGroup.addChild(fm); //  labelGroup.addChild(lm);

        fmData.push({
          minY: model.coordinates.start,
          maxY: model.coordinates.stop,
          minX: fm.canvasBounds.left,
          maxX: fm.canvasBounds.right,
          data: fm
        }); // lmData.push({
        //   minY: model.coordinates.start,
        //   maxY: model.coordinates.stop,
        //   minX: lm.canvasBounds.left,
        //   maxX: lm.canvasBounds.left + this.labelGroup.bounds.width,
        //   data: lm
        // });
        // if (lm.bounds.right > this.labelGroup.bounds.right) this.labelGroup.bounds.right = lm.bounds.right;
        // return fm;
      }); // Load group rTrees for markers and labels

      markerGroup.locMap.load(fmData); //labelGroup.locMap.load(lmData);

      _this.featureData = markerGroup.children;
      _this.featureGroup = markerGroup;

      if (Math.abs(_this.model.config.ruler.position) < Math.abs(_this.model.config.marker.labelPosition)) {
        _this._addRuler();

        _this._addLabels();
      } else {
        _this._addLabels();

        _this._addRuler();
      } //this.ruler = new Ruler({parent: this, bioMap: this.model, config: this.model.config.ruler});
      //labelGroup.bounds = new Bounds({
      //  top: 0,
      //  left: this.backbone.bounds.right + 1,
      //  height: this.bounds.height,
      //  width: 0
      //});
      //// load this rtree with markers (elements that need hit detection)


      _this.locMap.load(fmData);

      return _this;
    }

    _createClass(MapTrack, [{
      key: "_addRuler",
      value: function _addRuler() {
        var config = this.model.config;
        this.ruler = new Ruler({
          parent: this,
          bioMap: this.model,
          config: config.ruler
        }); //(reposition to outside the label group iff both are on the same side, and label group
        // has already been drawn

        if (this.labelGroup && config.ruler.position < 0 === config.marker.labelPosition < 0) {
          var width = this.ruler.bounds.width;

          if (config.ruler.position >= 0) {
            // this.ruler.bounds.left = (this.labelGroup.offset + width + config.ruler.padding);
            // this.ruler.bounds.right = this.ruler.bounds.left + width;
            this.ruler.bounds.translate(this.labelGroup.offset + width + config.ruler.padding - this.ruler.bounds.left, 0);
            this.bounds.right += width + config.ruler.padding;
          } else {
            this.bounds.left += width;
            this.featureGroup.bounds.left += width;
            this.ruler.bounds.right = 0;
            this.ruler.bounds.left = this.ruler.bounds.right - width;
          }
        }
      }
    }, {
      key: "_addLabels",
      value: function _addLabels() {
        var config = this.model.config;
        var offsetRuler = this.ruler && config.ruler.position < 0 === config.marker.labelPosition < 0;

        if (offsetRuler) {
          config.marker.labelPadding += 2 * (config.ruler.padding + Math.abs(this.ruler.bounds.width));
        } // set up track bounds to recognise labels


        this.labelGroup = label({
          parent: this,
          config: config.marker
        }); ////this.addChild(labelGroup);

        var offset = this.labelGroup.offset || 0;

        if (offset < 0) {
          offset = -offset;
          this.featureGroup.bounds.translate(offset - this.featureGroup.bounds.left, 0); //this.featureGroup.bounds.left += offset;

          this.labelGroup.bounds.left += offset; //this.featureGroup.bounds.right += offset;

          if (offsetRuler) {
            this.ruler.bounds.translate(offset - this.ruler.bounds.left, 0);
            this.ruler.bounds.left += offset;
            this.ruler.bounds.right += offset;
          }
        }

        this.labelGroup.bounds.right += offset;
        this.bounds.right += offset; // Move labels if the ruler is on same side and placed before labels
      }
      /**
       *
       * @returns {*[]}
       */

    }, {
      key: "draw",

      /**
       *
       * @param ctx
       */
      value: function draw(ctx) {
        var gb = this.canvasBounds || {};
        ctx.save();
        ctx.globalAlpha = .5;
        ctx.fillStyle = 'blue'; // noinspection JSSuspiciousNameCombination
        // noinspection JSSuspiciousNameCombination

        ctx.fillRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(gb.width), Math.floor(gb.height));
        ctx.fillStyle = 'green'; // gb = this.labelGroup.canvasBounds || {};
        // // noinspection JSSuspiciousNameCombination
        // // noinspection JSSuspiciousNameCombination
        // ctx.fillRect(
        //   Math.floor(gb.left),
        //   Math.floor(gb.top),
        //   Math.floor(gb.width),
        //   Math.floor(gb.height)
        // );

        ctx.restore();
      }
    }, {
      key: "loadLabelMap",
      value: function loadLabelMap() {}
    }, {
      key: "visible",
      get: function get() {
        var coord = this.parent.model.view.base;
        var visc = this.parent.model.view.visible;
        var vis = [{
          minX: this.bounds.left,
          maxX: this.bounds.right,
          minY: coord.start,
          maxY: coord.stop,
          data: this.backbone
        }];
        vis = vis.concat(this.locMap.search({
          minX: this.bounds.left,
          maxX: this.bounds.right,
          minY: visc.start,
          maxY: visc.stop
        })); // vis = vis.concat([{data:this}]);
        //  let labels = [];
        //  let start = visc.start;
        //  let stop = visc.stop;
        //  let psf = this.labelGroup.children[0].pixelScaleFactor;
        //  let step = ((visc.start * (coord.stop * psf - 12) + visc.stop * (12 - coord.start * psf)) / (psf * (coord.stop - coord.start)) - start) - (coord.start * -1);
        //  for (let i = start; i < stop; i += step) {
        //    let item = knn(this.labelGroup.locMap, this.labelGroup.children[0].canvasBounds.left, i, 1)[0];
        //    if (labels.length === 0) {
        //      labels.push(item);
        //      continue;
        //    }
        //    let last = labels[labels.length - 1];
        //    if (item !== last && (item.minY > (last.maxY + step))) {
        //      labels.push(item);
        //    }
        //  }
        //  vis = vis.concat(labels);
        //  return vis;
        //let visible = [];
        //this.labelGroup.forEach(child => {
        //  visible = visible.concat(child.visible);
        //  if(child.labels){
        //    visible = visible.concat(child.labels.visible);
        //  }
        //});

        if (this.labelGroup) {
          return this.labelGroup.visible.concat(vis);
        }

        return vis;
      }
      /**
       *
       */

    }, {
      key: "hitMap",
      get: function get() {
        var bbGb = this.backbone.canvasBounds;
        return this.markerGroup.children.map(function (child) {
          return {
            minY: child.canvasBounds.bottom + 1,
            maxY: child.canvasBounds.top - 1,
            minX: bbGb.left,
            maxX: bbGb.right,
            data: child
          };
        });
      }
    }]);

    return MapTrack;
  }(SceneGraphNodeTrack);

  var FeatureTrack =
  /*#__PURE__*/
  function (_SceneGraphNodeTrack) {
    _inherits(FeatureTrack, _SceneGraphNodeTrack);

    /**
     * Constructor - sets up a track that's a collection of data display tracks
     * @param params
     */
    function FeatureTrack(params) {
      var _this;

      _classCallCheck(this, FeatureTrack);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FeatureTrack).call(this, params));
      _this.model = _this.parent.model;
      var b = _this.parent.bounds;
      _this.trackPos = params.position || 1;
      var left = _this.trackPos < 0 ? remToPix(3) : _this.parent.backbone.canvasBounds.right;
      _this.bounds = new Bounds({
        allowSubpixel: false,
        top: b.top,
        left: left,
        width: 0,
        height: b.height
      });

      if (_this.parent.model.tracks) {
        var tracks = _this.trackPos < 1 ? _this.parent.tracksLeft : _this.parent.tracksRight;
        tracks.forEach(function (track, order) {
          // newFeatureTrack is a group with two dataSourceComponents, the feature data track, and the feature label track
          //track.appState = this.parent.appState;
          var newFeatureTrack = new SceneGraphNodeGroup({
            parent: _assertThisInitialized(_assertThisInitialized(_this))
          });
          newFeatureTrack.model = _this.model;
          newFeatureTrack.config = track;
          newFeatureTrack.order = order;
          newFeatureTrack.trackPos = _this.trackPos;
          var trackLeft = order === 0 ? 0 : _this.children[order - 1].bounds.right;
          trackLeft += _this.model.config.qtl.padding;
          newFeatureTrack.bounds = new Bounds({
            allowSubpixel: false,
            top: 0,
            left: trackLeft,
            width: _this.model.config.qtl.trackMinWidth,
            height: b.height
          });
          var featureData = {};
          _this.labels = []; //Load feature tracks and labels
          //TODO: Add track adaptor class to prevent this type of mess
          //if(track.type === 'qtl') {
          //  newFeatureTrack.title = track.title || this.model.config.qtl.title || track.filters[0];
          //  featureData = new QtlTrack({parent:this , config: track});
          //  newFeatureTrack.featureData = featureData.children;
          //  //newFeatureTrack.labels = new FeatureLabelTrack({parent:newFeatureTrack, config:track});
          //} else if( track.type === 'manhattan') {
          //  newFeatureTrack.sources = this.parent.appState.sources;
          //  newFeatureTrack.title = track.title || this.model.config.manhattan.title || 'Manhattan';
          //  featureData = new ManhattanPlot({parent:newFeatureTrack, config: track});
          //}

          newFeatureTrack.sources = _this.parent.appState.sources;
          var trackType = track.type.toLowerCase();
          featureData = feature({
            parent: newFeatureTrack,
            config: track,
            featureStyle: trackType
          });

          if (featureData !== undefined) {
            //only add if valid track
            newFeatureTrack.title = track.title || _this.model.config[trackType].title || trackType;

            _this.addChild(newFeatureTrack);

            newFeatureTrack.addChild(featureData);

            if (newFeatureTrack.canvasBounds.right > _this.canvasBounds.right) {
              _this.bounds.right = _this.bounds.left + (newFeatureTrack.canvasBounds.right - _this.canvasBounds.left);
            } //if(newFeatureTrack.canvasBounds.right > this.canvasBounds.right){
            //  this.bounds.right =  this.bounds.left + (newFeatureTrack.canvasBounds.right - this.canvasBounds.left);
            //}

          } //Shift newFeature track bounds for wide feature glyphs
          // if(featureData.canvasBounds.right > newFeatureTrack.canvasBounds.right){
          //   newFeatureTrack.bounds.right += featureData.bounds.right;
          // }
          //Shift newFeature track bounds for wide labels
          //if(newFeatureTrack.labels) console.log("labPost", newFeatureTrack.labels.canvasBounds.left, newFeatureTrack.canvasBounds.left);
          //if(newFeatureTrack.labels && newFeatureTrack.labels.canvasBounds.right > newFeatureTrack.canvasBounds.right) {
          //  newFeatureTrack.bounds.right = newFeatureTrack.bounds.right + newFeatureTrack.labels.bounds.right;
          //}
          //if(newFeatureTrack.labels && newFeatureTrack.labels.canvasBounds.left < newFeatureTrack.canvasBounds.left){
          //  const offset = (newFeatureTrack.canvasBounds.left - newFeatureTrack.labels.canvasBounds.left);
          //  this.bounds.left += offset;
          //  this.bounds.width += (offset);
          //  //newFeatureTrack.bounds.left += offset;
          //  //newFeatureTrack.bounds.right += offset;
          // }
          //shift this tracks's bounds so it still fits in the canvas

        });
      } else {
        _this.parent.model.tracks = [];
      }

      return _this;
    }
    /**
     *
     */


    _createClass(FeatureTrack, [{
      key: "draw",

      /**
       * Debug draw to check track positioning
       * @param ctx
       */
      value: function draw(ctx) {
        ctx.save();
        ctx.globalAlpha = .5;
        ctx.fillStyle = '#ADD8E6';
        this.children.forEach(function (child) {
          console.log('ft draw', child.canvasBounds);
          var cb = child.canvasBounds; // noinspection JSSuspiciousNameCombination
          // noinspection JSSuspiciousNameCombination

          ctx.fillRect(Math.floor(cb.left), Math.floor(cb.top), Math.floor(cb.width), Math.floor(cb.height));
        }); // ctx.fillStyle = 'red';
        // let cb = this.canvasBounds;
        // ctx.fillRect(
        //   Math.floor(cb.left),
        //   Math.floor(cb.top),
        //   Math.floor(cb.width),
        //   Math.floor(cb.height)
        // );

        ctx.restore();
      }
      /**
       * Get RTree children that are visible in the canvas' current zoom bounds
       * @returns {Array}
       */

    }, {
      key: "visible",
      get: function get() {
        var visible = [];
        this.children.forEach(function (child) {
          visible = visible.concat(child.visible);

          if (child.labels) {
            visible = visible.concat(child.labels.visible);
          }
        });
        return visible; //return visible.concat([{data: this}]); // debugging statement to test track width bounds
      }
    }, {
      key: "hitMap",
      get: function get() {
        //return [];
        // console.log('hits child',child);
        var hits = [];
        this.children.forEach(function (child) {
          return child.children.map(function (qtlGroup) {
            hits = hits.concat(qtlGroup.hitMap);
          });
        });
        return hits;
      }
    }]);

    return FeatureTrack;
  }(SceneGraphNodeTrack);

  var TestDot =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(TestDot, _SceneGraphNodeBase);

    /**
     * Constructor
     *
     * @param parent - parent scene graph node
     * @param bioMap - map data
     * @param featureModel - feature data
     * @param config - configuration information object
     */
    function TestDot(_ref) {
      var _this;

      var parent = _ref.parent,
          position = _ref.position,
          radius = _ref.radius;

      _classCallCheck(this, TestDot);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(TestDot).call(this, {
        parent: parent
      })); //setup config

      _this.position = position;
      _this.radius = radius;
      _this.bounds = new Bounds({
        top: 0,
        left: 0,
        width: 2 * _this.radius,
        //this.fontSize*(this.model.name.length),
        height: 2 * _this.radius,
        allowSubpixel: false
      });
      return _this;
    }
    /**
     * Draw label on cmap canvas context
     * @param ctx
     */


    _createClass(TestDot, [{
      key: "draw",
      value: function draw(ctx) {
        //Setup a base offset based on parent track
        var y = this.position.y;
        var x = this.position.x; // Draw dot

        ctx.beginPath();
        ctx.fillStyle = 'red';
        ctx.arc(x, y, this.radius, 0, 2 * Math.PI, false);
        ctx.fill(); //ctx.lineWidth = config.lineWeight;
        //ctx.strokeStyle = config.lineColor;
        //ctx.stroke();
        //update bounding box

        this.bounds.translate(x - this.radius - this.bounds.left, y - this.radius - this.bounds.top);
      }
    }, {
      key: "visible",
      get: function get() {
        return {
          data: this
        };
      }
    }]);

    return TestDot;
  }(SceneGraphNodeBase);

  var SelectBox =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(SelectBox, _SceneGraphNodeBase);

    /**
     * Constructor
     *
     * @param parent - parent scene graph node
     * @param bioMap - map data
     * @param featureModel - feature data
     * @param config - configuration information object
     */
    function SelectBox(_ref) {
      var _this;

      var parent = _ref.parent,
          position = _ref.position;

      _classCallCheck(this, SelectBox);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SelectBox).call(this, {
        parent: parent
      }));
      _this.position = position;
      _this.bounds = new Bounds({
        top: position.y,
        left: position.x,
        width: 0,
        //this.fontSize*(this.model.name.length),
        height: 0,
        allowSubpixel: false
      });
      return _this;
    }

    _createClass(SelectBox, [{
      key: "updatePosition",
      value: function updatePosition(position) {
        this.bounds.right = position.x;
        this.bounds.bottom = position.y;
      }
      /**
       * Draw label on cmap canvas context
       * @param ctx
       */

    }, {
      key: "draw",
      value: function draw(ctx) {
        //Setup a base offset based on parent track
        ctx.lineWidth = 1.0;
        ctx.strokeStyle = 'black'; // noinspection JSSuspiciousNameCombination

        ctx.strokeRect(this.position.x, this.position.y, this.bounds.width, this.bounds.height);
      }
    }, {
      key: "visible",
      get: function get() {
        return {
          data: this
        };
      }
    }]);

    return SelectBox;
  }(SceneGraphNodeBase);

  var BioMap =
  /*#__PURE__*/
  function (_SceneGraphNodeCanvas) {
    _inherits(BioMap, _SceneGraphNodeCanvas);

    /**
     * Create a new bio map
     *
     * @param {object} bioMapModel - Parsed model of the bio map to be drawn
     * @param {object} appState - Application's meta state object
     * @param {object} layoutBounds - Bounds object of position on screen
     * @param {number} bioMapIndex - bio map's order on screen,
     * @param {object} initialView - bio map's original layout, used for resetting view
     */
    function BioMap(_ref) {
      var _this;

      var bioMapModel = _ref.bioMapModel,
          appState = _ref.appState,
          layoutBounds = _ref.layoutBounds,
          bioMapIndex = _ref.bioMapIndex,
          initialView = _ref.initialView,
          sub = _ref.sub;

      _classCallCheck(this, BioMap);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(BioMap).call(this, {
        model: bioMapModel,
        sub: sub
      }));
      console.log('constructing bioMap'); //this.setCanvas(canvas); //set canvas and rendering context

      _this.initialView = initialView;
      _this.bioMapIndex = bioMapIndex;
      _this.model.visible = {
        start: _this.model.coordinates.start,
        stop: _this.model.coordinates.stop
      };
      var bm = appState.bioMaps[bioMapIndex].view; //in case the view was altered by the querystring to start

      if (bm === undefined) bm = {};
      bm.visible = bm.visible || {};
      _this.model.view = {
        base: {
          start: _this.model.coordinates.start,
          stop: _this.model.coordinates.stop
        },
        visible: {
          start: bm.visible.start ? bm.visible.start : _this.model.coordinates.start,
          stop: bm.visible.stop ? bm.visible.stop : _this.model.coordinates.stop
        },
        invert: typeof bm.invert === 'boolean' ? bm.invert : _this.model.config.invert
      };
      _this.canvas = undefined;
      _this.model.manhattanPlot = _this.initialView.manhattan || null;
      _this.zoomDelta = (_this.model.view.base.stop - _this.model.view.base.start) / _this.model.config.ruler.steps; // set up coordinate bounds for view scaling

      _this.appState = appState;
      _this.verticalScale = 0;
      _this.backbone = null;
      _this.featureMarks = [];
      _this.featureLabels = [];
      _this.info = {
        top: 0,
        left: 0,
        display: 'none'
      }; //display elements that can be added via mouse events

      _this.selectionBox = null;
      _this.clickPosition = null;
      _this.dirty = true;

      _this._layout(layoutBounds);

      return _this;
    } // getters and setters

    /**
     * Culls elements to draw.
     *
     * @return array of elements visible in current canvas' viewport
     *
     */


    _createClass(BioMap, [{
      key: "zoomMap",
      //public functions

      /**
       * Handles mouse wheel zoom
       * @param delta - zoom event
       * @returns {boolean} returns true to stop event propagation further down layers
       *
       */
      value: function zoomMap(delta) {
        // TODO: send zoom event to the scenegraph elements which compose the biomap
        // (don't scale the canvas element itself)
        // normalise scroll delta
        this.verticalScale = delta < 0 ? -this.zoomDelta : this.zoomDelta;
        var mcv = this.model.view.base;
        var zStart = this.model.view.visible.start + this.verticalScale;
        var zStop = this.model.view.visible.stop - this.verticalScale;

        if (zStop - zStart < .01) {
          this.verticalScale -= 0.5;
          return true;
        }

        if (zStart < mcv.start) {
          zStart = mcv.start;
        } else if (zStart > zStop) {
          zStart = zStop;
        }

        if (zStop > mcv.stop) {
          zStop = mcv.stop;
        } else if (zStop < zStart) {
          zStop = zStart;
        }

        this.model.view.visible = {
          start: zStart,
          stop: zStop
        };
      } //private functions

      /**
       *  Converts a pixel position to the  canvas' backbone coordinate system.
       *
       *  @param {number} point - pixel position on screen
       *  @return {number} backbone position
       *
       *  @private
       */

    }, {
      key: "_pixelToCoordinate",
      value: function _pixelToCoordinate(point) {
        var coord = this.model.view.base;
        var visc = this.model.view.visible;
        var psf = this.model.view.pixelScaleFactor;
        return (visc.start * (coord.stop * psf - point) + visc.stop * (point - coord.start * psf)) / (psf * (coord.stop - coord.start)) - coord.start * -1;
      }
      /**
       * perform layout of backbone, feature markers, and feature labels.
       *
       * @param {object} layoutBounds - bounds object representing bounds of this canvas
       *
       * @private
       */

    }, {
      key: "_layout",
      value: function _layout(layoutBounds) {
        var _this2 = this;

        // TODO: calculate width based on # of SNPs in layout, and width of feature
        // labels
        // Setup Canvas
        //const width = Math.floor(100 + Math.random() * 200);
        this.lb = this.lb || layoutBounds;
        console.log('BioMap -> layout');
        var width = Math.floor(this.lb.width / this.appState.bioMaps.length);
        this.children = [];
        this.domBounds = this.domBounds || new Bounds({
          left: this.lb.left,
          //top: this.lb.top,
          top: 0,
          width: width > 300 ? width : 300,
          height: this.lb.height
        });
        this.bounds = this.bounds || new Bounds({
          left: 0,
          top: 40,
          width: this.domBounds.width,
          height: Math.floor(this.domBounds.height - 140) // set to reasonably re-size for smaller windows

        }); //Add children tracks

        this.bbGroup = new SceneGraphNodeGroup({
          parent: this
        });
        this.bbGroup.bounds = new Bounds({
          top: this.bounds.top,
          left: this.model.config.ruler.labelSize * 10,
          width: 10,
          height: this.bounds.height
        });
        this.bbGroup.model = this.model;
        this.backbone = new MapTrack({
          parent: this
        });
        this.bbGroup.addChild(this.backbone);
        this.model.view.backbone = this.backbone.backbone.canvasBounds;
        this.ruler = this.backbone.ruler; //this.ruler = new Ruler({parent: this, bioMap: this.model, config: this.model.config.ruler});

        this.bbGroup.addChild(this.ruler);
        this.backbone.children.forEach(function (child) {
          if (child.canvasBounds.left < _this2.bbGroup.bounds.left) {
            _this2.bbGroup.bounds.left = child.canvasBounds.left;
          }

          if (child.canvasBounds.right > _this2.bbGroup.bounds.right) {
            _this2.bbGroup.bounds.right = child.canvasBounds.right;
          }
        });
        this.children.push(this.bbGroup);
        this.tracksLeft = [];
        this.tracksRight = [];

        if (!this.model.tracks && this.model.config.tracks) {
          this.model.tracks = this.model.config.tracks;
        }

        if (this.model.tracks) {
          this.model.tracks.forEach(function (track, order) {
            track.tracksIndex = order;

            if (track.position === -1) {
              _this2.tracksLeft.push(track);
            } else {
              _this2.tracksRight.push(track);
            }
          });
        }

        var qtlLeft = new FeatureTrack({
          parent: this,
          position: -1
        });
        var qtlRight = new FeatureTrack({
          parent: this,
          position: 1
        }); // let qtlRight = {};
        //let qtlRight = new QtlTrack({parent: this , position: 1});
        //let qtlLeft = new QtlTrack({parent: this, position: -1});

        this.addChild(qtlLeft);
        this.addChild(qtlRight);

        if (qtlLeft && qtlLeft.canvasBounds.right > this.bbGroup.canvasBounds.left) {
          var bbw = this.bbGroup.bounds.width;
          this.bbGroup.bounds.left = qtlLeft.canvasBounds.right + 100;
          this.bbGroup.bounds.width = bbw;
          qtlRight.bounds.translate(qtlLeft.canvasBounds.right, 0);
        }

        if (this.domBounds.width < qtlRight.canvasBounds.right + remToPix(4)) {
          this.domBounds.width = qtlRight.canvasBounds.right + remToPix(4);
        } //load local rBush tree for hit detection


        this._loadHitMap(); //let layout know that width has changed on an element;
        //m.redraw();


        this.inform();
      }
      /**
       * Adds children nodes to the R-tree
       *
       * @private
       */

    }, {
      key: "_loadHitMap",
      value: function _loadHitMap() {
        var hits = [];
        var childrenHits = this.children.map(function (child) {
          return child.hitMap;
        });
        childrenHits.forEach(function (child) {
          hits = hits.concat(child);
        });
        this.locMap.clear(); // = rbush();

        this.locMap.load(hits);
      } // Event Behavior

    }, {
      key: "addCircle",
      value: function addCircle(position) {
        var radius = 4;

        if (!this.clickPosition) {
          this.clickPosition = new TestDot({
            parent: this,
            position: position,
            radius: radius
          });
          this.addChild(this.clickPosition);
        } else {
          this.clickPosition.position = position;
        }

        this._loadHitMap();

        this.dirty = true; //this.inform();

        return this._calculateHits({
          left: position.x - radius,
          right: position.x + radius,
          top: position.y - radius,
          bottom: position.y + radius
        });
      }
    }, {
      key: "onPanStart",
      value: function onPanStart(position) {
        if (!this.ruler) this._layout(this.domBounds);
        var rulerBounds = this.ruler.canvasBounds;
        var evtType = null;
        var rbx = position.x >= rulerBounds.left && position.x <= rulerBounds.right;
        var rby = position.y >= rulerBounds.top && position.y <= rulerBounds.bottom;

        if (rbx && rby) {
          evtType = 'panRuler';
        } else {
          evtType = 'boxSelect';

          this._addSelectionBox(position);
        }

        if (this.clickPosition) this.removeChild(this.clickPosition);
        this.clickPosition = new TestDot({
          parent: this,
          position: position,
          radius: 4
        });
        this.addChild(this.clickPosition); //this.inform();

        return evtType;
      }
    }, {
      key: "onPan",
      value: function onPan(_ref2) {
        var position = _ref2.position,
            _ref2$delta = _ref2.delta,
            delta = _ref2$delta === void 0 ? {
          x: 0,
          y: 0
        } : _ref2$delta,
            type = _ref2.type;

        if (type === 'boxSelect') {
          this._updateSelectionBox(position);
        }

        if (type === 'panRuler') {
          this._panRuler(delta);
        } // this.inform();

      }
    }, {
      key: "onPanEnd",
      value: function onPanEnd(_ref3) {
        var position = _ref3.position,
            type = _ref3.type;
        var hits = null;

        if (type === 'boxSelect') {
          this.onPan({
            position: position,
            type: type
          }); //Determine if select box or zoom box

          var gb = this.ruler.canvasBounds;
          var sb = this.selectionBox.bounds;
          var sgb = this.selectionBox.canvasBounds;
          var lCorner = sgb.left < sgb.right ? sgb.left : sgb.right;
          var rCorner = sgb.right > sgb.left ? sgb.right : sgb.left; // if zoom rectangle contains the ruler, zoom, else populate popover

          if (lCorner <= gb.left && rCorner >= gb.left || lCorner <= gb.right && rCorner >= gb.right) {
            var newStartPos = sb.top >= gb.top ? sb.top : gb.top;
            var newStopPos = sb.bottom <= gb.bottom ? sb.bottom : gb.bottom;

            this._updateRulerVisible({
              top: newStartPos,
              bottom: newStopPos
            });
          } else {
            hits = this._calculateHits(sb);
          } //Remove the box graphic


          this._clearSelectionBox(); // this.inform();

        }

        return hits || [];
      }
    }, {
      key: "_addSelectionBox",
      value: function _addSelectionBox(position) {
        this.selectionBox = new SelectBox({
          parent: this,
          position: position
        });
        this.addChild(this.selectionBox);
      }
    }, {
      key: "_updateSelectionBox",
      value: function _updateSelectionBox(position) {
        this.selectionBox.updatePosition(position);
      }
    }, {
      key: "_clearSelectionBox",
      value: function _clearSelectionBox() {
        this.removeChild(this.selectionBox);
        this.selectionBox = null;
      }
    }, {
      key: "_panRuler",
      value: function _panRuler(delta) {
        if (this.model.config.invert) {
          delta.y = -delta.y;
        }

        var scaleDelta = delta.y / this.model.view.pixelScaleFactor; // prevent moving off top/bottom of ruler range

        if (this.model.view.visible.start + scaleDelta < this.model.view.base.start) {
          scaleDelta = this.model.view.base.start - this.model.view.visible.start;
        } else if (this.model.view.visible.stop + scaleDelta > this.model.view.base.stop) {
          scaleDelta = this.model.view.base.stop - this.model.view.visible.stop;
        }

        this.model.view.visible = {
          start: this.model.view.visible.start + scaleDelta,
          stop: this.model.view.visible.stop + scaleDelta
        };
      }
    }, {
      key: "_updateRulerVisible",
      value: function _updateRulerVisible(bounds) {
        this.model.view.visible = this.model.view.base;

        var baseStart = this._pixelToCoordinate(bounds.top - this.ruler.canvasBounds.top);

        var baseStop = this._pixelToCoordinate(bounds.bottom - this.ruler.canvasBounds.top);

        var swap = baseStart < baseStop;
        var zStart = swap ? baseStart : baseStop;
        var zStop = swap ? baseStop : baseStart;

        if (zStart < this.model.view.base.start) {
          zStart = this.model.view.base.start;
        }

        if (zStop > this.model.view.base.stop) {
          zStop = this.model.view.base.stop;
        }

        this.model.view.visible = {
          start: zStart,
          stop: zStop
        };
      }
    }, {
      key: "_calculateHits",
      value: function _calculateHits(bounds) {
        var left = bounds.left <= bounds.right;
        var top = bounds.top <= bounds.bottom;

        this._loadHitMap();

        var hits = this.hitMap.search({
          minX: left ? bounds.left : bounds.right,
          maxX: left ? bounds.right : bounds.left,
          minY: top ? bounds.top : bounds.bottom,
          maxY: top ? bounds.bottom : bounds.top
        });
        return hits;
      }
    }, {
      key: "visible",
      get: function get() {
        var vis = [];
        var cVis = this.children.map(function (child) {
          return child.visible;
        });
        cVis.forEach(function (item) {
          vis = vis.concat(item);
        }); //if(this.circle) vis = vis.concat[{data:this.circle}];

        return vis;
      }
      /**
       * getter for the R-tree of subnodes.
       * @return rbush R-tree
       */

    }, {
      key: "hitMap",
      get: function get() {
        return this.locMap;
      }
    }]);

    return BioMap;
  }(SceneGraphNodeCanvas);

  var FeatureControlComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FeatureControlComponent, _Component);

    function FeatureControlComponent() {
      var _this;

      _classCallCheck(this, FeatureControlComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FeatureControlComponent).call(this));
      _this.state = {
        width: 10,
        offset: 0,
        refreshPosition: false
      }; //bind eventHandlers to this

      _this.onClick = _this.onClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }

    _createClass(FeatureControlComponent, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.setDivOffset();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        if (this.state.refreshPosition) {
          this.setDivOffset();
        }
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        if (this.props.leftBound !== nextProps.leftBound) {
          this.setState({
            refreshPosition: true,
            offset: 0
          });
        }

        if (this.props.bioIndex !== nextProps.bioIndex) {
          this.setState({
            refreshPosition: true,
            offset: 0
          });
        }
      }
    }, {
      key: "setDivOffset",
      value: function setDivOffset() {
        var offset = this.props.leftBound - (this.base.offsetLeft - this.base.parentElement.offsetLeft);
        this.setState({
          offset: offset,
          refreshPosition: false
        });
      }
    }, {
      key: "onClick",
      value: function onClick() {
        console.log('fcc oc', this.props);
        this.props.modalToggle('feature', this.props.modalData, this.props.newDirection);
      }
    }, {
      key: "render",
      value: function render$$1(_ref, _ref2) {
        var featureTrack = _ref.featureTrack;
        var offset = _ref2.offset;
        // store these bounds, for checking in drawLazily()
        return h("div", {
          class: 'feature-title',
          style: {
            position: 'relative',
            left: offset,
            width: featureTrack.bounds.width
          },
          onClick: this.onClick
        }, featureTrack.title);
      }
    }]);

    return FeatureControlComponent;
  }(Component);

  var SelectionDisplayComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(SelectionDisplayComponent, _Component);

    function SelectionDisplayComponent() {
      var _this;

      _classCallCheck(this, SelectionDisplayComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SelectionDisplayComponent).call(this));
      _this.state = {
        featureComponents: [],
        visible: []
      };
      _this.featureComponents = _this.featureComponents.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.updateVisible = _this.updateVisible.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }

    _createClass(SelectionDisplayComponent, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.featureComponents(this.props.selections);
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        if (this.props.selections.length !== nextProps.selections.length || nextProps.selections[0].data.model !== this.props.selections[0].data.model) {
          this.featureComponents(nextProps.selections);
        }
      }
    }, {
      key: "updateVisible",
      value: function updateVisible(idx) {
        var vis = this.state.visible;
        vis[idx] = !vis[idx];
        this.setState({
          visible: vis
        });
      }
    }, {
      key: "featureComponents",
      value: function featureComponents(selections) {
        var vis = selections.map(function () {
          return 0;
        });
        this.setState({
          visible: vis
        });
      }
    }, {
      key: "render",
      value: function render$$1(_ref, _ref2) {
        var _this2 = this;

        var onClose = _ref.onClose,
            selections = _ref.selections,
            offsetBounds = _ref.offsetBounds;
        var visible = _ref2.visible;
        // store these bounds, for checking in drawLazily()
        //let width = bioMap.domBounds ? bioMap.domBounds.width : 500;
        var fc = selections.map(function (feature, idx) {
          var dm = feature.data.model;
          var start = h("div", null, " start: ", dm.coordinates.start, " ");
          var stop = h("div", null, " stop: ", dm.coordinates.stop, " ");
          var tags = dm.tags.length > 0 && typeof dm.tags[0] !== 'undefined' ? h("div", null, "tags: ", dm.tags.join('\n'), " ") : [];
          var aliases = dm.aliases.length > 0 && typeof dm.aliases[0] !== 'undefined' ? h("div", null, " aliases: ", dm.aliases.join('\n'), " ") : [];
          return h("div", null, h("div", {
            class: 'biomap-info-name',
            onClick: function onClick() {
              return _this2.updateVisible(idx);
            }
          }, dm.name), visible[idx] ? h("div", {
            class: 'biomap-info-data'
          }, start, stop, tags, aliases) : null);
        });
        var offsetTop = Math.floor(offsetBounds.height - selections[0].data.canvasBounds.top);
        return h("div", {
          class: 'biomap-info',
          style: {
            position: 'relative',
            left: selections[0].maxX,
            top: -offsetTop
          }
        }, h("div", {
          style: {
            display: 'inline-block',
            width: '84%'
          }
        }), h("i", {
          class: 'material-icons',
          style: {
            display: 'inline-block',
            textAlign: 'right',
            marginRight: '1rem',
            marginLeft: 'auto',
            marginTop: '1rem'
          },
          onClick: onClose
        }, "close"), h("div", {
          class: 'biomap-features',
          style: {
            maxHeight: '75%',
            overflowY: 'auto'
          }
        }, fc));
      }
    }]);

    return SelectionDisplayComponent;
  }(Component);

  var BioMapComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(BioMapComponent, _Component);

    function BioMapComponent() {
      var _this;

      _classCallCheck(this, BioMapComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(BioMapComponent).call(this)); //this.setState({dirty:false});

      _this.state = {
        layout: null,
        dirty: false,
        panEvent: null,
        width: 0,
        hits: [],
        visible: false
      }; //bind eventHandlers to this

      _this.handleWheel = _this.handleWheel.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.onClick = _this.onClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.onPanStart = _this.onPanStart.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.onPan = _this.onPan.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.onPanEnd = _this.onPanEnd.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.closePopover = _this.closePopover.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }

    _createClass(BioMapComponent, [{
      key: "layoutBioMap",
      value: function layoutBioMap(cvs, bioMap) {
        var _this2 = this;

        cvs.width = this.props.minWidth;
        var mapBounds = new Bounds(cvs.getBoundingClientRect());
        var BM = new BioMap({
          bioMapModel: bioMap,
          appState: this.props.appState,
          layoutBounds: mapBounds,
          bioMapIndex: this.props.bioIndex,
          initialView: this.props.appState.allMaps[0].config,
          sub: function sub() {
            return _this2.setState({});
          }
        });
        BM.setCanvas(cvs);
        var cvsWidth = this.props.minWidth > BM.domBounds.width ? this.props.minWidth : BM.domBounds.width;
        cvs.width = cvsWidth; // this.bioMap.domBounds.width;

        var featureCtrl = this.layoutFeatureButtons(BM);
        this.setState({
          hits: [],
          visible: false,
          layout: BM,
          width: cvsWidth,
          dirty: true,
          buttons: featureCtrl
        });
        BM.offsetBounds = this.genOffsetBounds();
      }
    }, {
      key: "layoutFeatureButtons",
      value: function layoutFeatureButtons(layout) {
        var _this3 = this;

        var buttons = [];
        buttons.push(h(FeatureControlComponent, {
          featureTrack: {
            bounds: {
              width: '2em'
            },
            title: '+'
          },
          leftBound: remToPix(1),
          bioIndex: this.props.bioIndex,
          modalToggle: this.props.modalToggle,
          modalData: layout,
          newDirection: -1
        }));
        layout.children.forEach(function (child) {
          if (child instanceof FeatureTrack) {
            child.children.forEach(function (featureTrack) {
              buttons.push(h(FeatureControlComponent, {
                featureTrack: featureTrack,
                leftBound: featureTrack.canvasBounds.left,
                bioIndex: _this3.props.bioIndex,
                modalToggle: _this3.props.modalToggle,
                modalData: featureTrack,
                newDirction: 0
              }));
            });
          }
        });
        buttons.push(h(FeatureControlComponent, {
          featureTrack: {
            bounds: {
              width: '3rem'
            },
            title: '+'
          },
          leftBound: layout.domBounds.width - remToPix(3),
          bioIndex: this.props.bioIndex,
          modalToggle: this.props.modalToggle,
          modalData: layout,
          newDirection: 1
        }));
        this.setState({
          ditry: true
        });
        return buttons;
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this.layoutBioMap(this.base.children[2], this.props.bioMap);
        this.updateCanvas();
        this.state.layout.setDomBounds(new Bounds(this.base.children[2].getBoundingClientRect())); //console.log('bmc cdm', this.state.buttons);
      }
    }, {
      key: "updateCanvas",
      value: function updateCanvas() {
        var cvs = this.base.children[2];
        var bioMap = this.state.layout;
        var ww = this.props.minWidth > bioMap.domBounds.width ? this.props.minWidth : bioMap.domBounds.width;
        cvs.width = ww;
        bioMap.setDomBounds(new Bounds(cvs.getBoundingClientRect()));
        bioMap.width = ww; //bioMap.setCanvas(cvs);

        bioMap.draw();
        this.props.setLayout(this.state.layout, this.props.bioIndex);
        this.setState({
          dirty: false,
          width: bioMap.width
        });
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        if (this.state.dirty) {
          this.updateCanvas();
          this.setState({
            dirty: true
          });
        }

        if (nextProps.bioMap !== this.state.layout.model || nextProps.bioMap.tracks !== this.state.layout.model.tracks || this.props.minWidth !== nextProps.minWidth) {
          this.layoutBioMap(this.base.children[2], nextProps.bioMap);
        }
      }
    }, {
      key: "genOffsetBounds",
      value: function genOffsetBounds() {
        var cvs = this.base.children[2];
        var bnds = {
          top: cvs.offsetTop,
          bottom: cvs.offsetTop + cvs.offsetHeight,
          left: cvs.offsetLeft,
          right: cvs.offsetLeft + cvs.offsetWidth,
          width: cvs.offsetWidth,
          height: cvs.offsetHeight
        };
        this.setState({
          width: bnds.width
        });
        return bnds;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var oB = this.state.layout.offsetBounds;
        var cvs = this.base.children[2];

        if (cvs.offsetTop !== oB.top || cvs.offsetLeft !== oB.left || cvs.offsetWidth !== oB.width) {
          this.state.layout.offsetBounds = this.genOffsetBounds();
        }

        if (this.state.dirty) {
          this.updateCanvas();
        }
      }
    }, {
      key: "handleWheel",
      value: function handleWheel(evt) {
        if (evt.preventDefault) evt.preventDefault();
        this.state.layout.zoomMap(evt.deltaY);
        this.updateCanvas();
        this.setState({
          dirty: true
        });
      }
    }, {
      key: "onClick",
      value: function onClick(evt) {
        if (evt.srcEvent) evt = evt.srcEvent;
        var hits = this.state.layout.addCircle({
          x: evt.layerX,
          y: evt.layerY
        });

        if (hits.length > 0) {
          this.setState({
            hits: hits,
            visible: true
          });
        }

        this.updateCanvas();
      }
    }, {
      key: "onPan",
      value: function onPan(evt) {
        if (evt.srcEvent) {
          evt = evt.srcEvent;
        }

        this.state.layout.onPan({
          position: {
            x: evt.layerX,
            y: evt.layerY
          },
          delta: {
            x: evt.movementX,
            y: evt.movementY
          },
          type: this.state.panEvent
        });
        this.updateCanvas();
      }
    }, {
      key: "onPanStart",
      value: function onPanStart(evt) {
        if (evt.srcEvent) {
          //ignore hammer wrapper around normalised event
          evt = evt.srcEvent;
        }

        if (this.state.panEvent) {
          //Chance panStart is just an interrupted pan event
          this.state.layout.onPan({
            position: {
              x: evt.layerX,
              y: evt.layerY
            },
            eventType: this.state.panEvent
          });
        } else {
          //Determine if pan is box select/zoom or ruler drag and update BioMap components
          var panType = this.state.layout.onPanStart({
            x: evt.layerX,
            y: evt.layerY
          });
          this.setState({
            panEvent: panType
          });
        }

        this.updateCanvas();
      }
    }, {
      key: "onPanEnd",
      value: function onPanEnd(evt) {
        if (evt.srcEvent) {
          //ignore hammer wrapper around normalised event
          evt = evt.srcEvent;
        }

        var hits = this.state.layout.onPanEnd({
          position: {
            x: evt.layerX,
            y: evt.layerY
          },
          delta: {
            x: evt.movementX,
            y: evt.movementY
          },
          type: this.state.panEvent
        });

        if (hits.length > 0) {
          this.setState({
            hits: hits,
            visible: true
          });
        }

        this.setState({
          panEvent: null
        });
        this.updateCanvas();
      }
    }, {
      key: "closePopover",
      value: function closePopover() {
        this.setState({
          visible: false
        });
      }
    }, {
      key: "render",
      value: function render$$1(_ref, _ref2) {
        var bioMap = _ref.bioMap,
            bioIndex = _ref.bioIndex,
            minWidth = _ref.minWidth;
        var visible = _ref2.visible,
            hits = _ref2.hits,
            width = _ref2.width,
            buttons = _ref2.buttons,
            layout = _ref2.layout;
        // store these bounds, for checking in drawLazily()
        //let width = bioMap.domBounds ? bioMap.domBounds.width : 500;
        width = minWidth > width ? minWidth : width;
        var hOptions = {
          recognizers: {
            pan: {
              threshold: 0
            }
          }
        };
        return h("div", {
          style: {
            display: 'table-cell',
            width: width
          }
        }, h("div", {
          class: 'swap-div',
          style: {
            width: width
          }
        }, " ", bioMap.name, " ", h("br", null), " ", bioMap.source.id, " "), h("div", null, buttons), h(GestureWrapper, {
          onTap: this.onClick //doubles as onClick
          ,
          onPanStart: this.onPanStart,
          onPan: this.onPan,
          onPanEnd: this.onPanEnd,
          options: hOptions
        }, h("canvas", {
          class: 'cmap-canvas',
          id: "bioMap ".concat(bioIndex),
          style: {
            position: 'relative'
          },
          height: 700,
          onWheel: this.handleWheel
        })), visible ? h(SelectionDisplayComponent, {
          width: 20,
          height: 20,
          selections: hits,
          onClose: this.closePopover,
          offsetBounds: layout.offsetBounds
        }) : null);
      }
    }]);

    return BioMapComponent;
  }(Component);

  var FeatureEditorComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FeatureEditorComponent, _Component);

    function FeatureEditorComponent() {
      var _this;

      _classCallCheck(this, FeatureEditorComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FeatureEditorComponent).call(this));
      _this.state = {
        selected: '',
        baseColor: '',
        newColor: '',
        hueValColor: '',
        hueValCanvas: '',
        satCanvas: '',
        previewCanvas: '',
        hueValPos: {
          x: 0,
          y: 0
        },
        satPos: 0,
        hueValueWidth: 10,
        canvasHeight: 10
      };
      _this.onFilterChange = _this.onFilterChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.satLocationChange = _this.satLocationChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.hueValLocationChange = _this.hueValLocationChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.onManualColor = _this.onManualColor.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.resetColor = _this.resetColor.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.setFeature = _this.setFeature.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.removeFeature = _this.removeFeature.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }

    _createClass(FeatureEditorComponent, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.setState({
          selected: this.props.initialSelection,
          selectedIndex: this.props.tagList.indexOf(this.props.initialSelection),
          hueValCanvas: this.hueValCanvasComponent(),
          satCanvas: this.saturationCanvasComponent(),
          previewCanvas: this.previewCanvasComponent()
        });
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var hvc = this.base.children[1].children[0];
        var hvctx = hvc.getContext('2d');
        var sc = this.base.children[1].children[1];
        hvctx.fillStyle = this.props.baseColor;
        var hvcol = this.rgbToHsv(this.hexToRgb(hvctx.fillStyle));
        var calcWidth = Math.floor(this.base.offsetWidth * .25);
        var calcHeight = this.base.children[1].children[3].offsetHeight;
        hvc.height = calcHeight;
        hvc.width = calcWidth;
        sc.height = calcHeight;
        this.base.children[1].children[2].height = calcHeight;
        this.setState({
          baseColor: hvctx.fillStyle,
          newColor: hvctx.fillStyle,
          hueValColor: hvcol,
          hueValPos: this.hueValPosFromHsv(hvcol, hvc),
          satPos: this.satPosFromHSV(hvcol, sc),
          canvasHeight: this.base.children[1].children[3].offsetHeight,
          hueValueWidth: Math.floor(this.base.offsetWidth * .25)
        });
        this.redrawCanvases();
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        if (nextProps.baseColor !== this.state.baseColor) {
          this.setState({
            baseColor: nextProps.baseColor
          });
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.redrawCanvases();
      }
    }, {
      key: "redrawCanvases",
      value: function redrawCanvases() {
        this.drawHVCanvas(this.base.children[1].children[0]);
        this.drawSCanvas(this.base.children[1].children[1]);
        this.drawPCanvas(this.base.children[1].children[2]);
      }
    }, {
      key: "onFilterChange",
      value: function onFilterChange(evt) {
        var idx = evt.target.selectedIndex;
        this.setState({
          selectedIndex: idx,
          selected: this.props.tagList[idx]
        });
      }
      /**
       * Convert RGB triplet ot HSV
       * [0-255,0-255,0-255] -> [0-360,0-100,0-100]
       * @param rgb
       * @returns {*[]}
       */

    }, {
      key: "hexToRgb",
      value: function hexToRgb(hex) {
        var result = hex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
        return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)];
      }
      /**
       *  convert RGB triplet to hex
       * [0-255,0-255,0-255] -> #FFFFFF
       * @param rgb
       * @returns {string}
       */

    }, {
      key: "rgbToHex",
      value: function rgbToHex(rgb) {
        return (0x100 | Math.round(rgb[0])).toString(16).substr(1) + (0x100 | Math.round(rgb[1])).toString(16).substr(1) + (0x100 | Math.round(rgb[2])).toString(16).substr(1);
      }
      /**
       * Convert RGB triplet ot HSV
       * [0-255,0-255,0-255] -> [0-360,0-100,0-100]
       * @param rgb
       * @returns {*[]}
       */

    }, {
      key: "rgbToHsv",
      value: function rgbToHsv(rgb) {
        //make sure RGB values are within 0-255 range
        //and convert to decimal
        rgb = rgb.map(function (component) {
          return Math.max(0, Math.min(255, component)) / 255;
        }); // Conversion from RGB -> HSV colorspace

        var cmin = Math.min(Math.min(rgb[0], rgb[1]), rgb[2]);
        var cmax = Math.max(Math.max(rgb[0], rgb[1]), rgb[2]);
        var delta = parseFloat(cmax - cmin);
        var hue = 0;

        if (delta === 0) {
          hue = 0;
        } else if (cmax === rgb[0]) {
          hue = 60 * ((rgb[1] - rgb[2]) / delta);
        } else if (cmax === rgb[1]) {
          hue = 60 * ((rgb[2] - rgb[0]) / delta + 2);
        } else if (cmax === rgb[2]) {
          hue = 60 * ((rgb[0] - rgb[1]) / delta + 4);
        }

        if (hue < 0) hue += 360;
        var sat = cmax === 0 ? 0 : delta / cmax * 100;
        var value = cmax * 100;
        return [hue, sat, value];
      }
      /**
       * Convert from HSV to RGB
       * [0-360,0-100,0-100] -> [0-255,0-255,0-255]
       * @param hsv
       * @returns {*[]}
       */

    }, {
      key: "hsvToRgb",
      value: function hsvToRgb(hsv) {
        var u = 255 * (hsv[2] / 100);
        var h$$1 = hsv[0] / 60;
        var s = hsv[1] / 100;
        var i = Math.floor(h$$1);
        if (i < 0) i = 0;
        var f = i % 2 ? h$$1 - i : 1 - (h$$1 - i);
        var m = u * (1 - s);
        var n = u * (1 - s * f);

        switch (i) {
          case 6:
          case 0:
            return [u, n, m];

          case 1:
            return [n, u, m];

          case 2:
            return [m, u, n];

          case 3:
            return [m, n, u];

          case 4:
            return [n, m, u];

          case 5:
            return [u, m, n];
        }
      }
    }, {
      key: "hueValCanvasComponent",
      value: function hueValCanvasComponent() {
        var hOptions = {
          recognizers: {
            pan: {
              threshold: 1
            }
          }
        };
        return h(GestureWrapper, {
          onTap: this.hueValLocationChange,
          onPan: this.hueValLocationChange,
          options: hOptions
        }, h("canvas", {
          class: 'color-canvas-main',
          width: this.state.hueValueWidth,
          height: this.state.canvasHeight,
          style: {
            paddingRight: '1em'
          }
        }));
      }
    }, {
      key: "saturationCanvasComponent",
      value: function saturationCanvasComponent() {
        var hOptions = {
          recognizers: {
            pan: {
              threshold: 1
            }
          }
        };
        return h(GestureWrapper, {
          onTap: this.satLocationChange,
          onPan: this.satLocationChange,
          options: hOptions
        }, h("canvas", {
          class: 'color-canvas-sat',
          width: 20,
          height: this.state.canvasHeight,
          style: {
            paddingRight: '1em'
          }
        }));
      }
    }, {
      key: "previewCanvasComponent",
      value: function previewCanvasComponent() {
        return h("canvas", {
          class: 'color-canvas-preview',
          width: 20,
          height: this.state.canvasHeight,
          style: {
            paddingRight: '1em'
          }
        });
      }
    }, {
      key: "hueValLocationChange",
      value: function hueValLocationChange(evt) {
        if (evt.srcEvent) evt = evt.srcEvent;
        if (evt.target !== this.base.children[1].children[0]) return;
        var hueValue = this.state.hueValColor.slice();
        var ptrPos = {
          x: evt.layerX,
          y: evt.layerY
        };
        var hsv = this.hueValHSFromPos(ptrPos, evt.target);
        hueValue[0] = hsv[0];
        hueValue[2] = hsv[2];

        if (!hueValue[1]) {
          hueValue[1] = 100;
        }

        this.setState({
          hueValPos: ptrPos,
          hueValColor: hueValue
        });
      }
    }, {
      key: "hueValPosFromHsv",
      value: function hueValPosFromHsv(hsv, cvs) {
        // Math.round to avoid annoying sub-pixel rendering
        hsv[0] = Math.max(0, Math.min(360, hsv[0]));
        hsv[2] = Math.max(0, Math.min(100, hsv[2]));
        return {
          x: parseFloat(hsv[0] / 360) * cvs.width,
          y: (1 - hsv[2] / 100) * cvs.height
        };
      }
    }, {
      key: "hueValHSFromPos",
      value: function hueValHSFromPos(pos, cvs) {
        var h$$1 = Math.max(0, pos.x * 360 / cvs.width);
        var s = 100;
        var l = 100 * (1 - pos.y / cvs.height);
        return [h$$1, s, l];
      }
    }, {
      key: "satLocationChange",
      value: function satLocationChange(evt) {
        if (evt.srcEvent) evt = evt.srcEvent;
        if (evt.target !== this.base.children[1].children[1]) return;
        var hvcolor = this.state.hueValColor;
        var yPos = evt.layerY <= 0 ? 0 : evt.layerY >= evt.target.offsetHeight ? evt.target.offsetHeight : evt.layerY;
        hvcolor[1] = this.satSFromPos(yPos, evt.target);
        this.setState({
          satPos: yPos,
          hueValColor: hvcolor
        });
      }
    }, {
      key: "satPosFromHSV",
      value: function satPosFromHSV(hsv, cvs) {
        return Math.round((1 - hsv[1] / 100) * cvs.height);
      }
    }, {
      key: "satSFromPos",
      value: function satSFromPos(pos, cvs) {
        return 100 * (1 - pos / cvs.height);
      }
    }, {
      key: "drawHVCanvas",
      value: function drawHVCanvas(cvs) {
        var ctx = cvs.getContext('2d');
        var ptrPos = this.state.hueValPos; //reset canvas

        ctx.clearRect(0, 0, cvs.width, cvs.height); // RGB gradient

        var hGrad = ctx.createLinearGradient(0, 0, cvs.width, 0);
        hGrad.addColorStop(0 / 6, '#F00');
        hGrad.addColorStop(1 / 6, '#FF0');
        hGrad.addColorStop(2 / 6, '#0F0');
        hGrad.addColorStop(3 / 6, '#0FF');
        hGrad.addColorStop(4 / 6, '#00F');
        hGrad.addColorStop(5 / 6, '#F0F');
        hGrad.addColorStop(6 / 6, '#F00');
        ctx.fillStyle = hGrad;
        ctx.fillRect(0, 0, cvs.width, cvs.height); //Fade to black gradient

        var vGrad = ctx.createLinearGradient(0, 0, 0, cvs.height);
        vGrad.addColorStop(0, 'rgba(0,0,0,0)');
        vGrad.addColorStop(1, 'rgba(0,0,0,1)');
        ctx.fillStyle = vGrad; // Draw the selection pointer

        ctx.fillRect(0, 0, cvs.width, cvs.height);
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, cvs.width, cvs.height);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(ptrPos.x - 10, ptrPos.y);
        ctx.lineTo(ptrPos.x - 3, ptrPos.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.strokeStyle = 'white';
        ctx.moveTo(ptrPos.x - 3, ptrPos.y);
        ctx.lineTo(ptrPos.x - 1, ptrPos.y);
        ctx.moveTo(ptrPos.x + 1, ptrPos.y);
        ctx.lineTo(ptrPos.x + 3, ptrPos.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.strokeStyle = 'black';
        ctx.moveTo(ptrPos.x + 3, ptrPos.y);
        ctx.lineTo(ptrPos.x + 10, ptrPos.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(ptrPos.x, ptrPos.y - 10);
        ctx.lineTo(ptrPos.x, ptrPos.y - 3);
        ctx.stroke();
        ctx.beginPath();
        ctx.strokeStyle = 'white';
        ctx.moveTo(ptrPos.x, ptrPos.y - 3);
        ctx.lineTo(ptrPos.x, ptrPos.y - 1);
        ctx.moveTo(ptrPos.x, ptrPos.y + 1);
        ctx.lineTo(ptrPos.x, ptrPos.y + 3);
        ctx.stroke();
        ctx.beginPath();
        ctx.strokeStyle = 'black';
        ctx.moveTo(ptrPos.x, ptrPos.y + 3);
        ctx.lineTo(ptrPos.x, ptrPos.y + 10);
        ctx.stroke();
      }
    }, {
      key: "drawSCanvas",
      value: function drawSCanvas(cvs) {
        var ctx = cvs.getContext('2d');
        var ptrPos = this.state.satPos; // clear and redraw gradient slider for current picked HueValue color;

        ctx.clearRect(0, 0, cvs.width, cvs.height);
        var grad = ctx.createLinearGradient(0, 0, 0, cvs.height);
        var hueValueColor = this.state.hueValColor;
        var rgbStart = this.hsvToRgb([hueValueColor[0], 100, hueValueColor[2]]).map(function (color) {
          return Math.floor(color);
        });
        var rgbStop = this.hsvToRgb([hueValueColor[0], 0, hueValueColor[2]]).map(function (color) {
          return Math.floor(color);
        });
        grad.addColorStop(0, "rgba(".concat(rgbStart[0], ",").concat(rgbStart[1], ",").concat(rgbStart[2], ",1)"));
        grad.addColorStop(1, "rgba(".concat(rgbStop[0], ",").concat(rgbStop[1], ",").concat(rgbStop[2], ",1)"));
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, cvs.width, cvs.height); // draw slider pointer

        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, cvs.width, cvs.height);
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.strokeStyle = 'white';
        ctx.moveTo(cvs.width, ptrPos + 5);
        ctx.lineTo(cvs.width / 2, ptrPos);
        ctx.lineTo(cvs.width, ptrPos - 5);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }
    }, {
      key: "drawPCanvas",
      value: function drawPCanvas(cvs) {
        var ctx = cvs.getContext('2d');
        ctx.clearRect(0, 0, cvs.width, cvs.height);
        var rgb = this.hsvToRgb(this.state.hueValColor);
        ctx.fillStyle = "#".concat(this.rgbToHex(rgb));
        ctx.fillRect(0, 0, cvs.width, cvs.height);
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, cvs.width, cvs.height);

        if (this.state.newColor !== ctx.fillStyle) {
          this.setState({
            newColor: ctx.fillStyle
          });
        }
      }
    }, {
      key: "onManualColor",
      value: function onManualColor(evt) {
        try {
          var value = evt.srcElement.value;
          var code = value.match(/^#?([a-f\d]*)$/i);
          var str = code[1];

          if (code[1].length === 3) {
            str = "#".concat(str[0]).concat(str[0]).concat(str[1]).concat(str[1]).concat(str[2]).concat(str[2]);
          }

          this.setState({
            newColor: value,
            hueValColor: this.rgbToHsv(this.hexToRgb(str))
          });
        } catch (e) {
          return;
        }
      }
    }, {
      key: "resetColor",
      value: function resetColor() {
        var hvc = this.base.children[1].children[0];
        var hvctx = hvc.getContext('2d');
        var sc = this.base.children[1].children[1];
        hvctx.fillStyle = this.props.baseColor;
        var hvcol = this.rgbToHsv(this.hexToRgb(hvctx.fillStyle));
        this.setState({
          baseColor: hvctx.fillStyle,
          newColor: hvctx.fillStyle,
          hueValColor: hvcol,
          hueValPos: this.hueValPosFromHsv(hvcol, hvc),
          satPos: this.satPosFromHSV(hvcol, sc)
        });
        this.redrawCanvases();
      }
    }, {
      key: "setFeature",
      value: function setFeature() {
        this.props.setFeature(this.state.selected, this.state.newColor, this.props.index);
      }
    }, {
      key: "removeFeature",
      value: function removeFeature() {
        this.props.removeFeature(this.props.index);
      }
    }, {
      key: "render",
      value: function render$$1(props, state) {
        // store these bounds, for checking in drawLazily()
        return h("div", {
          class: 'row'
        }, h("select", {
          style: {
            display: 'block',
            marginTop: '2rem'
          },
          onInput: this.onFilterChange
        }, props.tagList.map(function (option) {
          return h("option", {
            selected: option === state.selected
          }, " ", option, " ");
        })), h("div", {
          class: "twelve columns",
          id: 'horizontal-layout-container'
        }, state.hueValCanvas, state.satCanvas, state.previewCanvas, h("div", {
          style: {
            display: 'inline-block'
          }
        }, h("input", {
          id: 'color-input',
          type: 'text',
          onInput: this.onManualColor,
          value: state.newColor,
          style: {
            width: '8rem'
          }
        }), h("button", {
          class: 'color-select-ctrl',
          style: {
            background: state.newColor
          },
          onClick: this.setFeature
        }, "Apply"), h("button", {
          class: 'color-select-ctrl',
          style: {
            background: props.baseColor
          },
          onClick: this.resetColor
        }, "Reset"), h("button", {
          class: 'color-select-ctrl',
          onClick: this.removeFeature
        }, "Remove"))));
      }
    }]);

    return FeatureEditorComponent;
  }(Component);

  var FeatureModal =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FeatureModal, _Component);

    function FeatureModal() {
      var _this;

      _classCallCheck(this, FeatureModal);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FeatureModal).call(this));
      _this.state = {
        isOpen: true,
        filters: [],
        fillColor: [],
        title: '',
        tagList: []
      };
      _this.onTitleChange = _this.onTitleChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.configurationElements = _this.configurationElements.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.setFeature = _this.setFeature.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.removeFeature = _this.removeFeature.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.applySelection = _this.applySelection.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.removeTrack = _this.removeTrack.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.removeFeature = _this.removeFeature.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.toggleOpen = _this.toggleOpen.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }

    _createClass(FeatureModal, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var modalData = this.props.modalData;
        var model = modalData.model || modalData.component.model;
        var tagList = model.tags ? model.tags.sort() : [];
        var featureData = modalData.config || modalData.model.config.qtl;
        var filters = featureData.filters || [];
        var fillColor = featureData.fillColor || model.config.qtl.fillColor;
        if (typeof fillColor === 'string') fillColor = [fillColor];
        this.setState({
          filters: filters.slice(),
          fillColor: fillColor.slice(),
          title: featureData.title || 'feature',
          tagList: tagList
        });
      }
    }, {
      key: "configurationElements",
      value: function configurationElements() {
        var _this2 = this;

        if (!this.state.filters.length) return null;
        return h("div", {
          id: 'color-apply-controls',
          style: {
            display: 'block'
          }
        }, this.state.filters.map(function (filter, idx) {
          var bc = _this2.state.fillColor[idx] || _this2.state.fillColor[0];
          return h(FeatureEditorComponent, {
            initialSelection: filter,
            tagList: _this2.state.tagList,
            baseColor: bc,
            index: idx,
            setFeature: _this2.setFeature,
            removeFeature: _this2.removeFeature
          });
        }));
      }
    }, {
      key: "setFeature",
      value: function setFeature(tag, color, idx) {
        var filt = this.state.filters.slice();
        var col = this.state.fillColor.slice();
        filt[idx] = tag;
        col[idx] = color;
        this.setState({
          filters: filt,
          fillColor: col
        });
      }
    }, {
      key: "filterEditor",
      value: function filterEditor(initialSelection) {
        return h("div", null, " ", initialSelection, " ");
      }
    }, {
      key: "toggleOpen",
      value: function toggleOpen() {
        this.props.modalToggle('hidden');
      }
    }, {
      key: "onTitleChange",
      value: function onTitleChange(evt) {
        this.setState({
          title: evt.srcElement.value
        });
      }
    }, {
      key: "applySelection",
      value: function applySelection() {
        var _this3 = this;

        var tracks = this.props.modalData.model.tracks.slice();

        if (Math.abs(this.props.newDirection) === 1) {
          var config = JSON.parse(JSON.stringify(this.props.modalData.model.config.qtl));
          config.title = this.state.title;
          config.filters = this.state.filters.slice();
          config.fillColor = this.state.fillColor.slice();
          config.position = this.props.newDirection;

          if (this.props.newDirection === -1) {
            tracks = [config].concat(tracks);
          } else {
            tracks = tracks.concat([config]);
          }
        } else {
          tracks.some(function (track) {
            if (track === _this3.props.modalData.config) {
              track.title = _this3.state.title;
              track.filters = _this3.state.filters.slice();
              track.fillColor = _this3.state.fillColor.slice();
              return true;
            }

            return false;
          });
        }

        this.props.appState.editFeatureTracks(this.props.modalData.model, tracks);
        this.toggleOpen();
      }
    }, {
      key: "removeTrack",
      value: function removeTrack() {
        var _this4 = this;

        if (!this.props.newDirection) {
          var tracks = this.props.modalData.model.tracks.slice();
          tracks.some(function (track, idx) {
            if (track === _this4.props.modalData.config) {
              tracks.splice(idx, 1);
              return true;
            }

            return false;
          });
          this.props.appState.editFeatureTracks(this.props.modalData.model, tracks);
          this.toggleOpen();
        }
      }
    }, {
      key: "removeFeature",
      value: function removeFeature(idx) {
        var features = this.state.filters.slice().splice(idx, 1);
        var colors = this.state.fillColor.slice();
        if (colors[idx]) colors.splice(idx, 1);
        this.setState({
          filters: features,
          fillColor: colors
        });
      }
    }, {
      key: "render",
      value: function render$$1(props, state) {
        var _this5 = this;

        // store these bounds, for checking in drawLazily()
        var featureModal = h("div", {
          class: 'twelve columns control-dialog',
          id: 'cmap-map-addition-dialog',
          style: {
            height: props.modalHeight
          }
        }, h("h5", null, " Feature Editor"), h("p", null, " Options to configure the selected feature. "), h("div", {
          class: 'twelve-columns',
          style: {
            height: '80%',
            maxHeight: '80%',
            overflowY: 'auto'
          }
        }, h("span", {
          class: 'label-body'
        }, " ", 'Track Title', " "), h("input", {
          id: 'title-input',
          type: 'text',
          placeholder: 'feature',
          onInput: this.onTitleChange,
          value: state.title
        }), this.configurationElements(), h("div", {
          class: 'row',
          style: {
            marginTop: '1rem'
          }
        }, h("button", {
          class: 'button',
          onClick: function onClick() {
            _this5.setFeature(state.tagList[0], state.fillColor[0], state.filters.length);
          }
        }, h("span", null, " Add Feature ")))), h("div", {
          class: 'cmap-modal-control'
        }, h("button", {
          class: 'button',
          onClick: this.applySelection
        }, h("i", {
          class: 'material-icons'
        }, " done "), h("span", null, " Apply ")), h("button", {
          class: 'button',
          onClick: this.toggleOpen,
          style: {
            marginLeft: '0rem'
          }
        }, h("i", {
          class: 'material-icons'
        }, " cancel "), h("span", null, " Close Menu ")), h("button", {
          class: 'button',
          onClick: this.removeTrack,
          style: {
            background: '#DA2C43',
            marginLeft: '2rem'
          }
        }, h("i", {
          class: 'material-icons'
        }, " remove_circle_outline "), h("span", null, " Remove Track "))));
        return state.isOpen && featureModal;
      }
    }]);

    return FeatureModal;
  }(Component);

  var ModalSelector =
  /*#__PURE__*/
  function (_Component) {
    _inherits(ModalSelector, _Component);

    function ModalSelector() {
      _classCallCheck(this, ModalSelector);

      return _possibleConstructorReturn(this, _getPrototypeOf(ModalSelector).apply(this, arguments));
    }

    _createClass(ModalSelector, [{
      key: "render",
      value: function render$$1(props, state) {
        // store these bounds, for checking in drawLazily()
        switch (props.menuType) {
          case 'feature':
            return h(FeatureModal, {
              modalToggle: props.modalToggle,
              modalData: props.modalData,
              modalHeight: props.modalHeight,
              appState: props.appState,
              newDirection: props.newDirection
            });

          case 'hidden':
          default:
            return null;
        }
      }
    }]);

    return ModalSelector;
  }(Component);

  var CorrespondenceMark =
  /*#__PURE__*/
  function (_SceneGraphNodeBase) {
    _inherits(CorrespondenceMark, _SceneGraphNodeBase);

    /**
     * Construct the CorrespondenceMark layer
     * @param parent - parent scene graph node
     * @param featurePair - array of features being compared
     * @param mapCoordinates - current zoom level of each feature maps
     * @param bioMap - array of both sets of map data
     */

    /**
     * TODO: Allow configuration as part of config file
     */
    function CorrespondenceMark(_ref) {
      var _this;

      var parent = _ref.parent,
          featurePair = _ref.featurePair,
          mapCoordinates = _ref.mapCoordinates,
          bioMap = _ref.bioMap;

      _classCallCheck(this, CorrespondenceMark);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(CorrespondenceMark).call(this, {
        parent: parent
      }));
      _this.model = featurePair;
      _this.mapCoordinates = mapCoordinates;
      _this.lineWidth = 1.0;
      _this.bioMap = bioMap;
      _this.invert = [bioMap[0].model.config.invert, bioMap[1].model.config.invert];
      _this.pixelScaleFactor = [bioMap[0].model.view.pixelScaleFactor, bioMap[1].model.view.pixelScaleFactor];

      var leftY = translateScale(_this.model[0].coordinates.start, bioMap[0].model.view.base, bioMap[0].model.view.visible, _this.invert[0]) * _this.pixelScaleFactor[0];

      var rightY = translateScale(_this.model[1].coordinates.start, bioMap[1].model.view.base, bioMap[1].model.view.visible, _this.invert[1]) * _this.pixelScaleFactor[1];

      _this.bounds = new Bounds({
        allowSubpixel: false,
        top: leftY,
        left: parent.bounds.left,
        height: leftY - rightY,
        width: parent.bounds.width
      });
      return _this;
    }
    /**
     * Draw the correspondence marks
     * @param {object} ctx - canvas context 2D
     */


    _createClass(CorrespondenceMark, [{
      key: "draw",
      value: function draw(ctx) {
        var bioMap = this.bioMap;
        var leftYStart = translateScale(this.model[0].coordinates.start, bioMap[0].model.view.base, bioMap[0].model.view.visible, this.invert[0]) * this.pixelScaleFactor[0];
        var rightYStart = translateScale(this.model[1].coordinates.start, bioMap[1].model.view.base, bioMap[1].model.view.visible, this.invert[1]) * this.pixelScaleFactor[1];

        if (this.model[0].coordinates.start === this.model[0].coordinates.stop && this.model[1].coordinates.start === this.model[1].coordinates.stop) {
          // correspondence line
          this.bounds.top = leftYStart;
          this.bounds.bottom = rightYStart;
          var gb = this.canvasBounds || {};
          ctx.beginPath();
          ctx.lineWidth = this.lineWidth;
          ctx.strokeStyle = '#CAA91E';
          ctx.globalAlpha = 0.7; // noinspection JSSuspiciousNameCombination

          ctx.moveTo(Math.floor(gb.left), Math.floor(gb.top)); // noinspection JSSuspiciousNameCombination

          ctx.lineTo(Math.floor(gb.right), Math.floor(gb.bottom));
          ctx.stroke();
        } else {
          // correspondence region 
          var leftYStop = translateScale(this.model[0].coordinates.stop, bioMap[0].model.view.base, bioMap[0].model.view.visible, this.invert[0]) * this.pixelScaleFactor[0];
          var rightYStop = translateScale(this.model[1].coordinates.stop, bioMap[1].model.view.base, bioMap[1].model.view.visible, this.invert[1]) * this.pixelScaleFactor[1];
          this.bounds.top = leftYStart;
          this.bounds.bottom = leftYStop;
          var gbLeft = this.canvasBounds || {}; //let leftTop = gbLeft.top;
          //let leftBot = gbLeft.bottom;

          this.bounds.top = rightYStart;
          this.bounds.bottom = rightYStop;
          var gbRight = this.canvasBounds || {}; //let rightTop = gbRight.top;
          //let rightBot = gbRight.bottom;

          ctx.beginPath();
          ctx.lineWidth = this.lineWidth;
          ctx.globalAlpha = 0.2;
          ctx.fillStyle = '#7C6400'; //'#A4870C';
          // noinspection JSSuspiciousNameCombination

          ctx.moveTo(Math.floor(gbLeft.left), Math.floor(gbLeft.top)); // noinspection JSSuspiciousNameCombination

          ctx.lineTo(Math.floor(gbLeft.left), Math.floor(gbLeft.bottom)); // noinspection JSSuspiciousNameCombination

          ctx.lineTo(Math.floor(gbRight.right), Math.floor(gbRight.bottom)); // noinspection JSSuspiciousNameCombination

          ctx.lineTo(Math.floor(gbRight.right), Math.floor(gbRight.top));
          ctx.fill();
        }
      }
    }]);

    return CorrespondenceMark;
  }(SceneGraphNodeBase);

  var CorrespondenceMap =
  /*#__PURE__*/
  function (_SceneGraphNodeCanvas) {
    _inherits(CorrespondenceMap, _SceneGraphNodeCanvas);

    function CorrespondenceMap(_ref) {
      var _this;

      var bioMapComponents = _ref.bioMapComponents,
          appState = _ref.appState,
          layoutBounds = _ref.layoutBounds;

      _classCallCheck(this, CorrespondenceMap);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(CorrespondenceMap).call(this, {}));
      _this.bioMapComponents = bioMapComponents;
      _this.appState = appState;
      _this.verticalScale = 1;
      _this.correspondenceMarks = [];

      _this._layout(layoutBounds);

      return _this;
    }
    /**
     * draw our scenegraph children our canvas element
     */


    _createClass(CorrespondenceMap, [{
      key: "draw",
      value: function draw() {
        var ctx = this.context2d;
        if (!ctx) return;
        if (!this.domBounds) return;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        var gb = this.canvasBounds || {};
        ctx.save();
        ctx.globalAlpha = 0; // noinspection JSSuspiciousNameCombination
        // noinspection JSSuspiciousNameCombination

        ctx.fillRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(gb.width), Math.floor(gb.height));
        ctx.restore();
        this.visible.map(function (child) {
          return child.data.draw(ctx);
        }); // store these bounds, for checking in drawLazily()

        this.lastDrawnCanvasBounds = this.bounds;
      }
      /**
       * getter for common features between our bioMaps.
       */

    }, {
      key: "_layout",

      /**
       * Lay out correspondence lines between features
       * @param layoutBounds - bounds of the linked canvas
       * @private
       */
      value: function _layout(layoutBounds) {
        var _this2 = this;

        this.domBounds = layoutBounds; // this.bounds (scenegraph) has the same width and height, but zero the
        // left/top because we are the root node in a canvas sceneGraphNode
        // hierarchic.

        var gb1 = this.bioMapComponents[0].backbone.markerGroup.canvasBounds;
        this.bounds = new Bounds({
          allowSubpixel: false,
          left: 1,
          top: 0,
          width: this.domBounds.width,
          height: this.domBounds.height
        });
        var corrData = [];
        var coorGroup = new SceneGraphNodeGroup({
          parent: this
        });
        coorGroup.bounds = new Bounds({
          allowSubpixel: false,
          top: gb1.top,
          left: 0,
          width: this.domBounds.width,
          height: gb1.height
        });
        this.addChild(coorGroup);
        var bioMapCoordinates = [this.bioMapComponents[0].mapCoordinates, this.bioMapComponents[1].mapCoordinates];
        this.commonFeatures.forEach(function (feature) {
          var corrMark = new CorrespondenceMark({
            parent: coorGroup,
            featurePair: feature,
            mapCoordinates: bioMapCoordinates,
            bioMap: _this2.bioMapComponents
          });
          coorGroup.addChild(corrMark);
          corrData.push({
            minX: _this2.bounds.left,
            maxX: _this2.bounds.right,
            minY: feature[0].coordinates.start,
            maxY: feature[1].coordinates.start,
            data: corrMark
          });
        });
        this.locMap.load(corrData);
      }
      /**
       * Return visible elements in R-Tree
       */

    }, {
      key: "commonFeatures",
      get: function get() {
        // TODO: support more than 2 sets of features (e.g. for circos layout)
        var leftFeatures = this.bioMapComponents[0].model.features;
        var rightFeatures = this.bioMapComponents[1].model.features; //let leftFeatures = this.bioMapComponents[0].backbone.filteredFeatures;
        //let rightFeatures = this.bioMapComponents[1].backbone.filteredFeat

        return featuresInCommon(leftFeatures, rightFeatures); //return common;
      }
    }, {
      key: "visible",
      get: function get() {
        return this.locMap.all();
      }
    }]);

    return CorrespondenceMap;
  }(SceneGraphNodeCanvas);

  var CorrespondenceMapComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(CorrespondenceMapComponent, _Component);

    function CorrespondenceMapComponent() {
      var _this;

      _classCallCheck(this, CorrespondenceMapComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(CorrespondenceMapComponent).call(this)); //this.setState({dirty:false});

      _this.state = {
        layout: null,
        dirty: false,
        refreshOffset: false,
        leftOffset: 0,
        panEvent: null,
        width: 0,
        top: 0,
        left: 0
      }; //bind eventHandlers to this

      return _this;
    }

    _createClass(CorrespondenceMapComponent, [{
      key: "layoutCorrespondenceMap",
      value: function layoutCorrespondenceMap(cvs, leftBM, rightBM) {
        var layoutBounds = new Bounds({
          top: 0,
          left: Math.floor(leftBM.offsetBounds.left + leftBM.bbGroup.bounds.right),
          right: Math.floor(rightBM.offsetBounds.left + rightBM.bbGroup.bounds.left),
          height: leftBM.domBounds.height
        });
        var CM = new CorrespondenceMap({
          bioMapComponents: [leftBM, rightBM],
          top: 0,
          layoutBounds: layoutBounds
        });
        CM.setCanvas(cvs);
        cvs.width = CM.domBounds.width; // this.bioMap.domBounds.width;
        //   let cvsWidth = this.props.minWidth > cvs.width ? this.props.minWidth : cvs.width;

        this.setState({
          layout: CM,
          width: cvs.width,
          dirty: true
        });
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this.layoutCorrespondenceMap(this.base.children[0], this.props.leftBM, this.props.rightBM);
        this.setOffsets(); //  this.updateCanvas();
        //this.setState({dirty:false});
      }
    }, {
      key: "setOffsets",
      value: function setOffsets() {
        var leftB = this.props.leftBM.offsetBounds;
        var base = this.base.children[0];
        var leftOff = leftB.left + this.props.leftBM.backbone.backbone.canvasBounds.right;
        this.setState({
          top: leftB.top - base.offsetTop,
          left: leftOff - base.offsetLeft,
          refreshOffset: false,
          leftOff: base.offsetLeft
        });
      }
    }, {
      key: "updateCanvas",
      value: function updateCanvas() {
        //let cvs = this.base.children[0];
        var corrMap = this.state.layout; //corrMap.setCanvas(cvs);

        corrMap.draw();
        this.setState({
          dirty: false
        });
      }
    }, {
      key: "resetOffset",
      value: function resetOffset() {
        this.setState({
          top: 0,
          left: 0,
          refreshOffset: true
        });
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        this.setState({
          dirty: true
        });
        var lb = this.props.leftBM;
        var rb = this.props.rightBM;
        var nlb = nextProps.leftBM;
        var nrb = nextProps.rightBM;

        if (lb.model !== nlb.model || rb.model !== nrb.model || lb.backbone.backbone.canvasBounds.right !== nlb.backbone.backbone.canvasBounds.right) {
          this.layoutCorrespondenceMap(this.base.children[0], nextProps.leftBM, nextProps.rightBM);
          this.resetOffset();
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        if (this.state.dirty) {
          this.updateCanvas();
        }

        if (this.state.refreshOffset) {
          this.setOffsets();
        } else if (this.base.children[0].offsetLeft !== this.state.leftOff + this.state.left) {
          this.layoutCorrespondenceMap(this.base.children[0], this.props.leftBM, this.props.rightBM);
          this.resetOffset();
        }
      }
    }, {
      key: "render",
      value: function render$$1(_ref, _ref2) {
        var bioIndex = _ref.bioIndex;
        var top = _ref2.top,
            left = _ref2.left;
        // store these bounds, for checking in drawLazily()
        //let width = bioMap.domBounds ? bioMap.domBounds.width : 500;
        return h("div", {
          style: {
            display: 'table-cell',
            width: 0,
            zIndex: -100
          }
        }, h("canvas", {
          class: 'cmap-canvas cmap-correspondence-map',
          id: "corrMap ".concat(bioIndex),
          style: {
            position: 'relative',
            top: top,
            left: left
          },
          height: 700
        }));
      }
    }]);

    return CorrespondenceMapComponent;
  }(Component);

  var HorizontalLayout =
  /*#__PURE__*/
  function (_LayoutBase) {
    _inherits(HorizontalLayout, _LayoutBase);

    function HorizontalLayout() {
      var _this;

      _classCallCheck(this, HorizontalLayout);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(HorizontalLayout).call(this));
      _this.state = {
        bioMapComponents: [],
        bioMaps: [],
        layouts: [],
        menuVis: 'hidden',
        menuTarget: null,
        corrComponents: []
      };
      _this.modalToggle = _this.modalToggle.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.setBMLayout = _this.setBMLayout.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.layoutCorrespondenceMaps = _this.layoutCorrespondenceMaps.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }

    _createClass(HorizontalLayout, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this._layoutBioMaps(this.props.appState); //this.setState({bioMapComponents: bioMapComponents, bioMaps: this.props.appState.bioMaps.length});

      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {}
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps() {
        if (this.props.appState.bioMaps.length !== this.state.bioMaps) this._layoutBioMaps();
      } //componentWillUpdate() {
      //}

    }, {
      key: "modalToggle",
      value: function modalToggle(newMenu, menuTarget, menuNew) {
        this.setState({
          menuVis: newMenu,
          menuTarget: menuTarget,
          menuAdd: menuNew
        });
      }
    }, {
      key: "setBMLayout",
      value: function setBMLayout(layout, idx) {
        var layouts = this.state.layouts;
        layouts[idx] = layout;
        this.setState({
          layouts: layouts
        });

        if (layouts.indexOf(0) === -1 && this.state.corrComponents.length !== layouts.length - 1) {
          this.layoutCorrespondenceMaps();
        }
      }
    }, {
      key: "_layoutBioMaps",
      value: function _layoutBioMaps() {
        var _this2 = this;

        var appState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.appState;
        var activeMaps = appState.bioMaps;
        var bmbounds = new Bounds(this.props.bounds);
        var minWidth = Math.floor(bmbounds.width / activeMaps.length) - 2;
        var lay = activeMaps.map(function () {
          return 0;
        });
        this.setState({
          layouts: lay
        });
        var bioMapComponents = activeMaps.map(function (model, mapIndex) {
          //let BM = new BioMap({
          //  bioMapModel:model,
          //  appState: appState,
          //  layoutBounds: bmbounds,
          //  bioMapIndex : mapIndex,
          //  initialView: appState.allMaps[0].config,
          //  sub: () => this.setState({})
          //});
          return h(BioMapComponent, {
            bioMap: model,
            appState: appState,
            bioIndex: mapIndex,
            minWidth: minWidth,
            style: 'display:table-cell; width:400px;',
            setLayout: _this2.setBMLayout,
            modalToggle: _this2.modalToggle,
            modalData: _this2.state.menuTarget
          });
        });
        this.setState({
          bioMapComponents: bioMapComponents,
          bioMaps: this.props.appState.bioMaps.length
        }); // Add map controls
      }
    }, {
      key: "layoutCorrespondenceMaps",
      value: function layoutCorrespondenceMaps() {
        var layouts = this.state.layouts;
        var cmap = [];

        for (var i = 0; i < layouts.length - 1; i++) {
          cmap.push(h(CorrespondenceMapComponent, {
            bioIndex: i,
            leftBM: layouts[i],
            rightBM: layouts[i + 1]
          }));
        }

        this.setState({
          corrComponents: cmap
        });
      }
    }, {
      key: "render",
      value: function render$$1(props, state) {
        //let bmc = null;
        //if (props.appState.bioMaps.length !== this.state.bioMaps) bmc = this._layoutBioMaps();
        return (//<div class={'container'} id={'layout-container'} style={{width:'100%', maxWidth:'100%'}} >
          h("div", {
            class: 'row',
            style: {
              position: 'relative'
            }
          }, h("div", {
            class: "twelve columns",
            style: {
              maxHeight: props.maxHeight || '100%',
              overflow: 'auto'
            },
            id: 'horizontal-layout-container'
          }, state.menuVis !== 'hidden' ? h(ModalSelector, {
            menuType: state.menuVis,
            modalToggle: this.modalToggle,
            modalData: state.menuTarget,
            modalHeight: props.maxHeight,
            appState: props.appState,
            newDirection: state.menuAdd
          }) : [state.bioMapComponents, state.corrComponents])) //</div>

        );
      }
    }]);

    return HorizontalLayout;
  }(LayoutBase);

  var AddMapDialog =
  /*#__PURE__*/
  function (_Component) {
    _inherits(AddMapDialog, _Component);

    function AddMapDialog() {
      var _this;

      _classCallCheck(this, AddMapDialog);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AddMapDialog).call(this));
      _this.state = {
        mapSources: [],
        selection: null,
        isOpen: true
      };
      return _this;
    }

    _createClass(AddMapDialog, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var newSources = this.state.mapSources;
        this.props.appState.allMaps.forEach(function (map) {
          if (newSources.indexOf(map.source.id) === -1) newSources.push(map.source.id);
        });
        this.setState({
          mapSources: newSources
        });
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps() {
        if (!this.state.isOpen) this.toggleOpen();
      }
    }, {
      key: "generateSelections",
      value: function generateSelections(mapSet) {
        var _this2 = this;

        var maps = this.props.appState.allMaps.filter(function (map) {
          return map.source.id === mapSet && _this2.props.appState.bioMaps.indexOf(map) === -1;
        });
        var selected = this.state.selection;
        return maps.map(function (map) {
          return h("label", null, h("input", {
            type: 'radio',
            name: "maps4".concat(mapSet),
            value: map.uniqueName,
            checked: selected === map,
            onChange: function onChange(evt) {
              _this2.onSelection(evt, map);
            }
          }), h("span", {
            class: 'label-body'
          }, " ", map.name, " "));
        });
      }
    }, {
      key: "toggleOpen",
      value: function toggleOpen() {
        if (this.state.isOpen) {
          this.props.toggleVis('hidden');
        }

        this.setState({
          isOpen: !this.state.isOpen
        });
      }
    }, {
      key: "onSelection",
      value: function onSelection(evt, map) {
        evt.preventDefault();
        this.setState({
          selection: map
        });
      }
    }, {
      key: "render",
      value: function render$$1(_ref, _ref2) {
        var _this3 = this;

        var appState = _ref.appState,
            maxHeight = _ref.maxHeight;
        var mapSources = _ref2.mapSources,
            selection = _ref2.selection,
            isOpen = _ref2.isOpen;
        // store these bounds, for checking in drawLazily()
        var selectable = [];
        mapSources.forEach(function (source) {
          selectable.push(h("tr", null, h("td", null, " ", source), h("td", null, _this3.generateSelections(source))));
        });
        var addModal = h("div", {
          class: 'twelve columns control-dialog',
          id: 'cmap-map-addition-dialog',
          style: {
            maxHeight: maxHeight
          }
        }, h("h5", null, " Add Map"), h("p", null, " Select a map from the available map sets to add to the current view. "), h("form", {
          class: 'twelve-columns',
          style: {
            maxHeight: maxHeight * .30,
            overflowY: 'auto'
          }
        }, h("thead", null, h("tr", null, h("th", null, " Data Source"), h("th", null, " Available Maps"))), h("tbody", null, selectable)), h("div", {
          class: 'cmap-modal-control'
        }, h("button", {
          disabled: !selection,
          class: this.selection ? 'button-primary' : 'button',
          onClick: function onClick() {
            appState.addBioMap(selection, 0);

            _this3.setState({
              selection: null
            });
          }
        }, h("i", {
          class: 'material-icons'
        }, " keyboard_arrow_left "), h("span", null, " Add Map On Left ")), h("button", {
          disabled: !selection,
          class: this.selection ? 'button-primary' : 'button',
          onClick: function onClick() {
            appState.addBioMap(selection, 1);

            _this3.setState({
              selection: null
            });
          }
        }, h("i", {
          class: 'material-icons'
        }, " keyboard_arrow_right "), h("span", null, " Add Map On Right ")), h("button", {
          class: 'button',
          onClick: function onClick() {
            _this3.toggleOpen();
          }
        }, h("i", {
          class: 'material-icons'
        }, " cancel "), h("span", null, " Close Menu "))));
        return isOpen && addModal;
      }
    }]);

    return AddMapDialog;
  }(Component);

  var RemoveMapDialog =
  /*#__PURE__*/
  function (_Component) {
    _inherits(RemoveMapDialog, _Component);

    function RemoveMapDialog() {
      var _this;

      _classCallCheck(this, RemoveMapDialog);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(RemoveMapDialog).call(this));
      _this.state = {
        mapSources: [],
        selection: [],
        isOpen: true
      };
      return _this;
    }

    _createClass(RemoveMapDialog, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var newSources = this.state.mapSources;
        this.props.appState.bioMaps.forEach(function (map) {
          if (newSources.indexOf(map.uniqueName) === -1) {
            newSources.push(map.uniqueName);
          }
        });
        this.setState({
          mapSources: newSources
        });
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps() {
        if (!this.state.isOpen) this.toggleOpen();
      }
    }, {
      key: "generateSelections",
      value: function generateSelections(mapSet) {
        var _this2 = this;

        return mapSet.map(function (map) {
          var checked = _this2.state.selection.indexOf(map) !== -1;
          return h("label", null, h("input", {
            type: 'checkbox',
            name: "maps4".concat(map.uniqueName),
            checked: checked,
            onClick: function onClick(evt) {
              checked = !checked;

              _this2.onSelection(evt, map);
            }
          }), h("span", {
            class: 'label-body'
          }, " ", map.uniqueName, " "));
        });
      }
    }, {
      key: "toggleOpen",
      value: function toggleOpen() {
        if (this.state.isOpen) {
          this.props.toggleVis('hidden');
        }

        this.setState({
          isOpen: !this.state.isOpen
        });
      }
    }, {
      key: "onSelection",
      value: function onSelection(evt, map) {
        var selection = this.state.selection.slice();
        var i = selection.indexOf(map);

        if (i === -1) {
          selection.push(map);
        } else {
          selection.splice(i, 1);
        }

        this.setState({
          selection: selection
        });
      }
    }, {
      key: "render",
      value: function render$$1(_ref, _ref2) {
        var _this3 = this;

        var appState = _ref.appState,
            maxHeight = _ref.maxHeight;
        var selection = _ref2.selection,
            isOpen = _ref2.isOpen;
        // store these bounds, for checking in drawLazily()
        var selectable = h("tr", null, h("td", null, this.generateSelections(appState.bioMaps)));
        var removeModal = h("div", {
          class: 'twelve columns control-dialog',
          id: 'cmap-map-removal-dialog',
          style: {
            maxHeight: maxHeight
          }
        }, h("h5", null, " Remove Maps"), h("p", null, " Select maps from the currently displayed map sets to remove from the current view. "), h("form", {
          class: 'twelve-columns',
          style: {
            maxHeight: maxHeight * .3,
            overflowY: 'auto'
          }
        }, h("thead", null, h("tr", null, h("th", null, " Available Maps"), h("th", null))), h("tbody", null, selectable)), h("div", {
          class: 'cmap-modal-control'
        }, h("button", {
          disabled: selection.length === 0,
          class: selection.length === 0 ? 'button-primary' : 'button',
          onClick: function onClick() {
            appState.removeBioMap(selection);

            _this3.setState({
              selection: []
            });
          }
        }, h("i", {
          class: 'material-icons'
        }, " remove_circle_outline "), h("span", null, "Remove Maps")), h("button", {
          class: 'button',
          onClick: function onClick() {
            _this3.toggleOpen();
          }
        }, h("i", {
          class: 'material-icons'
        }, " cancel "), h("span", null, " Close Menu "))));
        return isOpen && removeModal;
      }
    }]);

    return RemoveMapDialog;
  }(Component);

  var ExportDialog =
  /*#__PURE__*/
  function (_Component) {
    _inherits(ExportDialog, _Component);

    function ExportDialog() {
      var _this;

      _classCallCheck(this, ExportDialog);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ExportDialog).call(this));
      _this.state = {
        isOpen: true
      };
      return _this;
    }

    _createClass(ExportDialog, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps() {
        if (!this.state.isOpen) this.toggleOpen();
      }
    }, {
      key: "toggleOpen",
      value: function toggleOpen() {
        if (this.state.isOpen) {
          this.props.toggleVis('hidden');
        }

        this.setState({
          isOpen: !this.state.isOpen
        });
      }
    }, {
      key: "render",
      value: function render$$1(_ref, _ref2) {
        var _this2 = this;

        var maxHeight = _ref.maxHeight;
        var isOpen = _ref2.isOpen;
        // store these bounds, for checking in drawLazily()
        var configureModal = h("div", {
          class: 'twelve columns control-dialog',
          id: 'cmap-map-addition-dialog',
          style: {
            maxHeight: maxHeight
          }
        }, h("h5", null, " Configure Maps"), h("p", null, " Options to configure current view will go here. "), h("form", {
          class: 'twelve-columns',
          style: {
            maxHeight: maxHeight * .30,
            overflowY: 'auto'
          }
        }, h("thead", null, h("th", null, " filler")), h("tbody", null, h("tr", null, " more filler"))), h("div", {
          class: 'cmap-modal-control'
        }, h("button", {
          class: 'button',
          onClick: function onClick() {
            return _this2.toggleOpen();
          }
        }, h("i", {
          class: 'material-icons'
        }, " cancel "), h("span", null, " Close Menu "))));
        return isOpen && configureModal;
      }
    }]);

    return ExportDialog;
  }(Component);

  var ExportDialog$1 =
  /*#__PURE__*/
  function (_Component) {
    _inherits(ExportDialog, _Component);

    function ExportDialog() {
      var _this;

      _classCallCheck(this, ExportDialog);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ExportDialog).call(this));
      _this.state = {
        format: 'png',
        location: '',
        isOpen: true
      };
      return _this;
    }

    _createClass(ExportDialog, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps() {
        if (!this.state.isOpen) this.toggleOpen();
      }
    }, {
      key: "genFormatSelection",
      value: function genFormatSelection() {
        var _this2 = this;

        return ['png', 'tiff', 'jpg'].map(function (format) {
          return h("label", null, h("input", {
            type: 'radio',
            name: format,
            value: format,
            checked: _this2.state.format === format,
            onChange: function onChange(evt) {
              _this2.onSelection(evt, format);
            }
          }), h("span", {
            class: 'label-body'
          }, " ", format, " "));
        });
      }
    }, {
      key: "toggleOpen",
      value: function toggleOpen() {
        if (this.state.isOpen) {
          this.props.toggleVis('hidden');
        }

        this.setState({
          isOpen: !this.state.isOpen
        });
      }
    }, {
      key: "onSelection",
      value: function onSelection(evt, format) {
        evt.preventDefault();
        this.setState({
          format: format
        });
      }
    }, {
      key: "onInput",
      value: function onInput(evt) {
        this.setState({
          location: evt.srcElement.value
        });
      }
    }, {
      key: "onExport",
      value: function onExport(evt) {
        evt.preventDefault();
        var cmapCanvases = Array.from(document.getElementsByClassName('cmap-canvas'));
        var width = 0;
        var height = 0; //figure out max height/width for tmp canvas

        cmapCanvases.forEach(function (canvas) {
          var testWidth = parseInt(canvas.offsetLeft) + parseInt(canvas.offsetWidth);
          var testHeight = parseInt(canvas.offsetHeight);
          width = width > testWidth ? width : testWidth;
          height = height > testHeight ? height : testHeight;
        }); // create tmp canvas to draw canvas elements on.

        var tmpCvs = document.createElement('canvas');
        var ctx = tmpCvs.getContext('2d');
        tmpCvs.height = height;
        tmpCvs.width = width;
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, tmpCvs.width, tmpCvs.height); // put new canvas images on meta canvas.

        cmapCanvases.forEach(function (canvas) {
          ctx.drawImage(canvas, parseInt(canvas.offsetLeft), 0);
        }); //open rendered image in newWindow

        var dl = document.createElement('a');
        var format = this.state.format;
        var image = tmpCvs.toDataURL("image/".concat(format));
        dl.setAttribute('href', image);
        var name = this.state.location || 'cmapimage';
        dl.setAttribute('download', "".concat(name, ".").concat(format)); //window.open(image,'cmap.png','title=yes');

        document.body.appendChild(dl);
        dl.click();
        document.body.removeChild(dl);
      }
    }, {
      key: "render",
      value: function render$$1(_ref, _ref2) {
        var _this3 = this;

        var maxHeight = _ref.maxHeight;
        var location = _ref2.location,
            isOpen = _ref2.isOpen;
        // store these bounds, for checking in drawLazily()
        var formatSelector = this.genFormatSelection();
        var exportModal = h("div", {
          class: 'twelve columns control-dialog',
          id: 'cmap-map-addition-dialog',
          style: {
            maxHeight: maxHeight
          }
        }, h("h5", null, " Export Image"), h("p", null, " Export current view as an image. "), h("form", {
          class: 'twelve-columns',
          style: {
            maxHeight: maxHeight * .30,
            overflowY: 'auto'
          }
        }, h("thead", null, h("tr", null, h("th", null, " Export as Image"), h("th", null))), h("tbody", null, h("tr", null, h("td", null, " File Name:"), h("td", null, h("input", {
          id: 'export-location-input',
          type: 'text',
          placeholder: 'cmapimage',
          onInput: function onInput() {
            _this3.onInput();
          },
          value: location
        }))), h("tr", null, h("td", null, " Image Format:"), h("td", null, formatSelector)))), h("div", {
          class: 'cmap-modal-control'
        }, h("button", {
          class: 'button',
          onClick: function onClick(evt) {
            return _this3.onExport(evt);
          }
        }, h("div", null, h("i", {
          class: 'material-icons'
        }, " get_app "), h("span", null, " Export Image "))), h("button", {
          class: 'button',
          onClick: function onClick() {
            return _this3.toggleOpen();
          }
        }, h("i", {
          class: 'material-icons'
        }, " cancel "), h("span", null, " Close Menu "))));
        return isOpen && exportModal;
      }
    }]);

    return ExportDialog;
  }(Component);

  var MenuComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(MenuComponent, _Component);

    function MenuComponent() {
      _classCallCheck(this, MenuComponent);

      return _possibleConstructorReturn(this, _getPrototypeOf(MenuComponent).apply(this, arguments));
    }

    _createClass(MenuComponent, [{
      key: "render",
      value: function render$$1(_ref) {
        var menu = _ref.menu,
            set = _ref.set,
            maxHeight = _ref.maxHeight,
            appState = _ref.appState;

        // store these bounds, for checking in drawLazily()
        switch (menu) {
          case 'add':
            return h(AddMapDialog, {
              toggleVis: set,
              maxHeight: maxHeight,
              appState: appState
            });

          case 'remove':
            return h(RemoveMapDialog, {
              toggleVis: set,
              maxHeight: maxHeight,
              appState: appState
            });

          case 'configure':
            return h(ExportDialog, {
              toggleVis: set,
              maxHeight: maxHeight,
              appState: appState
            });

          case 'export':
            return h(ExportDialog$1, {
              toggleVis: set,
              maxHeight: maxHeight,
              appState: appState
            });

          case 'hidden':
          default:
            return null;
        }
      }
    }]);

    return MenuComponent;
  }(Component);

  var DialogSelectButton =
  /*#__PURE__*/
  function (_Component) {
    _inherits(DialogSelectButton, _Component);

    function DialogSelectButton(props) {
      var _this;

      _classCallCheck(this, DialogSelectButton);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DialogSelectButton).call(this, props));
      _this.state = {
        visible: 'hidden'
      };
      return _this;
    }

    _createClass(DialogSelectButton, [{
      key: "onClick",
      value: function onClick() {
        var visible = this.props.visible === this.props.dialog ? 'hidden' : this.props.dialog;
        this.props.set(visible);
      }
    }, {
      key: "render",
      value: function render$$1(_ref) {
        var _this2 = this;

        var icon = _ref.icon,
            text = _ref.text;
        // store these bounds, for checking in drawLazily()
        return h(GestureWrapper, {
          onTap: function onTap() {
            return _this2.onClick();
          } //doubles as onClick

        }, h("div", {
          class: 'three columns button'
        }, h("div", null, h("i", {
          class: 'material-icons'
        }, " ", icon, " "), h("span", null, " ", text, " "))));
      }
    }]);

    return DialogSelectButton;
  }(Component);

  var CMAP =
  /*#__PURE__*/
  function (_Component) {
    _inherits(CMAP, _Component);

    function CMAP() {
      var _this;

      _classCallCheck(this, CMAP);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(CMAP).call(this));

      _this.setState({
        viewPort: null
      });

      _this.setState({
        menuVisible: null
      });

      _this.setState({
        layoutMax: 0
      });

      _this.setMenuComponent = _this.setMenuComponent.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }

    _createClass(CMAP, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.updateBounds();
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps() {
        this.updateBounds();
      }
    }, {
      key: "updateBounds",
      value: function updateBounds() {
        var bnds = new Bounds(this.base.getBoundingClientRect());
        this.setState({
          viewPort: bnds
        });
      }
    }, {
      key: "setMenuComponent",
      value: function setMenuComponent(newComponent) {
        this.setState({
          menuVisible: newComponent
        });
      }
    }, {
      key: "render",
      value: function render$$1(_ref, _ref2) {
        var appModel = _ref.appModel,
            maxHeight = _ref.maxHeight;
        var viewPort = _ref2.viewPort,
            menuVisible = _ref2.menuVisible;
        var b2 = this.base ? this.base.getBoundingClientRect() : null;
        var layoutMax = b2 ? maxHeight - this.base.childNodes[0].offsetHeight : maxHeight;
        return h("div", {
          id: 'cmap-main-app',
          class: 'row',
          style: {
            maxHeight: maxHeight || '100%',
            height: 10000
          }
        }, h("div", {
          class: "row cmap",
          id: "cmap-controls"
        }, h(DialogSelectButton, {
          text: 'Add Map',
          icon: 'add_circle_outline',
          dialog: 'add',
          visible: menuVisible,
          set: this.setMenuComponent
        }), h(DialogSelectButton, {
          text: 'Remove Maps',
          icon: 'remove_circle_outline',
          dialog: 'remove',
          visible: menuVisible,
          set: this.setMenuComponent
        }), h(DialogSelectButton, {
          text: 'Configuration',
          icon: 'mode_edit',
          dialog: 'configure',
          visible: menuVisible,
          set: this.setMenuComponent
        }), h(DialogSelectButton, {
          text: 'Export Image',
          icon: 'get_app',
          dialog: 'export',
          visible: menuVisible,
          set: this.setMenuComponent
        })), h("div", {
          class: 'row'
        }, h(MenuComponent, {
          set: this.setMenuComponent,
          menu: menuVisible,
          appState: appModel,
          maxHeight: layoutMax
        })), viewPort ? h(HorizontalLayout, {
          appState: appModel,
          bounds: b2,
          maxHeight: layoutMax
        }) : null);
      }
    }]);

    return CMAP;
  }(Component);

  var Header =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Header, _Component);

    function Header() {
      _classCallCheck(this, Header);

      return _possibleConstructorReturn(this, _getPrototypeOf(Header).call(this));
    }

    _createClass(Header, [{
      key: "render",
      value: function render$$1(_ref) {
        var header = _ref.header;
        return h("div", {
          class: "row cmap",
          id: "cmap-head"
        }, h("div", {
          class: "twelve columns"
        }, h("p", {
          class: "cmap-header"
        }, " cmap-js", h("span", {
          class: "cmap-header"
        }, header))));
      }
    }]);

    return Header;
  }(Component);

  var StatusBar =
  /*#__PURE__*/
  function (_Component) {
    _inherits(StatusBar, _Component);

    function StatusBar() {
      _classCallCheck(this, StatusBar);

      return _possibleConstructorReturn(this, _getPrototypeOf(StatusBar).apply(this, arguments));
    }

    _createClass(StatusBar, [{
      key: "render",
      //// constructor() - prefer do not use in mithril dataSourceComponents
      // /**
      //  *
      //  * @param vnode
      //  */
      // oninit(vnode) {
      //   this.appState = vnode.attrs.appState;
      // }
      // /**
      //  *
      //  * @returns {*}
      //  */
      value: function render$$1(_ref) {
        var attribution = _ref.attribution;
        return h("div", {
          class: "cmap",
          id: 'cmap-foot'
        }, h("div", {
          class: "row"
        }, h("div", {
          class: "twelve columns cmap-attribution"
        }, attribution, " ")), h("div", {
          class: "row"
        }, h("div", {
          class: "twelve columns",
          id: "cmap-disclaimer"
        }, " cmap-js is still in alpha. As the software is still in development, the current state of the project may not reflect the final release.")));
      }
    }]);

    return StatusBar;
  }(Component);

  var Alert =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Alert, _Component);

    function Alert() {
      var _this;

      _classCallCheck(this, Alert);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Alert).call(this));

      _this.setState({
        visible: true
      });

      return _this;
    }

    _createClass(Alert, [{
      key: "close",
      value: function close() {
        this.setState({
          visible: false
        });
      }
    }, {
      key: "render",
      value: function render$$1(_ref, _ref2) {
        var _this2 = this;

        var message = _ref.message;
        var visible = _ref2.visible;
        if (!visible) return null;
        return h("div", {
          class: "container",
          style: {
            width: '100%'
          }
        }, h("div", {
          class: "row alert"
        }, h("div", {
          class: "eleven columns"
        }, message), h("div", {
          class: "one column"
        }, h("button", {
          class: "close-button",
          onClick: function onClick() {
            return _this2.close();
          }
        }, "X"))));
      }
    }]);

    return Alert;
  }(Component);

  var Loading =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Loading, _Component);

    function Loading() {
      var _this;

      _classCallCheck(this, Loading);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Loading).call(this));

      _this.setState({
        visible: true
      });

      _this.setState({
        newit: true
      });

      return _this;
    }

    _createClass(Loading, [{
      key: "close",
      value: function close() {
        this.setState({
          visible: false
        });
      }
    }, {
      key: "render",
      value: function render$$1(_ref, _ref2) {
        var status = _ref.status;
        var visible = _ref2.visible;
        if (!visible) return null;
        return h("div", {
          class: "row loading-row"
        }, h("div", {
          class: "one column"
        }, " ", h("p", null), " "), h("div", {
          class: "ten columns loading-col"
        }, h("div", {
          class: "loading-spinner"
        }, h("img", {
          class: "loading-element",
          src: "images/ajax-loader.gif"
        }), h("h5", {
          class: "loading-element"
        }, status))), h("div", {
          class: "one column"
        }, " ", h("p", null), " "));
      }
    }]);

    return Loading;
  }(Component);

  var UI =
  /*#__PURE__*/
  function (_Component) {
    _inherits(UI, _Component);

    function UI() {
      var _this;

      _classCallCheck(this, UI);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(UI).call(this)); //grab query string
      //let query = queryString.parse(location.search);
      //let configURL = query.config || 'cmap.json';

      var configURL = 'cmap.json';
      _this.model = new AppModel(configURL, function () {
        _this.setState({});

        _this.updateDimensions();
      });
      return _this;
    }

    _createClass(UI, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.updateDimensions();
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        window.addEventListener('resize', function () {
          return _this2.updateDimensions();
        }); //resize div max heights on window resize

        this.updateDimensions();
      }
    }, {
      key: "updateDimensions",
      value: function updateDimensions() {
        this.setState({
          windowHeight: document.querySelector('#cmap-div').offsetHeight,
          // Height of cmap-div to bound drawn stuff
          headerHeight: this.base ? this.base.children['cmap-head'].offsetHeight : 0,
          //Height of header
          footerHeight: this.base ? this.base.children['cmap-foot'].offsetHeight : 0 //Height of footer

        });
      }
    }, {
      key: "render",
      value: function render$$1(props, state) {
        var canvasRegionMaxHeight = state.windowHeight - state.headerHeight - state.footerHeight;
        canvasRegionMaxHeight = canvasRegionMaxHeight < 0 ? 1 : canvasRegionMaxHeight;
        return h("div", {
          class: "cmap app-main",
          style: {
            height: state.windowHeight || 0
          },
          id: "cmap-app"
        }, this.model.error ? h(Alert, {
          message: this.model.status
        }) : null, h(Header, {
          header: this.model.header
        }), this.model.allMaps.length > 0 ? h(CMAP, {
          appModel: this.model,
          maxHeight: canvasRegionMaxHeight
        }) : null, this.model.busy && !this.model.error ? h(Loading, {
          status: this.model.status
        }) : null, h(StatusBar, {
          attribution: this.model.attribution
        }));
      }
    }]);

    return UI;
  }(Component);

  /**
   * @file
   * Instantiate the CMAP class, and initialize it.
   * Also the entry point for bundling of javascript and css.
   */
  render(h(UI, null), document.querySelector('#cmap-div'));

}());
//# sourceMappingURL=cmap.min.js.map
